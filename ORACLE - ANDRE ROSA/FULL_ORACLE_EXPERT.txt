-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
														-- ORACLE EXPERT: SQL E PL/SQL --
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
SECAO 1: INTRODUCAO

1.Apresentacao

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
2.Introducao

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
3.Instalando o Oracle XE

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
4.Configurando SQL Developer

Criado o banco de dados Ora XE

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
5.Criando TableEspace

O que é uma tablespace???

Um banco de dados Oracle consiste em uma ou mais "unidades de armazenamento lógicas" denominadas tablespaces, que armazenam coletivamente todos os dados do
banco de dados.

Cada tablespace em um banco de dados Oracle consiste em um ou mais arquivos denominados arquivos de dados (datafile), que são estruturas físicas compatíveis 
como o sistema operacional no qual o Oracle é executado.


-- criando tablespace
create tablespace curso
 datafile
   'C:\oraclexe\app\oracle\oradata\XE\curso.dbf' 
		size 100m autoextend on next 50m maxsize 500m
   online
   permanent
   extent management local autoallocate
   segment space management auto;
   
   -- criando usuario 
   create user aluno -- usuario
          identified by aluno -- senha
          default tablespace curso
          temporary tablespace TEMP;
  -- permissao para aluno        
  grant create session, connect, resource to aluno;
  
  alter user aluno quota unlimited on curso;
  
  
  --deletar user
  drop user aluno;
  --deletar tablespace
DROP TABLESPACE curso
  INCLUDING CONTENTS and  DATAFILES
    CASCADE CONSTRAINTS;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
6.Historico Linguagem SQL 

SQL - Structure Query Language

A primeira versao da linguagem SQL, chamada SEQUEL (Structure Query English Language), surgiu em 1974 nos laboratorios da IBM (Califórnia).
Entre 1976 e 1977 ela foi revisada e ampliada, tendo então o seu nome alterado para SQL.

Em 1982 o American National Standard Institute (ANSI) tornou a SQL a linguagem padrão para a manipulação de dados em ambiente relacional.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
7.Definição PL/SQL

PL/SQL - Procedural Language Extension to SQL

O linguagem PL/SQL foi introduzida no ano de 1988 como parte do conjunto de tecnologias que compunha a versão 6.0 do SGBD Oracle.
Ela possibilita o desenvolvimento de programas que são armazenados, compilados e executados dentro do servidor de banco de dados Oracle.
É tipicamente utilizada para a criação de aplicações de missão crítica, que requerem alto desempenho na execução de suas tarefas.

pesquisar: db-engines.com   -- rank dos banco de dados

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
8.Conceitos DB Parte1


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
9.Conceitos DB PArte2

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.Diagrama de Dados

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
11.Caracteristicas de Banco de Dados Relacional

Permite o controle de redundância de dados 
Garante a integridade dos dados atraves das constrants
Garante privacidade, podemos restringir quem terá acesso
Otmização de espaço de armazenamento
Controle automático de relacionamento entre tabelas de dados
Performance de acesso, relacionamente correto atraves dos indices

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
12.MER - Modelo Entidade Relacionamento

MER Como o nome sugere, é um modelo conceitual utilizado na Engenharia de Software para descrever os objetos (Entidades) envolvidos em um domínio de negócios, 
com suas características (Atributos) e como elas se relacionam entre si (Relacionamento).
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
13.Cardinalidade

1 para 1 
	1-1 Ex: Em um banco de dados de currículos, cada usuário cadastrado pode possuir apenas um currículo na base, ao mesmo tempo em que cada currículo só
	pertence a um único usuário cadastrado.
	
1 para muitos
	1-N Ex: Sistema de plano de saúde, um usuário pode ter vários dependentes, mas cada dependente só pode estar ligado a um usuário principal.
	
Muitos para Muitos
	N-N Ex: Sistema de biblioteca, um título pode ser escrito por vários autores, ao mesmo tempo em que um autor pode escrever vários títulos.
	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
14.SGBD

Sistema de banco de dados:
 Formado por: Dados, Hardware, Software e Usuários

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
15.Tipos de Dados

Texto: String
Numerico: Inteiros ou Decimais
Datas: Temporais

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
16.ACID e CRUD
ACID: Conceito - Propriedade de Transações

A - Automicidade: Uma transação é uma unidade atômica de processamento, ou ela é executada na sua totalidade, ou então nada é executado.
C - Consistência: A execução de uma transação deve manter a consistência de um banco de dados.
I - Isolamento: Uma transação não deve tornar visível para outras transações as modificações feitas em um banco de dados até que ele seja encerrado com sucesso.
D - Durabilidade: Uma vez executado com sucesso, as alterações feitas por uma transação devem persitir, mesmo se houver falhas subsequentes no sistema.

CRUD: Conceito - É o agrônimo para as 4 operações básicas de um banco de dados.

C - Create
R - Read (SELECT)
U - Update
D - Delete

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
17.CONSTRAINTS

Constraint são utilizadas para especificar regras de armazenamentos de dados nas tabelas e garantir integridade.

Tipos de CONSTRAINTS:

NOT NULL -  Garante que uma coluna não receba valor NULL
UNIQUE - Garante que os valores em uma coluna sejam diferentes
PRIMARY KEY -  Chave única, linha exclusiva
FOREIGN KEY - Chave estrangeira, referencia o valor de um campo em determinada linha a outra tabela.
DEFAULT - Define um valor padrão para uma coluna quando nenhum valor é especificado
INDEX - Usado para criar e recuperar dados do banco de dados com melhor performance


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
SECAO 2: SQL ANSI

18.Operadores de Comparação


-- Acesso de select para usuario aluno na tabelas abaixo;

SELECT USER FROM DUAL;

GRANT select ON HR.COUNTRIES TO ALUNO WITH GRANT OPTION;
GRANT select ON HR.DEPARTMENTS TO ALUNO WITH GRANT OPTION;
GRANT select ON HR.EMPLOYEES TO ALUNO WITH GRANT OPTION;
GRANT select ON HR.JOB_HISTORY TO ALUNO WITH GRANT OPTION;
GRANT select ON HR.JOBS TO ALUNO WITH GRANT OPTION;
GRANT select ON HR.LOCATIONS TO ALUNO WITH GRANT OPTION;
GRANT select ON HR.REGIONS TO ALUNO WITH GRANT OPTION;

SELECT USER FROM DUAL;

--EXEMPLO OPERADOR IGUAL =
SELECT * FROM HR.EMPLOYEES a
WHERE a.JOB_ID='IT_PROG';

--EXEMPLO OPERADOR IGUAL =
SELECT * FROM HR.EMPLOYEES a
WHERE a.SALARY='9000';


--EXEMPLO OPERADOR MAIOR > 

SELECT * FROM HR.EMPLOYEES a
WHERE a.HIRE_DATE>'03/02/06'
order by  a.HIRE_DATE asc;


--EXEMPLO OPERADOR MAIOR > 

SELECT * FROM HR.EMPLOYEES a
WHERE a.SALARY>'9000'
order by a.SALARY asc ;

--EXEMPLO OPERADOR MENOR < 


SELECT * FROM HR.EMPLOYEES a
WHERE a.HIRE_DATE<'03/02/06'
order by  a.HIRE_DATE asc;
--EXEMPLO OPERADOR MENOR < 

SELECT * FROM HR.EMPLOYEES a
WHERE a.SALARY<'9000'
order by a.SALARY asc;

--EXEMPLO OPERADOR MAIOR IGUAL>= 

SELECT * FROM HR.EMPLOYEES a
WHERE a.SALARY>='9000'
order by a.SALARY asc;

--EXEMPLO OPERADOR MAIOR IGUAL>= 
SELECT * FROM HR.EMPLOYEES a
WHERE a.HIRE_DATE>='05/02/06'
order by  a.HIRE_DATE asc;

--EXEMPLO OPERADOR MENOR IGUAL <= 

SELECT * FROM HR.EMPLOYEES a
WHERE a.HIRE_DATE<='05/02/06'
order by  a.HIRE_DATE asc;

--EXEMPLO OPERADOR MENOR IGUAL <= 

SELECT * FROM HR.EMPLOYEES a
WHERE a.SALARY<='9000'
order by a.SALARY desc;

--EXEMPLO OPERADOR DIFERENTE <> 
SELECT * FROM HR.EMPLOYEES a
WHERE a.JOB_ID<>'IT_PROG';

--EXEMPLO OPERADOR DIFERENTE <> 
SELECT * FROM HR.EMPLOYEES a
WHERE a.MANAGER_ID<>'100';

--EXEMPLO COMBINANDO OPERADORES

SELECT * FROM HR.EMPLOYEES a
WHERE a.JOB_ID='IT_PROG'
AND a.SALARY>4800
AND a.MANAGER_ID='103';

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
19.Operadores Matematicos

--OPERADOR DE ADICAO +
SELECT 1+3 AS RESULTADO FROM DUAL;

SELECT a.FIRST_NAME,
       a.SALARY,
       a.SALARY+530 as salario_novo
       FROM HR.EMPLOYEES a;

--OPERADOR DE SUBTRACAO-
SELECT 1-3 AS RESULTADO FROM DUAL;

SELECT 7-4 AS RESULTADO FROM DUAL;

SELECT a.FIRST_NAME,
       a.SALARY,
       a.SALARY-530 as salario_novo
       FROM HR.EMPLOYEES a;

--OPERADOR DE MULTIPLICAO*

SELECT 2*3 AS RESULTADO FROM DUAL;

SELECT 7*4 AS RESULTADO FROM DUAL;


SELECT (7*4)*-1 AS RESULTADO FROM DUAL;


SELECT a.FIRST_NAME,
       a.SALARY,
       a.SALARY*1.10 as salario_novo
       FROM HR.EMPLOYEES a;
       

SELECT a.FIRST_NAME,
       a.SALARY,
       a.SALARY*0.10 as valor_acresc,
       a.SALARY*1.10 as salario_novo
       FROM HR.EMPLOYEES a;

--OPERADOR DE DIVISAO /

SELECT 2/4 AS RESULTADO FROM DUAL;

SELECT 4/2 AS RESULTADO FROM DUAL;

SELECT 7/4 AS RESULTADO FROM DUAL;

SELECT a.FIRST_NAME,
       a.SALARY,
       a.SALARY/10 as salario_novo
       FROM HR.EMPLOYEES a;

--OPERADOR MOD % -- RESTO DA DIVISAO

SELECT MOD(10,5) AS RESULTADO FROM DUAL;

SELECT MOD(10,3) AS RESULTADO FROM DUAL;

--Exmpressoes 

select 2*4/3+3 from dual;


select ((2*4)/3)+3 from dual;


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
20.Operadores Lógicos

Os operadores lógicos testam a legitimidade de algumas condições. os operadores lógicos, como operadores de comparação, retornam um tipo de dados Boolean com um valor TRUE, FALSE ou UNKNOWN.

WHERE
AND
BETWEEN
IN
LIKE
NOT
OR
IS NULL
IS NOT NULL
HAVING -  Com funções agregadas...




/*criação da tabelas senso */
CREATE TABLE senso
 (
ano INT NOT NULL,
cod_uf CHAR(2) NOT NULL,
estado VARCHAR2(50) NOT NULL,
cod_mun CHAR(7) NOT NULL,
nome_mun VARCHAR2(50) NOT NULL,
regiao VARCHAR2(150),
cod_meso_reg CHAR(4),
nome_meso_reg VARCHAR2(100) NOT NULL,
cod_mic_reg CHAR(5) NOT NULL,
nome_min_reg VARCHAR2(50) NOT NULL,
pib DECIMAL(12,3) NOT NULL,
populacao INTEGER NOT NULL,
pib_per_cap DECIMAL(12,3) NOT NULL
);


CREATE TABLE uf
(cod_uf CHAR(2) NOT NULL PRIMARY KEY,
 sigla_uf CHAR(2) NOT NULL,
 estado VARCHAR2(50) NOT NULL
);

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
21.Operadores Lógicos Parte 2


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
SECAO 3: Language Statements

22.Introdução Languagem Statements

A linguagem SQL é dividida em quatro tipos de instruções de linguagem primárias: DML, DDL, DCL e TCL

DML - Data Manipulation Languagem
	SELECT/INSERT/UPDATE/DELETE

DDL - Data Definition Language
	CREATE/ALTER/DROP/TRUNCATE

DCL - Data Control Language
	GRANT/REVOKE(Remove o privilegio do usuario)

TCL - Transaction Control Language
	START TRANSACTION/COMMIT/SAVEPOINT/ROLLBACK
	
	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
23.DML


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
24.DDL Parte 1

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
25.DDL Parte 2

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
26.DCL GRANT

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
27.DCL REVOKE


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
28.TCL 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
29.Operador UNION/UNION ALL

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
30.JOINS

--drop tabelas
drop table matricula;
drop table disciplina;
drop table alunos;
-- CRIACAO DE TABELA ALUNOS


create table alunos
(id_aluno int not null,
 nome varchar(20) not null,
 primary key(id_aluno)
 );


-- criando a tabela disciplina
create table disciplina
(
 id_disciplina int not null,
 nome_disc varchar2(20),
 primary key(id_disciplina)
 );


-- criando a tabela matricula
	CREATE TABLE matricula
	 (
	 id_aluno INT NOT NULL,
	 id_disciplina INT not null,
	 periodo VARCHAR2(10), 
	 PRIMARY KEY (id_aluno,id_disciplina), 
	 FOREIGN KEY (id_aluno) REFERENCES alunos(id_aluno), 
	 FOREIGN KEY (id_disciplina) REFERENCES disciplina(id_disciplina)
	);


  -- INSERINDO REGISTRO ALUNOS
  insert into alunos (id_aluno,nome) values (1,'Joao');
  insert into alunos (id_aluno,nome) values (2,'Maria');
  insert into alunos (id_aluno,nome) values (3,'Pedro');
  insert into alunos (id_aluno,nome) values (4,'Tiago');
  insert into alunos (id_aluno,nome) values (5,'Henrique');
  
--  insert into alunos (id_aluno,nome) values (5,'Henrique');


-- evidencia do insert
  SELECT * FROM alunos;


  -- INSERINDO REGISTRO DISCIPLINAS
  insert into disciplina (id_disciplina,nome_disc) values  (1,'Fisica');
  insert into disciplina (id_disciplina,nome_disc) values  (2,'Quimica');
  insert into disciplina (id_disciplina,nome_disc) values  (3,'Matematica');
  insert into disciplina (id_disciplina,nome_disc) values  (4,'Banco de Dados');
  insert into disciplina (id_disciplina,nome_disc) values  (5,'Programacao');

-- evidencia insert
  SELECT * FROM disciplina

-
  -- INSERINDO MATRICULAS DE ALUNOS
  insert into matricula values ('1','1','Noturno');
  insert into matricula values ('1','2','Vespertino');
  insert into matricula values ('1','3','Matutino');

  insert into matricula values ('2','3','Noturno');
  insert into matricula values ('2','4','Noturno');

  insert into matricula values ('3','1','Noturno');
  insert into matricula values ('3','3','Noturno');
  insert into matricula values ('3','4','Noturno');

  insert into matricula values ('5','1','Matutino');
  insert into matricula values ('5','2','Vespertino');
  insert into matricula values ('5','4','Noturno');

-- evidencia
 select * from matricula;
 
  -- ALUNO CODIG 4 NAO TEM MATRICULA
  -- DISCIPLINA 5 NAO TEM ALUNOS


  -- INNER JOIN

  SELECT a.nome,c.nome_disc,b.periodo
    FROM alunos a
	INNER JOIN matricula b 
		ON a.id_aluno = b.id_aluno
	INNER JOIN disciplina c 
		ON b.id_disciplina = c.id_disciplina;


  -- LEFT JOIN
	SELECT a.nome,c.nome_disc,b.periodo
	FROM alunos a
	LEFT JOIN matricula b 
		ON a.id_aluno=b.id_aluno
	LEFT JOIN disciplina c 
		ON b.id_disciplina=c.id_disciplina;
  

 -- RIGHT JOIN
	SELECT a.nome,c.nome_disc,b.periodo
	FROM alunos a
	RIGHT JOIN matricula b 
		ON a.id_aluno=b.id_aluno
	RIGHT JOIN disciplina c 
		ON b.id_disciplina=c.id_disciplina;
		

 -- full JOIN
	SELECT a.nome,c.nome_disc,b.periodo
	FROM alunos a
	full JOIN matricula b 
		ON a.id_aluno=b.id_aluno
	full JOIN disciplina c 
		ON b.id_disciplina=c.id_disciplina;


-- INNER JOIN

select * from hr.employees;
select * from HR.DEPARTMENTS;
select * from hr.jobs;


SELECT a.employee_id,a.first_name,b.department_name,c.job_title 
 FROM HR.EMPLOYEES a
 inner join HR.DEPARTMENTS b
  on a.department_id=b.department_id
 inner join HR.JOBS c
 on a.job_id=c.job_id
 order by 1;


-- LEFT JOIN

SELECT a.employee_id,a.first_name,b.department_name,c.job_title 
 FROM HR.EMPLOYEES a
 left join HR.DEPARTMENTS b
  on a.department_id=b.department_id
 left join HR.JOBS c
 on a.job_id=c.job_id
 order by 1;


-- RIGHT JOIN
SELECT a.employee_id,a.first_name,b.department_name,c.job_title 
 FROM HR.EMPLOYEES a
 right join HR.DEPARTMENTS b
  on a.department_id=b.department_id
 right join HR.JOBS c
 on a.job_id=c.job_id
 order by 1;



-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
31.SUBQUERYS


-- subselect

-- descobrir todos atores que fizeram o filme com seguintes parametros
-- film_id = 1 com tile = ACADEMY DINOSAUR
-- conhecer a estrura das tabelas alvo


select * from HR.EMPLOYEES;
select * from HR.JOB_HISTORY;
select * from HR.DEPARTMENTS;
select * from HR.JOBS; 


-- EXEMPLO DE SUBSELECT 1 OPERADOR IN 
select * from HR.EMPLOYEES a
where a.employee_id in (select b.employee_id from HR.JOB_HISTORY b); 
                       


-- EXEMPLO DE SUBSELECT 2 OPERADOR IN 
select * from HR.EMPLOYEES a
where a.manager_id='100'
and a.employee_id in (select b.employee_id from HR.JOB_HISTORY b);

-- EXEMPLO DE SUBSELECT 3 OPERADOR IN 
select * from HR.EMPLOYEES a
where  a.employee_id in (select b.employee_id from HR.JOB_HISTORY b
                         where b.DEPARTMENT_ID='50');


--select * from HR.JOB_HISTORY b where b.DEPARTMENT_ID='50'
---
-- EXEMPLO DE SUBSELECT 4 OPERADOR NOT IN 
select * from HR.EMPLOYEES a
where a.employee_id NOT in (select b.employee_id from HR.JOB_HISTORY b); 
                       


-- EXEMPLO DE SUBSELECT 5 OPERADOR NOT IN 
select * from HR.EMPLOYEES a
where a.manager_id='100'
and a.employee_id NOT in (select b.employee_id from HR.JOB_HISTORY b);

-- EXEMPLO DE SUBSELECT 3 OPERADOR NOT IN 
select * from HR.EMPLOYEES a
where  a.employee_id NOT in (select b.employee_id from HR.JOB_HISTORY b
                         where b.DEPARTMENT_ID='50');


--SUBSELECT RETORNANDO COLUNA

SELECT a.employee_id,
       a.first_name,
       a.job_id,
       (select b.job_title from hr.jobs b where a.job_id = b.job_id) as cargo
from HR.EMPLOYEES a;


--SUBSELECT RETORNANDO COLUNA
SELECT a.employee_id,
       a.first_name,
       a.DEPARTMENT_ID,
      (select b.DEPARTMENT_NAME from HR.DEPARTMENTS b where a.DEPARTMENT_ID=b.DEPARTMENT_ID) as Depto
from HR.EMPLOYEES a;
 
--SUBSELECT RETORNANDO COLUNA
SELECT a.DEPARTMENT_ID,
       a.DEPARTMENT_NAME,
        a.MANAGER_ID,
       (SELECT b.first_name from HR.EMPLOYEES b where a.manager_id=b.employee_id) AS NOME_GER
FROM HR.DEPARTMENTS a;

--SUBSELECT COM VALOR AGREGADO SOMA

SELECT a.DEPARTMENT_ID,
       a.DEPARTMENT_NAME,
       (SELECT SUM(b.salary) from HR.EMPLOYEES b where a.DEPARTMENT_ID = b.DEPARTMENT_ID) salario_depto
FROM HR.DEPARTMENTS a;
 
 
--SUBSELECT COM VALOR AGREGADO SOMA

SELECT a.DEPARTMENT_ID,
       a.DEPARTMENT_NAME,
	  (SELECT SUM(b.salary) from HR.EMPLOYEES b where a.DEPARTMENT_ID = b.DEPARTMENT_ID) salario_depto,
	  (SELECT count(*) from HR.EMPLOYEES b   where a.DEPARTMENT_ID = b.DEPARTMENT_ID) qtd_func
FROM HR.DEPARTMENTS a;

--SELLECT
SELECT a.DEPARTMENT_ID,
       a.DEPARTMENT_NAME,
--calculo total salario
(SELECT SUM(b.salary) from HR.EMPLOYEES b where a.DEPARTMENT_ID=b.DEPARTMENT_ID) salario_depto,
 --calculo qtd funcioanario
(SELECT count(*) from HR.EMPLOYEES b where a.DEPARTMENT_ID=b.DEPARTMENT_ID) qtd_func,
 --media
 (SELECT SUM(b.salary) from HR.EMPLOYEES b where a.DEPARTMENT_ID=b.DEPARTMENT_ID) 
   / --operador matematico
(SELECT count(*) from HR.EMPLOYEES b where a.DEPARTMENT_ID=b.DEPARTMENT_ID) media
FROM HR.DEPARTMENTS a;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
SECAO 5: FUNÇÕES PADROES
32.Introdução:


Funções Padrões/Nativas

Classificação
Controle de Fluxo
Agregação
Limite 
Conversão
Caracteres
Matemáticas
Data/Hora

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
33.Agregação Parte 1

-- AVG	Retorna a média dos valores em um grupo. Valores nulos são ignorados

select  * from senso;


-- AVG Retorna a "média" dos valores em um grupo. Valores nulos são ignorados
select AVG(populacao) as media from senso
where ano='2014';

-- AVG MEDIA POR ESTADO

SELECT estado,AVG(POPULACAO) FROM senso
WHERE ANO='2014'
GROUP BY estado
ORDER BY 2 desc;



-- AVG MEDIA POR ESTADO com sigla estado
SELECT a.cod_UF,b.sigla_uf,AVG(a.POPULACAO) media
	FROM senso a
inner join uf b
on a.cod_UF=b.cod_uf
WHERE a.ano='2014'
GROUP BY a.cod_UF,b.sigla_uf
ORDER BY 3 desc;


-- AVG POR REGIAO
-- AVG MEDIA POR REGIAO 
SELECT a.regiao,AVG(a.POPULACAO) 
	FROM senso a
    WHERE a.ano='2014'
    group by a.regiao
    ORDER BY 2 DESC;

   
-- MIN Retorna o valor mínimo na expressão. Pode ser seguido pela cláusula OVER
select MIN(a.populacao) from senso a
WHERE a.ano='2014';

-- MIN  POR ESTADO
SELECT a.estado,MIN(a.POPULACAO) 
	FROM senso a
    WHERE a.ano='2014'
GROUP BY estado;


-- MIN POR REGIAO

SELECT a.regiao,MIN(POPULACAO) 
	FROM senso a
WHERE a.ano='2014'
GROUP BY a.regiao
ORDER BY 2;

-- script 135
-- MAX Retorna o valor máximo na expressão
select MAX(populacao) from senso a
WHERE a.ano='2014';



-- MAX  POR ESTADO
SELECT a.estado,MAX(a.POPULACAO) FROM senso a
WHERE a.ano='2014'
GROUP BY a.estado
ORDER BY 2 desc;


-- MAX POR SIGLA ESTADO
SELECT b.sigla_uf,MAX(a.POPULACAO)AS maximo 
	FROM senso a
INNER JOIN uf b
ON a.cod_uf=b.cod_uf
WHERE a.ano='2014'
GROUP BY b.sigla_uf
ORDER BY 2;

-- SUM  POR ESTADO

SELECT  a.cod_uf,SUM(a.POPULACAO) FROM senso a
WHERE a.ano='2014'
GROUP BY a.cod_uf
ORDER BY 2 desc;


-- SUM POR REGIAO
SELECT b.sigla_uf,sum(a.POPULACAO)AS maximo 
	FROM senso a
INNER JOIN uf b
ON a.cod_uf=b.cod_uf
WHERE a.ano='2014'
GROUP BY b.sigla_uf
ORDER BY 2;


-- COUNT Retorna o número de itens de um grupo

select COUNT(*) from senso a
WHERE a.ano='2014';


-- COUNT Retorna o número de cidades por ano
select a.ano,COUNT(*) qtd_cidades from senso a
group by a.ano
ORDER BY a.ano ASC;


-- Descobrindo qtd estados
select count(distinct cod_uf) from senso;


-- exemplo
select count(cod_uf) from senso;


-- COUNT  POR ESTADO
SELECT a.estado, COUNT(*) 
FROM senso a
where ano='2014'
GROUP BY a.estado
ORDER BY 2 desc;


-- COUNT POR REGIAO
SELECT a.regiao,COUNT(*) FROM senso a
where ano='2014'
GROUP BY a.regiao
ORDER BY 2 desc;


-- usando varias funçoes de agregacao

select avg(a.populacao)media_pop,
	   min(a.populacao)minimo_pop,
	   max(a.populacao)maximo_pop,
	   sum(a.populacao)total_pop,
	   COUNT(*) qtd_cidades
from senso a
where a.ano='2014';


-- POR ESTADO
SELECT a.estado,
	   avg(a.populacao)media_pop,
	   min(a.populacao)minimo_pop,
	   max(a.populacao)maximo_pop,
	   sum(a.populacao)total_pop,
	   COUNT(*) qtd_cidades
FROM senso a
where a.ano='2014'
GROUP BY a.estado
ORDER BY 2 desc;


-- apresentar nome da cidade com maior populacao de cada estados
select a.estado,a.nome_mun,a.populacao 
from
(
    select b.estado, MAX(b.populacao) as populacao 
	from senso b
    where b.ano='2014'
    group by b.estado
) b
join senso a
on a.estado = b.estado
and a.populacao = b.populacao
where a.ano='2014'
order by a.populacao desc;


-- apresentar nome da cidade com maior populacao de cada estados
select a.estado,a.nome_mun,a.populacao 
from
(
    select b.estado, min(b.populacao) as populacao from senso b
    where b.ano='2014'
    group by b.estado
) b
join senso a
on a.estado = b.estado
and a.populacao = b.populacao
where a.ano='2014'
order by a.populacao desc;

-- apresentar nome da cidade com minimo populacao de cada estados
select a.estado,a.nome_mun,a.populacao 
from
(
    select b.estado, MIN(b.populacao) as populacao from senso b
    where b.ano='2014'
    group by b.estado
) b
join senso a
on a.estado = b.estado
and a.populacao = b.populacao
where a.ano='2014'
order by a.populacao desc;
-- apresentando

-- STDDEV Retorna o desvio padrão estatístico de todos os valores da expressão especificada

select STDDEV(a.populacao)  from senso a
where a.ano='2014';


-- script 148
-- STDDEV_POP Retorna o desvio padrão estatístico para a população de todos os 
-- valores na expressão especificada

select STDDEV_POP(populacao)  from senso;


-- COMPARANDO CRESCIMENTO pop DA CIDADES ref anos  2010 a 2014
-- select cod_uf,cod_mun,cod_uf+cod_mun as concatenado from cidades
-- usando exemplo
SELECT a.nome_mun,
       a.populacao as senso_2010,
	   b.populacao as senso_2014,
       (100/a.populacao)*(b.populacao)-100 as percentual
from senso a 
inner join senso b 
on a.cod_mun=b.cod_mun
where a.ano='2010' 
and b.ano='2014';


-- COMPARANDO CRESCIMENTO POPULACAO POR ESTADO ref anos  2010 a 2014

SELECT a.estado,
       sum(a.populacao) as senso_2010,
	   sum(b.populacao) as senso_2014,
       (100/sum(a.populacao))*(sum(b.populacao))-100 as percentual
from senso a 
inner join senso b 
on a.cod_mun=b.cod_mun
where a.ano='2010' 
and b.ano='2014'
group by a.estado;


-- VAR_POP Retorna a variância estatística de todos os valores da expressão especificada
SELECT VAR_POP(POPULACAO) FROM senso
where ano='2014';


-- VAR_POP COM GROUP BY 
SELECT estado,VAR_POP(POPULACAO) FROM senso
GROUP BY estado;


-- VAR_SAMP Retorna a variância estatística para o preenchimento 
-- de todos os valores da expressão especificada.
SELECT VAR_SAMP(POPULACAO) FROM senso;


-- VAR_SAMP COM GROUP BY 
SELECT estado,VAR_SAMP(POPULACAO) FROM senso
GROUP BY estado;



-- GROUP BY WITH ROLLUP
SELECT a.estado,COUNT(*) FROM senso a
where ano='2014'
GROUP BY rollup(a.estado);

-- GROUP BY WITH ROLLUP
SELECT a.estado,a.REGIAO,sum(a.POPULACAO) 
FROM senso a
where ano='2014'
GROUP BY rollup(a.estado,a.REGIAO);

-- exeplos extras.

SELECT job_id as Cargo,
avg(a.salary) as media_salario
FROM hr.EMPLOYEES a
GROUP BY a.job_id
ORDER BY a.job_id;

--Media geral

SELECT avg(a.salary) as media_salario
FROM hr.EMPLOYEES a;


-- MIN	Retorna o valor mínimo na expressão. Pode ser seguido pela cláusula OVER

SELECT job_id as Cargo,
MIN(a.salary) as menor_salario
FROM hr.EMPLOYEES a
GROUP BY a.job_id
ORDER BY a.job_id;

--menor geral
SELECT 
MIN(a.salary) as menor_salario
FROM hr.EMPLOYEES a;

-- MAX	Retorna o valor máximo na expressão;
SELECT job_id as Cargo,
MAX(a.salary) as maior_salario
FROM hr.EMPLOYEES a
GROUP BY a.job_id
ORDER BY a.job_id;

--maior geral
SELECT 
MAX(a.salary) as maior
FROM hr.EMPLOYEES a

-- SUM	Retorna a soma de todos os valores ou somente os valores DISTINCT na expressão. SUM pode ser usado exclusivamente com colunas numéricas.Valores nulos são ignorados
SELECT a.DEPARTMENT_ID "Departmento",
SUM(a.SALARY) "Soma Salarios"
FROM hr.EMPLOYEES a
GROUP BY a.DEPARTMENT_ID;

--sum com restrição having
SELECT a.DEPARTMENT_ID as  "Departmento",
SUM(a.SALARY) as "Soma Salarios"
FROM hr.EMPLOYEES a
GROUP BY a.DEPARTMENT_ID
HAVING SUM(a.SALARY) >= 100000
order BY a.DEPARTMENT_ID;


-- COUNT	Retorna o número de itens de um grupo

SELECT a.MANAGER_ID "Gerente",
COUNT(*) "Number Subordinados"
FROM hr.EMPLOYEES a
GROUP BY a.MANAGER_ID
ORDER BY a.MANAGER_ID;

SELECT a.MANAGER_ID "Gerente",b.first_name "Nome Gerente",
COUNT(*) "Qtd Subordinados"
FROM hr.EMPLOYEES a
inner join hr.EMPLOYEES b
on a.manager_id=b.employee_id
GROUP BY a.MANAGER_ID,b.first_name
ORDER BY a.MANAGER_ID;
-- STDDEV	Retorna o desvio padrão estatístico de todos os valores da expressão especificada
-- VARIANCE	Determina a variância de n, ignorando valores nulos.





--Varios

SELECT JOB_ID,
COUNT(*) "QTD",
MIN(SALARY) "Minimo",
ROUND(AVG(SALARY), 0) "Media",
MEDIAN(SALARY) "Mediano",
MAX(SALARY) "Maximo",
ROUND(STDDEV(SALARY)) "Std Dev"
FROM HR.EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID;


---scripts extras

-- conhecendo as tabela


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
34.Agregação Parte 2

-- AVG	Retorna a média dos valores em um grupo. Valores nulos são ignorados

select  * from senso;


-- AVG Retorna a média dos valores em um grupo. Valores nulos são ignorados
select AVG(populacao) as media 
from senso
where ano = '2014';

-- AVG MEDIA POR ESTADO

SELECT estado, AVG(POPULACAO) FROM senso
WHERE ANO='2014'
GROUP BY estado
ORDER BY 2 desc;



-- AVG MEDIA POR ESTADO com sigla estado
SELECT a.cod_UF, 
       b.sigla_uf,
       AVG(a.POPULACAO) media
	FROM senso a
inner join uf b
on a.cod_UF = b.cod_uf
WHERE a.ano = '2014'
GROUP BY a.cod_UF, b.sigla_uf
ORDER BY 3 desc;


-- AVG POR REGIAO
-- AVG MEDIA POR REGIAO 
SELECT a.regiao,AVG(a.POPULACAO) 
	FROM senso a
    WHERE a.ano='2014'
    group by a.regiao
    ORDER BY 2 DESC;

--select * from senso  where populacao = 822 
-- MIN Retorna o valor mínimo na expressão. Pode ser seguido pela cláusula OVER
select a.estado, 
    MIN(a.populacao) as CIDADE_COM_MENOR_POPULACAO-- Cidade com menos populacao
from senso a 
WHERE a.ano='2014'
GROUP BY ESTADO;


-- MIN  POR ESTADO
SELECT a.estado,
       MIN(a.POPULACAO) 
	FROM senso a
    WHERE a.ano = '2014'
GROUP BY estado;


-- MIN POR REGIAO

SELECT a.regiao, 
       MIN(POPULACAO) 
	 FROM senso a
     WHERE a.ano='2014'
GROUP BY a.regiao
ORDER BY 2;

-- script 135
-- MAX Retorna o valor máximo na expressão
select MAX(populacao) 
    from senso a
WHERE a.ano='2014';



-- MAX  POR ESTADO
SELECT a.estado,
       MAX(a.POPULACAO) 
       FROM senso a
WHERE a.ano='2014'
GROUP BY a.estado
ORDER BY 2 desc;


-- MAX POR SIGLA ESTADO
SELECT b.sigla_uf,
       MAX(a.POPULACAO)AS maximo 
	FROM senso a
INNER JOIN uf b
ON a.cod_uf = b.cod_uf
WHERE a.ano = '2014'
GROUP BY b.sigla_uf
ORDER BY 2;

-- SUM  POR ESTADO

SELECT  a.cod_uf,
        SUM(a.POPULACAO) 
        FROM senso a
WHERE a.ano='2014'
GROUP BY a.cod_uf
ORDER BY 2 desc;


-- SUM POR REGIAO
SELECT b.sigla_uf,sum(a.POPULACAO)AS maximo 
	FROM senso a
INNER JOIN uf b
ON a.cod_uf=b.cod_uf
WHERE a.ano='2014'
GROUP BY b.sigla_uf
ORDER BY 2;


-- COUNT Retorna o número de itens de um grupo

select COUNT(*) from senso a
WHERE a.ano='2014';


-- COUNT Retorna o número de cidades por ano
select a.ano,
       COUNT(*) qtd_cidades 
       from senso a
group by a.ano
ORDER BY a.ano ASC;


-- Descobrindo qtd estados
select count(distinct cod_uf) from senso;


-- exemplo
select count(cod_uf) from senso;


-- COUNT  POR ESTADO
SELECT a.estado,
    COUNT(*) FROM senso a
where ano = '2014'
GROUP BY a.estado
ORDER BY 2 desc;


-- COUNT POR REGIAO
SELECT a.regiao,
        COUNT(*) 
        FROM senso a
where ano = '2014'
GROUP BY a.regiao
ORDER BY 2 desc;


-- usando varias funçoes de agregacao

select avg(a.populacao)media_pop,
	   min(a.populacao)minimo_pop,
	   max(a.populacao)maximo_pop,
	   sum(a.populacao)total_pop,
	   COUNT(*) qtd_cidades
from senso a
where a.ano='2014';


-- POR ESTADO
SELECT a.estado,
	   avg(a.populacao)media_pop,
	   min(a.populacao)minimo_pop,
	   max(a.populacao)maximo_pop,
	   sum(a.populacao)total_pop,
	   COUNT(*) qtd_cidades
FROM senso a
where a.ano='2014'
GROUP BY a.estado
ORDER BY 2 desc;


-- apresentar nome da cidade com maior populacao de cada estados
select a.estado,a.nome_mun,a.populacao 
from
(
    select b.estado, MAX(b.populacao) as populacao from senso b
    where b.ano='2014'
    group by b.estado
) b
join senso a
on a.estado = b.estado
and a.populacao = b.populacao
where a.ano='2014'
order by a.populacao desc;


-- apresentar nome da cidade com maior populacao de cada estados
select a.estado,a.nome_mun,a.populacao 
from
(
    select b.estado, min(b.populacao) as populacao from senso b
    where b.ano='2014'
    group by b.estado
) b
join senso a
on a.estado = b.estado
and a.populacao = b.populacao
where a.ano='2014'
order by a.populacao desc;

-- apresentar nome da cidade com minimo populacao de cada estados
select a.estado,a.nome_mun,a.populacao 
from
(
    select b.estado, MIN(b.populacao) as populacao from senso b
    where b.ano='2014'
    group by b.estado
) b
join senso a
on a.estado = b.estado
and a.populacao = b.populacao
where a.ano='2014'
order by a.populacao desc;
-- apresentando

-- STDDEV Retorna o desvio padrão estatístico de todos os valores da expressão especificada

select STDDEV(a.populacao)  from senso a
where a.ano='2014';


-- script 148
-- STDDEV_POP Retorna o desvio padrão estatístico para a população de todos os 
-- valores na expressão especificada

select STDDEV_POP(populacao)  from senso;


-- COMPARANDO CRESCIMENTO pop DA CIDADES ref anos  2010 a 2014
-- select cod_uf,cod_mun,cod_uf+cod_mun as concatenado from cidades
-- usando exemplo
SELECT a.nome_mun,
       a.populacao as senso_2010,
	   b.populacao as senso_2014,
       (100/a.populacao)*(b.populacao)-100 as percentual
from senso a 
inner join senso b 
on a.cod_mun=b.cod_mun
where a.ano='2010' 
and b.ano='2014';


-- COMPARANDO CRESCIMENTO POPULACAO POR ESTADO ref anos  2010 a 2014

SELECT a.estado,
       sum(a.populacao) as senso_2010,
	   sum(b.populacao) as senso_2014,
       (100/sum(a.populacao))*(sum(b.populacao))-100 as percentual
from senso a 
inner join senso b 
on a.cod_mun=b.cod_mun
where a.ano='2010' 
and b.ano='2014'
group by a.estado;


-- VAR_POP Retorna a variância estatística de todos os valores da expressão especificada
SELECT VAR_POP(POPULACAO) FROM senso
where ano='2014';


-- VAR_POP COM GROUP BY 
SELECT estado,VAR_POP(POPULACAO) FROM senso
GROUP BY estado;


-- VAR_SAMP Retorna a variância estatística para o preenchimento 
-- de todos os valores da expressão especificada.
SELECT VAR_SAMP(POPULACAO) FROM senso;


-- VAR_SAMP COM GROUP BY 
SELECT estado,VAR_SAMP(POPULACAO) FROM senso
GROUP BY estado;



-- GROUP BY WITH ROLLUP
SELECT a.estado,COUNT(*) FROM senso a
where ano='2014'
GROUP BY rollup(a.estado);

-- GROUP BY WITH ROLLUP
SELECT a.estado,a.REGIAO,sum(a.POPULACAO) FROM senso a
where ano='2014'
GROUP BY rollup(a.estado,a.REGIAO);

-- exeplos extras.

SELECT job_id as Cargo,
avg(a.salary) as media_salario
FROM hr.EMPLOYEES a
GROUP BY a.job_id
ORDER BY a.job_id;

--Media geral

SELECT avg(a.salary) as media_salario
FROM hr.EMPLOYEES a;


-- MIN	Retorna o valor mínimo na expressão. Pode ser seguido pela cláusula OVER

SELECT job_id as Cargo,
MIN(a.salary) as menor_salario
FROM hr.EMPLOYEES a
GROUP BY a.job_id
ORDER BY a.job_id;

--menor geral
SELECT 
MIN(a.salary) as menor_salario
FROM hr.EMPLOYEES a;

-- MAX	Retorna o valor máximo na expressão;
SELECT job_id as Cargo,
MAX(a.salary) as maior_salario
FROM hr.EMPLOYEES a
GROUP BY a.job_id
ORDER BY a.job_id;

--maior geral
SELECT 
MAX(a.salary) as maior
FROM hr.EMPLOYEES a

-- SUM	Retorna a soma de todos os valores ou somente os valores DISTINCT na expressão. SUM pode ser usado exclusivamente com colunas numéricas.Valores nulos são ignorados
SELECT a.DEPARTMENT_ID "Departmento",
SUM(a.SALARY) "Soma Salarios"
FROM hr.EMPLOYEES a
GROUP BY a.DEPARTMENT_ID;

--sum com restrição having
SELECT a.DEPARTMENT_ID as  "Departmento",
SUM(a.SALARY) as "Soma Salarios"
FROM hr.EMPLOYEES a
GROUP BY a.DEPARTMENT_ID
HAVING SUM(a.SALARY) >= 100000
order BY a.DEPARTMENT_ID;


-- COUNT	Retorna o número de itens de um grupo

SELECT a.MANAGER_ID "Gerente",
COUNT(*) "Number Subordinados"
FROM hr.EMPLOYEES a
GROUP BY a.MANAGER_ID
ORDER BY a.MANAGER_ID;

SELECT a.MANAGER_ID "Gerente",b.first_name "Nome Gerente",
COUNT(*) "Qtd Subordinados"
FROM hr.EMPLOYEES a
inner join hr.EMPLOYEES b
on a.manager_id=b.employee_id
GROUP BY a.MANAGER_ID,b.first_name
ORDER BY a.MANAGER_ID;
-- STDDEV	Retorna o desvio padrão estatístico de todos os valores da expressão especificada
-- VARIANCE	Determina a variância de n, ignorando valores nulos.





--Varios

SELECT JOB_ID,
COUNT(*) "QTD",
MIN(SALARY) "Minimo",
ROUND(AVG(SALARY), 0) "Media",
MEDIAN(SALARY) "Mediano",
MAX(SALARY) "Maximo",
ROUND(STDDEV(SALARY)) "Std Dev"
FROM HR.EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID;


---scripts extras

-- conhecendo as tabela



-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
35.Funções de Caracteres Parte 1



-- Exemplos com ASCII
select ascii('ab')teste from SYS.DUAL -- so esta considerando o primeiro caracter
union all
select ascii('a') from SYS.DUAL
union all
select ascii('b') from SYS.DUAL;


-- Exemplos com LOWER( )
select a.DEPARTMENT_NAME nome_depto,
      LOWER(a.DEPARTMENT_NAME)nome_depto_l, 
      LOWER('Curso SQL')
from HR.DEPARTMENTS a;

-- Exemplos com UPPER( )
select a.DEPARTMENT_NAME nome_depto,  
       UPPER(a.DEPARTMENT_NAME)nome_depto_U, 
       UPPER('Curso SQL')
from HR.DEPARTMENTS a;

-- Exemplos com INITCAP( ) -- Primeiro caracter em maiusculo
select a.DEPARTMENT_NAME nome_depto, 
         INITCAP(UPPER(a.DEPARTMENT_NAME))nome_depto_i, 
         INITCAP('curso SQL')
from HR.DEPARTMENTS a;

-- Exemplos com CONCAT( )

select a.FIRST_NAME,
       a.LAST_NAME,
       concat(a.FIRST_NAME,a.LAST_NAME) nome_completo
from HR.EMPLOYEES a;

--outra opcao concatenar
select a.FIRST_NAME,
       a.LAST_NAME,
       a.FIRST_NAME||' '||a.LAST_NAME as nome_completo,
       a.FIRST_NAME||' '||a.LAST_NAME||' '||a.salary as texto
from HR.EMPLOYEES a;


-- Exemplos com LPAD( )

select a.EMPLOYEE_ID,
       LPAD(a.EMPLOYEE_ID,10,'0')ID_LPAD,
       a.FIRST_NAME
from HR.EMPLOYEES a;


-- Exemplos com RPAD( )

select a.EMPLOYEE_ID,
       RPAD(a.EMPLOYEE_ID,10,'0')ID_LPAD,
       a.FIRST_NAME
from HR.EMPLOYEES a;


-- Exemplos com SUBSTR( )

select SUBSTR('ORACLE',2,4) FROM SYS.DUAL;

select a.FIRST_NAME,
       a.LAST_NAME,
       SUBSTR(a.FIRST_NAME,1,1)INI_1,
       SUBSTR(a.LAST_NAME,1,1)INI2,
       CONCAT(SUBSTR(a.FIRST_NAME,1,1),SUBSTR(a.LAST_NAME,1,1)) texto3
from HR.EMPLOYEES a;

--outro exemplo

select a.FIRST_NAME,
    SUBSTR(a.FIRST_NAME,1,3)PARTE1,
    SUBSTR(a.FIRST_NAME,4,10)PARTE2
from HR.EMPLOYEES a;

-- Exemplos com INSTR( ) -- Devolve a posição da primeira ocorrencia de string2 dentro da string1
                        

SELECT a.JOB_TITLE,INSTR(a.JOB_TITLE,'r') posicao FROM HR.JOBS a; -- Letra "r" em q posicao se encontra?

SELECT a.JOB_TITLE,INSTR(a.JOB_TITLE,'es') posicao FROM HR.JOBS a; -- Letra "es" em q posicao se encontra?

SELECT a.JOB_TITLE,INSTR(a.JOB_TITLE,'re') posicao FROM HR.JOBS a;

SELECT a.JOB_TITLE,INSTR(a.JOB_TITLE,'t',12) posicao FROM HR.JOBS a; -- Procure a letra "t" a partir da 10º posicao

-- Exemplos com LTRIM( )
SELECT a.JOB_TITLE,
       LTRIM(a.JOB_TITLE,'A') posicao FROM HR.JOBS a;

SELECT a.JOB_TITLE,LTRIM(a.JOB_TITLE,'AFPS') posicao FROM HR.JOBS a;

--exemplo ltrim
select   '       Andre' com_espaco,
         LTRIM('        Andre',' ') sem_espaco 
from dual;

--exemplo ltrim

select concat('    Andre',LTRIM('        Andre',' ')) sem_espaco from dual;


-- Exemplos com RTRIM( )
SELECT a.JOB_TITLE,RTRIM(a.JOB_TITLE,'tre') posicao FROM HR.JOBS a;

--exemplo
select 'Andre     ' com_espaco,'Andre'  sem_espaco from dual;

select concat(' Andre       ','Andre') espaco from dual;

select concat(RTRIM(' Andre       '),'Andre') sem_espaco from dual;

-- Exemplos com LENGTH( )
SELECT a.JOB_TITLE,
       LENGTH(a.JOB_TITLE) tamanho FROM HR.JOBS a;

-- Exemplos com TRANSLATE( ) --  Substitui o parametro S pelo X
SELECT a.JOB_TITLE,
      TRANSLATE(a.JOB_TITLE,'S','X') traducao -- parametro "S" e "X"
FROM HR.JOBS a;

SELECT a.JOB_TITLE,TRANSLATE(a.JOB_TITLE,'PAF','XYZ') traducao FROM HR.JOBS a;

-- Exemplos com REPLACE( )
SELECT a.JOB_TITLE,
       REPLACE(a.JOB_TITLE,'Manager','Gerente') 
       traducao FROM HR.JOBS a;

-- Exemplos com DECODE( ) - Funções de conversão 

SELECT a.JOB_TITLE  FROM HR.JOBS a;

SELECT a.JOB_TITLE,
       decode(JOB_TITLE,
                            'President','Presidente',
                            'Administration Vice President','Vice Presiente ADM',
                            'Administration Assistant','Assist Adm',
                            'Finance Manager','Gerente Financ',
                            'Accountant','Contador',
                            'Accounting Manager','Gerente de contas',
                            'Public Accountant','Contas Publicas',
                            'Sales Manager','Gerente de vendas',
                            'Sales Representative','Repres. Vendas',
                            'Purchasing Manager','Gerente de compras',
                            'Purchasing Clerk','Aux Compras',
                            'Stock Manager','Gerente de estoque',
                            'Stock Clerk','Aux Estoque',
                            'Shipping Clerk','Aux de carregamento',
                            'Programmer','Programador',
                            'Marketing Manager','Gerente de MKT',
                            'Marketing Representative','Repres de Marketing',
                            'Human Resources Representative','Repres RH',
                            'Public Relations Representative','Relacoes Publicas') decodif
FROM HR.JOBS a;

-- Exemplos com REVERSE( ) - Funções de conversão -- converte a cadeia de caracter q esta sendo tratada...

SELECT a.JOB_TITLE,
       reverse(a.JOB_TITLE) revertido
FROM HR.JOBS a;


--outras funções
select (a.FIRST_NAME)nome,
        DUMP(a.FIRST_NAME)dump_nome, -- traz o tipo, tamanho, posicao asc de cada letra
        VSIZE(a.FIRST_NAME)size_nome -- Qtde de caracteres
        from hr.employees a;



-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
36.Função Caracteres Parte 2


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
37.Funções de Classificação

--A diferença entre o  RANK e o DENSE_RANK é que o segundo não salta valores após classificações repetidas.
--usando ROW_NUMBER
SELECT ROW_NUMBER() OVER (ORDER BY a.SALARY DESC) Sequencia,-- Over, quer dizer sobre o campo abaixo.. Esse recusro apenas coloca uma sequencia na instrucao sql
        a.FIRST_NAME, 
        a.SALARY, NTILE(4) OVER (ORDER BY a.SALARY DESC) Faixa -- 4 pq ele pega o total de registros e divide por 4 grupos, como se fosse uma faxa.
FROM    hr.employees a
ORDER  BY a.SALARY DESC;

-- usando RANK()

select RANK() OVER(ORDER BY a.SALARY desc) classificacao, -- Esse recurso traz o rank dos maiores salarios
       a.FIRST_NAME,
       a.SALARY
       from hr.employees a
order by a.salary desc;

-- usando RANK() eDENSE_RANK()
select RANK() OVER(ORDER BY a.SALARY desc) classif_geral,
       DENSE_RANK() OVER(ORDER BY a.SALARY desc) classif_densa,-- Nao salta posicoes, ele segue uma sequencia...
       a.FIRST_NAME,
       a.SALARY,
       a.JOB_ID 
    from hr.employees a
order by a.salary desc

--
select RANK() OVER(ORDER BY a.SALARY desc) classif_geral1,
       RANK() OVER(partition by  a.JOB_ID  ORDER BY a.SALARY desc) classif_geral2,
       a.FIRST_NAME,
       a.SALARY,
       a.JOB_ID 
    from hr.employees a
order by a.salary desc;

--
select RANK() OVER(ORDER BY a.SALARY desc) classif_geral,
       RANK() OVER(partition by  a.JOB_ID  ORDER BY a.SALARY desc) classif_densa,
       a.FIRST_NAME,
       a.SALARY,
       a.JOB_ID 
    from hr.employees a
order by a.salary desc;


--usando NTILE

SELECT   a.job_title,
         a.MAX_SALARY, 
         NTILE(5) OVER (ORDER BY a.MAX_SALARY DESC) Faixa -- 5 pq ele pega o total de registros e divide por 5 grupos, como se fosse uma faxa.
FROM     hr.JOBS a
ORDER  BY a.MAX_SALARY DESC;


--usando NTILE

SELECT   a.FIRST_NAME, 
         a.SALARY, 
         NTILE(4) OVER (ORDER BY a.SALARY DESC) Faixa
FROM     hr.employees a
ORDER  BY a.SALARY DESC;


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
38.Funções de Controle de Fluxo

    
--exemplo case
SELECT A.FIRST_NAME, A.SALARY,
    CASE WHEN A.SALARY <5000 THEN 'Baixo'
         WHEN A.SALARY <10000 THEN 'Medio'
         WHEN A.SALARY <15000 THEN 'Medio Alto'
		 ELSE   'Alto' 
    END FAIXA 
FROM HR.EMPLOYEES A
ORDER BY A.SALARY DESC;


-- Faz a mesma coisa q o SQL acima, porem, nesse exemplo estou amarrando os valores
SELECT A.FIRST_NAME,A.SALARY,
    CASE WHEN A.SALARY <5000  THEN 'Baixo'
         WHEN A.SALARY >=5000 AND A.SALARY <10000 THEN 'Medio'
         WHEN A.SALARY >=10000 AND A.SALARY <15000 THEN 'Medio Alto'
         ELSE   'Alto' 
    END FAIXA 
FROM HR.EMPLOYEES A
ORDER BY A.SALARY DESC;

    
--exemplo case
-- Nesse exemplo significa q os id que estao preenchidos, tem um gerente, se esta null, é pq ele é o gerente...
SELECT A.FIRST_NAME, A.MANAGER_ID,
    CASE WHEN A.MANAGER_ID IS NULL THEN 'Gerente' 
        ELSE 'Subordinado' 
    END AS HIERARQ
    FROM HR.EMPLOYEES A;


--
-- Esse script mostra a hierarquia dos colaboradores q estao abaixo do seu gestor
SELECT A.employee_id,
       A.FIRST_NAME Colaborador,
       A.MANAGER_ID COD_GERENTE,
       b.FIRST_NAME   
    FROM HR.EMPLOYEES A
    left JOIN HR.EMPLOYEES B
    on a.manager_id = b.employee_id
    order by a.employee_id;

    
--exemplo case   
SELECT A.FIRST_NAME, 
               A.MANAGER_ID,
     CASE WHEN A.MANAGER_ID IS NOT NULL THEN 'Subordinado' 
          ELSE 'Gerente' 
     END HIERARQ
FROM HR.EMPLOYEES A;
    
--exemplo case
select * from hr.LOCATIONS

SELECT UNIQUE COUNTRY_ID ID, -- Esse UNIQUE tras o registro uma unica vez, quando UF esta repetida....
         CASE COUNTRY_ID
         WHEN 'AU' THEN 'Australia'
         WHEN 'BR' THEN 'Brazil'
         WHEN 'CA' THEN 'Canada'
         WHEN 'CH' THEN 'Switzerland'
         WHEN 'CN' THEN 'China'
         WHEN 'DE' THEN 'Germany'
         WHEN 'IN' THEN 'India'
         WHEN 'IT' THEN 'Italy'
         WHEN 'JP' THEN 'Japan'
         WHEN 'MX' THEN 'Mexico'
         WHEN 'NL' THEN 'Netherlands'
         WHEN 'SG' THEN 'Singapore'
         WHEN 'UK' THEN 'United Kingdom'
         WHEN 'US' THEN 'United States'
         ELSE 'Outros'
        END COUNTRY
FROM hr.LOCATIONS
ORDER BY COUNTRY_ID;

    
--exemplo case
    
SELECT A.FIRST_NAME,A.COMMISSION_PCT,
    CASE WHEN A.COMMISSION_PCT IS NOT NULL THEN 'Vendedor' 
      ELSE 'Interno' END HIERARQ
    FROM HR.EMPLOYEES A;
    

--Exemplo NULLIF   
SELECT NULLIF(100,100) FROM DUAL; -- Se os valores sao identicos, set null

--Exemplo NULLIF   

-- script 173
SELECT NULLIF(100,10) FROM DUAL; -- Quando e diferente, set o primeiro valor

--Exemplo NULLIF   
--nao serve pra tratar retorno NULL
SELECT A.FIRST_NAME,
       A.COMMISSION_PCT,
NULLIF(A.COMMISSION_PCT,0)
FROM HR.EMPLOYEES A;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
39.Funções Matemáticas

-- ABS-- ABS Retorna o valor posotivo absoluto

select a.FIRST_NAME,
       a.SALARY,
       a.SALARY*-1 SALARIO_NEGATIVO,
       abs(a.SALARY*-1) SALARIO_ABS -- Exemplo
from HR.EMPLOYEES a

select a.FIRST_NAME,
       a.SALARY,
       a.SALARY*-1 SALARIO_NEGATIVO,
       abs(a.SALARY*-1) SALARIO_ABS
from HR.EMPLOYEES a


--Rand

/*
--Retorna um valor float pseudoaleatorio de 0 a 1, exclusivo.
--RANDOM
U – Upper case
L – Lower case
A – Alfanumérico (Alphanumeric)
X – Alfanumérico com caracteres upper case (Alphanumeric with upper case alphabets)
P – Somente caracteres imprimíveis (printable characters only)
Outros caracteres: retorno será somente em upper case (Providing any other character will return the output in upper case only)
*/
select dbms_random.value from dual;

select trunc(dbms_random.value(1, 99), 0) as Exemplo from dual; -- Uma casa decimal
select trunc(dbms_random.value(1, 99), 2) as Exemplo from dual; -- Duas casas decimais
select trunc(dbms_random.value(1, 99), 3) as Exemplo from dual; --Tres casas decimais

select dbms_random.string('U', 5) x from dual; -- Dois caracteres maiusculo
select dbms_random.string('U', 2) x from dual; -- Dois caracteres maiusculo
select dbms_random.string('L', 5) x from dual; -- Cinco caracteres minusculo
select dbms_random.string('A', 10) x from dual; -- Dez caracteres Alfanumérico
select dbms_random.string('X',10) x from dual; -- Dez caracteres Alfanumérico com caracteres upper case
select dbms_random.string('P',10) x from dual; -- Dez, Somente caracteres imprimíveis

-- ROUND
--ROUND: Funcao Randomica

SELECT ROUND(45.923,1)AS T1, --45.923 + 1 q e a qtde de casas q queri tratar
       ROUND(45.923)AS T2,   -- 45.923 nesse caso a funcao arredonda para cima
       ROUND(45.323,1)AS T3, -- 45.323 nesse caso a funcao arredonda para baixo
       ROUND(45.323,-1)AS T4, -- 45.323,-1 ( 1234 arredonda p baixo, 5678 arredonda p cima)
       ROUND(44.323,-1) AS T5 
FROM DUAL

-- ROUND      
SELECT A.FIRST_NAME,
       A.SALARY,
       A.SALARY/33 NOVO,
       ROUND(A.SALARY/33,2) NOVO
FROM HR.EMPLOYEES A

-- TRUNC
select TRUNC(45.923,1)T1, 
       TRUNC(45.923)T2, 
       TRUNC(45.323,1)T3, 
       TRUNC(45.323,-1) T4,
       TRUNC(44.323,-1) T5 FROM DUAL
       
SELECT A.FIRST_NAME,
       A.SALARY,
       A.SALARY/33 NOVO,
 TRUNC(A.SALARY/33,2) NOVO
FROM HR.EMPLOYEES A

--SQRT
SELECT SQRT(4) FROM DUAL;
SELECT SQRT(9) FROM DUAL;

SELECT A.SALARY,
      SQRT(A.SALARY)
      FROM HR.EMPLOYEES A

--SIGN(valor) Retorna -1 p negativo, 0 neutro, 1 para positivo com o valor da expressao
SELECT SIGN(-20) TESTE_NEGATIVO,
       SIGN(null) TESTE_null,
       SIGN(30) TESTE_POSITVO,
       SIGN(0) TESTE_NEUTRO
FROM DUAL;

--POWER(valor, n)
-- Eleva a potencia desejada a um determinado numero
-- Eleva a potencia de N o valor. Pode ser negativo

select  power(3,2)T1, -- 3 Elevado ao quadrado
        power(3,3)T2, -- 3 Elevado ao cubo
        power(3,4)T3, -- 3 Elevado a quarta potencia
        power(2,2)T4  -- 2 Elevado ao quadrado
FROM DUAL;


SELECT A.SALARY, 
       POWER(A.SALARY,2) ELEVADO
FROM HR.EMPLOYEES A

--MOD Devolve o resto da divisão de valor1 por valor2.]

SELECT MOD(3,2)RET FROM DUAL  -- 3/2 = 2 sobra 1
SELECT MOD(4,2)RET FROM DUAL  -- 4/2 = sobra 0
SELECT MOD(200,80)RET FROM DUAL -- 200/80 = sobra


--EXP Devolve o valor 'e' elevado a n. e=2.7182818

select exp(1)T1, 
       exp(4)T2
from dual;
 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
40.Funcoes de Cripitografia

SET SERVEROUTPUT ON

--exemplo 1
-- Bloco anonimo do PL/SQL

DECLARE
     v_str VARCHAR2(100);
     v_frase VARCHAR2(100);
    BEGIN
            -- atribuindo valor
     v_frase:= 'Utilidades Oracle';
                                                     --generate encoded value
                                                     --1 PARAM BUF VALOR:  v_frase
                                                     --2 PARAM ENCODE_CHARSET SAO TIPO: WE8ISO8859P1 - AL32UTF8
        -- Encode: Encodifiquei                      --3 PARAM ENCODING - BASE64
      v_str := utl_encode.text_encode(v_frase,'WE8ISO8859P1', UTL_ENCODE.BASE64);  -- Funcao UTL_ENCODE, atribuindo os valores conforme exemplificado acima
      --imprimi valor
      dbms_output.put_line(v_str);
      
      -- Decode: Descodifiquei
      --take the encoded value and decode it
      v_str := utl_encode.text_decode(v_str,'WE8ISO8859P1', UTL_ENCODE.BASE64); 
      --imprimi valor
     dbms_output.put_line(v_str);
     
   END;


--exemplo 2   
	
   set serveroutput on
   
   DECLARE
   v_input varchar2(2000) := 'teste123';
   v_imput_cripto varchar2(32) := null;
   BEGIN                -- Criptografia do tipo md5... funcao:  utl_raw.cast_to_raw
    v_imput_cripto := rawtohex(dbms_obfuscation_toolkit.md5(input => utl_raw.cast_to_raw(v_input)));
    dbms_output.put_line('O valor hash para "' || v_input || '" é "' || nvl(v_imput_cripto, 'xxx')||'".');--NVL, se for Null, trazer xxx...
   end;
   
 
 
   
--exemplo 3

   --criando função para gerar senha
   
   create or replace function md5 (valor varchar) 
     return varchar2 is
     
     v_input varchar2(2000) := valor;
     v_imput_cripto varchar2(32) := null;

   begin
        v_imput_cripto := rawtohex(dbms_obfuscation_toolkit.md5(input => utl_raw.cast_to_raw(v_input)));
   return nvl(v_imput_cripto,'');-- Se nao tiver nada retornará vazio, por conta da funcao NVL
   end;
   
   
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
      
   
  -- testando retorno da função  
    select md5('minhasenha') from dual; -- Vai gerar um chave que vou usar no select abaixo
    
 --testando função com select comparando valores
    select 'TRUE' as retorno 
    from dual
    where '7C67E713A4B4139702DE1A4FAC672344' = md5('minhasenha_errada'); -- Essa criptografia esta errada!!
    
 --testando função com select comparando valores
    select 'TRUE' as retorno 
    from dual
   where '7C67E713A4B4139702DE1A4FAC672344' = md5('minhasenha'); -- Criptografia certa!!!
   
 --testando função com select comparando valores
    select 'TRUE' as retorno 
    from dual
   where '7C67E713A4B4139702DE1A4FAC672344' = 'minhasenha'; -- Se nao chamar a funcao md5, vai dar errado...



-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
41.Funcao LIMITED

--limite de retorno

select * from HR.EMPLOYEES a
Where rownum <= 5
order by a.SALARY desc; -- Cinco maiores salarios: rownum + salary desc

--exemplo

select a.EMPLOYEE_ID,
       a.FIRST_NAME,
       a.salary
    from HR.EMPLOYEES a
Where rownum <= 10
order by a.salary desc;


--exemplo

select a.EMPLOYEE_ID, -- so trouxe 6 registros pq esse departamento so tem 6, prtanto, o limite...
       FIRST_NAME,
       a.salary 
       from HR.EMPLOYEES a
Where DEPARTMENT_ID = '60'
and rownum <= 10
order by a.salary desc;

--exemplo
select a.EMPLOYEE_ID,
       FIRST_NAME,
       a.salary ,
       B.DEPARTMENT_NAME
from HR.EMPLOYEES a
inner join HR.DEPARTMENTS b -- o objetivo e trazer o nome do departamento...
on a.DEPARTMENT_ID = b.DEPARTMENT_ID
Where a.DEPARTMENT_ID = '60'
and rownum <=10
order by a.salary desc;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
42.Funcões de Conversão

--usando cast
--Converte uma expressao de um tipo de dados em outro
-- Obs: Não tem nada a ver com arredondamento de dados, com essa funcao o dado foi convertido...
select cast(1932.450 as integer) conversao from dual; -- Arredondou para baixo

select cast(1932.650 as integer) conversao from dual; -- Arredondou para cima




SELECT * FROM HR.EMPLOYEES; -- NO CAMPO ORIGINAL E NUMBER COM UMA CASA DECIMAL, POREM, COM O "CAST" O DADO FOI TRANSFORMADO P INTEIRO

select cast(a.EMPLOYEE_ID as integer) teste -- VISUALMENTE NAO DA PARA PERCEBER!!!
from HR.EMPLOYEES a;

select cast(a.EMPLOYEE_ID as varchar(3)) teste
from HR.EMPLOYEES a;

--   A função TO_DATE() converte de cadeia de caracteres em data. À data resultante adicionamos um dia;
--  A data obtida pelo comando anterior é apresentada usando o formato definido pelo comando ALTER SESSION SET NLS_DATE_FORMAT;


--TO_DATE(string, máscara de data)
--alterar sessao
--verificar antes de alterar sessao
ALTER SESSION SET NLS_DATE_FORMAT='yyyy-mm-dd hh24:mi:ss';

ALTER SESSION SET NLS_DATE_FORMAT='yy-mm-dd hh24:mi:ss';


select
   a.hire_date,
   to_date(a.hire_date,'yyyy-mm-dd hh24:mi:ss')aaaammdd
from HR.EMPLOYEES a;

--
-- TO_CHAR(data)
--TO_CHAR(data, máscara_data, [nls_date_format] )

alter session set nls_territory='PORTUGAL';-- BRAZIL
alter session set nls_language='PORTUGUESE';
alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
select
  a.first_name,
  a.hire_date,
   to_char(a.hire_date,'day, dd "de" Month "de" YYYY')Data_entenso
from HR.EMPLOYEES a;


SELECT  to_char(SYSDATE,'day, dd "de" Month "de" YYYY')Data_entenso FROM DUAL
--to_char

alter session set nls_territory='PORTUGAL'; --BRAZIL
alter session set nls_language='PORTUGUESE';
alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';


select 
  to_char(to_date('2018-07-17 14:15:45','yyyy-mm-dd hh24:mi:ss'), 'hh:mi:ss') "Hora Minutos Segundos",
  to_char(to_date('2018-07-17 14:15:45','yyyy-mm-dd hh24:mi:ss'), 'scc'     ) "Século",
  to_char(to_date('2018-07-17 14:15:45','yyyy-mm-dd hh24:mi:ss'), 'q'       ) "Trimestre",
  to_char(to_date('2018-07-17 14:15:45','yyyy-mm-dd hh24:mi:ss'), 'HH24'    ) "Hora em formato 24",
  to_char(to_date('2018-07-17 14:15:45','yyyy-mm-dd hh24:mi:ss'), 'HH'      ) "Hora formato 12"
from dual;
  
--TO_CHAR(número)

select 
  a.first_name,
  a.hire_date,
  to_char(a.SALARY,'$9999999')AS salario1, -- uma forma de app a mascara
  to_char(a.SALARY,'$99999')AS salario2,  -- Outra forma de trazer o resultado, se atentar a qtde de caracteres
  '$'||a.SALARY valor -- Uma outra forma de app a mascara com o mesmo resultado
from HR.EMPLOYEES a;

--TO_NUMBER(string)


select to_number('5')+7 as resultado
from dual;

select to_char(sysdate,'ddmmyyyyhh24miss') from dual; -- Escrevendo a data por estenso sem mascara


--NVL( )

select 
  a.first_name,
  a.hire_date,
  a.COMMISSION_PCT,
   nvl(a.COMMISSION_PCT,0) c1
FROM HR.EMPLOYEES a;

SELECT 
    a.first_name,
    a.hire_date,
    NVL(a.COMMISSION_PCT,0) AS RESULTADO
FROM HR.EMPLOYEES a;


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
43.Funções de data parte 1

-- pegando data do servidor
select sysdate from dual;

-- Utilizando mascaras
select 
  sysdate "Data do servidor", 
  to_char(sysdate,'yyyy-mm-dd hh24-mi-ss') "Data formatada", 
  to_char(sysdate, 'SCC') "Século"
from dual;


SELECT SYSDATE AS DIA_ATUAL,
       LAST_DAY(SYSDATE) AS ULTIMO_DIA,
       (SYSDATE - 17)  AS PRIMEIRO_DIA
FROM DUAL;


-- Formatando datas
-- MM = Retorna o número representando o mês. Ex: 04
select to_char(sysdate, 'MM') as campo from dual;

-- MON = Retorna a abreviação do mês, por exemplo ‘ABR’
select to_char(sysdate, 'MON') as campo from dual;

-- MONTH = Retorna o nome completo do mês, por exemplo: ‘ABRIL’
select to_char(sysdate, 'MONTH') as campo from dual;

-- DD = retorna o dia da data informada como parâmetro Ex.: 07
select to_char(sysdate, 'DD') as campo from dual;

-- DY = retorna a abreviação do dia da semana. Exemplo: SEG
select to_char(sysdate, 'DY') as campo from dual;

-- YYYY = retorna o ano com 4 dígitos. Exemplo: 2014
select to_char(sysdate, 'YYYY') from dual;

-- YY = retorna os últimos dois números do ano. Exemplo: 14
select to_char(sysdate, 'YY') as campo from dual;

-- AM (ou PM) = retorna se a hora é de manhã (AM) ou a tarde (PM).
select to_char(sysdate, 'PM') as campo from dual;

--HH = retorna a hora (0 – 12)
select to_char(sysdate, 'HH') as campo from dual; -- Traz a hora no formarto de 12 horas

--HH24 = retorna a hora (0 – 24)
select to_char(sysdate, 'HH24') from dual; -- No formato de 24 horas

--MI = retorna o minuto
select to_char(sysdate, 'MI') as campo  from dual;

--SS = retorna o segundo
select to_char(sysdate, 'SS') as campo  from dual;

-- Os formatos de data podem ser utilizados em conjuntos como por exemplo:
select to_char(sysdate, 'HH24:MI:SS') as campo  from dual

-- Outro exemplo retornando a data no formato mais comum no Brasil.
select to_char(sysdate, 'DD/MM/YYYY HH24:MI:SS') from dual;

--campo tratado

ALTER SESSION SET NLS_LANGUAGE = 'PORTUGUESE';
ALTER SESSION SET NLS_LANGUAGE = 'ENGLISH';


select a.first_name,
       a.hire_date orig,
       to_char(a.hire_date, 'MON')mex_ext,
       to_char(a.hire_date, 'MM')mes_num,
       to_char(a.hire_date, 'MONTH')mes_num,
       to_char(a.hire_date, 'DY')dia_semana
from HR.EMPLOYEES a

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
44.Funcao de data parte 2

-- SUBTRAINDO DIAS
ALTER SESSION SET nls_date_format = 'yyyy-mm-dd hh24:mi:ss';
--ALTER SESSION SET nls_date_format = 'dd-mm-yyyy hh24:mi:ss';




--ADICIONANDO DIAS 
SELECT SYSDATE + 5 FROM DUAL;

--DIFERENCA ENTRE OS DIAS

SELECT TO_DATE(SYSDATE) - TO_DATE('2019-07-17') DIF_DIAS FROM DUAL;


--ADICIONANDO HORAS
ALTER SESSION SET nls_date_format = 'yyyy-mm-dd hh24:mi:ss';

SELECT SYSDATE, 
       SYSDATE + 5 / 24 DATA_HORA_ADD 
FROM DUAL

--ADICIONAR MESES

SELECT SYSDATE DATA_ATUAL, 
       ADD_MONTHS(SYSDATE,2)AS ADD_MESES 
FROM DUAL;


--SUBTRAIR MESES
SELECT SYSDATE DATA_ATUAL, 
       ADD_MONTHS(SYSDATE,-2)AS ADD_MESES 
FROM DUAL;

-- QTD DE MESES ENTRE DATAS
-- Da data de contratacao ate a date de hoje, quantos meses se passou???

SELECT  first_name,
        a.hire_date,
        sysdate,
        trunc(months_between(sysdate,a.hire_date)) AS Meses -- FUNCAO P QUALCULAR ENTRE DATAS
FROM HR.EMPLOYEES a;

--Ultimo dia mes


SELECT  sysdate hoje,
        last_day(sysdate) AS Ult_dia 
from dual;

SELECT  a.hire_date,
        last_day(a.hire_date)AS Ult_dia 
from  HR.EMPLOYEES a;

--next day
--cenario para descobrir um data que acontece toda segunda quinta de cada cada mes;
-- descobrindo data da proxima segunda feira
-- 1 – Domingo 2 – Segunda-Feira 3 – Terça-Feira 4 – Quarta-Feira 5 – Quinta-Feira 6 – Sexta-Feira 7 – Sábado.

select NEXT_DAY(TRUNC(SYSDATE), 2) from dual; -- Descobrindo q dia vai ser a proxima segunda 

select NEXT_DAY(NEXT_DAY(TRUNC(SYSDATE), 2),2) from dual; -- Proxima segunda daqui a duas semanas??    

--
-- Para descobrir quantos anos eu tenho ???
SELECT TRUNC((MONTHS_BETWEEN(SYSDATE, TO_DATE('07/03/1985','dd/mm/yyyy')))/12) AS idade FROM DUAL; 

-- Pra eu saber quantos meses se passaram desde o meu nascimento, so tirar o /12......Conforme abaixo.
SELECT TRUNC((MONTHS_BETWEEN(SYSDATE, TO_DATE('07/03/1985','dd/mm/yyyy')))) AS idade_MESES FROM DUAL

--DIAS DE VIDA
-- QUANTOS DIAS DE VIDA EU TENHO DESDE O MEU NASCIMENTO...
SELECT SYSDATE - TO_DATE('07/03/1985','dd/mm/yyyy')AS DIAS_VIDA FROM DUAL;

--DUAS DE VIDA
SELECT TRUNC(SYSDATE-TO_DATE('05/11/1977','dd/mm/yyyy')) DIAS FROM DUAL;


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
45.Funcoes de Informacao do Sistema

USER: Mostra o nome do utilizador Oracle que logou na sessão.
UID: Mostra o número que a base de dados atribuiu ao utilizador.
USERENV(arg): Envolve dados da sessão atual, os valores de argumento podem ser vários...
  
   
--https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions165.htm
/*
    'LANGUAGE' - lingua;
    'LANG' - país;
    'INSTANCE' - instância (importante no ambiente RAC - Real Application Cluster);
    'TERMINAL' - nome do computador onde está a correr o cliente Oracle - quando o cliente é Java (JDBC) aparece em branco;
    'SESSIONID'- número da sessão Oracle que está em execução;
*/

select 
  userenv('LANGUAGE') as LANGUAGE,
  userenv('LANG') as LANG,
  userenv('INSTANCE') as INSTANCE,
  userenv('TERMINAL') as TERMINAL,
  userenv('SESSIONID') as SESSIONID,
  userenv('CLIENT_INFO') as CLIENT_INFO
from dual;

--OS PARAMETROS ABAIXO, PODEM SER USADOS PARA OBTER AS INFORMACOES DESEJADAS...
/*
AUDITED_CURSORID
AUTHENTICATION_DATA
AUTHENTICATION_TYPE
BG_JOB_ID
CLIENT_IDENTIFIER
CLIENT_INFO
CURRENT_SCHEMA
CURRENT_SCHEMAID
CURRENT_SQL
CURRENT_USER
CURRENT_USERID
DB_DOMAIN
DB_NAME
ENTRYID
EXTERNAL_NAME
FG_JOB_ID
GLOBAL_CONTEXT_MEMORY
HOST
INSTANCE
IP_ADDRESS
ISDBA
LANG
LANGUAGE
NETWORK_PROTOCOL
NLS_CALENDAR
NLS_CURRENCY
NLS_DATE_FORMAT
NLS_DATE_LANGUAGE
NLS_SORT
NLS_TERRITORY
OS_USER
PROXY_USER
PROXY_USERID
SESSION_USER
SESSION_USERID
SESSIONID
TERMINAL 
*/

-- Obs: Na versao Oracle Express Edition, ja vem padrao o banco de dados XE, nao e possivel criar mais bancos nessa versao free...
-- O que nos criamos sao TABLE_SPACE, para fazer analogia ao banco de dados...

--OUTRA FORMA DE USO
SELECT SYS_CONTEXT ('USERENV', 'SESSION_USER')AS QUAL_USER_LOGADO_SESSAO  -- USUARIO Q ESTA LOGADO NESSA SESSAO...
   FROM DUAL;

SELECT SYS_CONTEXT ('USERENV', 'NLS_TERRITORY') -- QUAL TERRITORIO???
   FROM DUAL;
   
--VERIFCANDO USUARIO E UID
select user,uid from dual; -- USUARIO + IDENTIFICADOR UNICO DESSE USUARIO NO BANCO

--USUARIO CORRENTE
SELECT *  FROM USER_USERS;

--DATABASE ATIVO
select SYS.DATABASE_NAME from dual;
 

--CONSULTA DE PARAMETROS VALIDOS PARA ALTERAR A SESSAO
select * from V$NLS_VALID_VALUES  
--verficando parametros

--Paramentros de instancia/
select * from NLS_INSTANCE_PARAMETERS;

--Paramentros de Base de dados/
select * from NLS_DATABASE_PARAMETERS;

--Parametros da sessão
select * from v$nls_parameters;
select * from NLS_SESSION_PARAMETERS;

-- Parâmetros de Linguagem da Sessão do Oracle no Padrão brasileiro:
--facilita a compatibilidade de caracteres, numéricos e datas no padrão brasileiro.

-- PADRAO BRASILEIRO
Alter Session Set nls_language='BRAZILIAN PORTUGUESE';
Alter Session Set NLS_TERRITORY = 'BRAZIL';
Alter Session Set NLS_NUMERIC_CHARACTERS=',.';
ALTER SESSION SET NLS_DATE_FORMAT = 'DD/MM/YYYY HH24:MI:SS';


--Portugal
alter session set nls_territory='PORTUGAL';
alter session set nls_language='PORTUGUESE';
alter session set nls_currency='EUR';

--Padrao americano
ALTER SESSION SET NLS_LANGUAGE= 'AMERICAN';
ALTER SESSION SET NLS_TERRITORY= 'AMERICA' 
ALTER SESSION NLS_CURRENCY= '$' 
ALTER SESSION NLS_ISO_CURRENCY= 'AMERICA' 
ALTER SESSION NLS_NUMERIC_CHARACTERS= '.,' 
ALTER SESSION NLS_CALENDAR= 'GREGORIAN' 
ALTER SESSION NLS_DATE_FORMAT= 'DD-MON-RR' 
ALTER SESSION NLS_DATE_LANGUAGE= 'AMERICAN' ;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
SECAO 6: VIEWS E TEMP TABLE
46.VIEWS
/*
VIEWS Tabela lógica baseado em uma tabela física...

Vantagens da views: 
				REUSO: As views são objetos de carater permanente
				SEGURANCA: As views permitem q ocutamos determinadas colunas de uma tabela
				SIMPLIFICAÇÃO DO CODIGO: As views nos permitem criar um código de programação muito mais limpo, na medida em q podem conter um SELECT complexo.
*/

--criar view que traga as informaçõe dos funcionarios, salario,departamentos

create or replace view v_func_depto
as
select a.EMPLOYEE_ID,
       a.FIRST_NAME,
       a.SALARY,
       a.DEPARTMENT_ID,
       b.DEPARTMENT_NAME
from HR.EMPLOYEES a
inner join hr.DEPARTMENTS b
on a.DEPARTMENT_ID = b.DEPARTMENT_ID;

-- usando a view

GRANT ALL PRIVILEGES TO ALUNO;
REVOKE ALL PRIVILEGES FROM ALUNO;


select * from v_func_depto
where DEPARTMENT_ID='20';

--atualizando a view
create or replace view v_func_depto
as
select a.EMPLOYEE_ID,
       a.FIRST_NAME as primeiro_nome,
       a.LAST_NAME as ultimo_nome,
       a.SALARY,
       a.DEPARTMENT_ID,
       b.DEPARTMENT_NAME
from HR.EMPLOYEES a
inner join hr.DEPARTMENTS b
on a.DEPARTMENT_ID=b.DEPARTMENT_ID;


-- usando a view

select * from v_func_depto
where DEPARTMENT_ID='20';

-- paises, location e regios
create or replace view v_pais_regiao
as
select a.COUNTRY_ID,
       a.COUNTRY_NAME,
       a.REGION_ID,
       b.REGION_NAME
from HR.COUNTRIES a
inner join HR.REGIONS b
on a.REGION_ID = b.REGION_ID;


--usando a view 
select * from v_pais_regiao where region_name  <> 'Europe';

--reutilizado a view

select region_name,
       count(*) qtd -- QUANTOS PAISES P CADA REGIAO???
from v_pais_regiao
group by region_name;

-- reutilizando view  e gerando outra view
create  view  v_pais_local
as
select a.LOCATION_ID,
       a.CITY,
       b.COUNTRY_NAME
from hr.locations a
inner join v_pais_regiao b
on a.COUNTRY_ID = b.COUNTRY_ID;

-- usando a view

select * from v_pais_local where country_name <> 'Italy';

-- criando views com union all
create view v_depto_union
as
select a.EMPLOYEE_ID,a.FIRST_NAME,a.SALARY,a.DEPARTMENT_ID,b.DEPARTMENT_NAME
from HR.EMPLOYEES a
inner join hr.DEPARTMENTS b
on a.DEPARTMENT_ID = b.DEPARTMENT_ID
where a.DEPARTMENT_ID = '10'

union all

select a.EMPLOYEE_ID,a.FIRST_NAME,a.SALARY,a.DEPARTMENT_ID,b.DEPARTMENT_NAME
from HR.EMPLOYEES a
inner join hr.DEPARTMENTS b
on a.DEPARTMENT_ID = b.DEPARTMENT_ID
where a.DEPARTMENT_ID  = '20'

union all

select a.EMPLOYEE_ID,a.FIRST_NAME,a.SALARY,a.DEPARTMENT_ID,b.DEPARTMENT_NAME
from HR.EMPLOYEES a
inner join hr.DEPARTMENTS b
on a.DEPARTMENT_ID = b.DEPARTMENT_ID
where a.DEPARTMENT_ID not in ('10','20');

-- usando a view
select * from v_depto_union 
ORDER BY EMPLOYEE_ID;

-- criar view de historico de funcionario

-- verificando se algum funcionario nao tem historico

select * from HR.EMPLOYEES
where EMPLOYEE_ID not in (select EMPLOYEE_ID from HR.JOB_HISTORY);

--verificando os empregados tem historico
select * from HR.EMPLOYEES
where EMPLOYEE_ID  in (select EMPLOYEE_ID from HR.JOB_HISTORY);



select * from hr.JOB_HISTORY
where EMPLOYEE_ID='101'

select  * from HR.EMPLOYEES
where EMPLOYEE_ID='101';


-- criando a view de historico de funciorios/ usando union all
create or replace view v_hist_func
as
--selectionando informações do historico
select a.EMPLOYEE_ID,
       b.FIRST_NAME,
       a.START_DATE,
       a.END_DATE,
       a.JOB_ID,
       c.JOB_TITLE, 
       a.DEPARTMENT_ID,
       d.DEPARTMENT_NAME
from hr.JOB_HISTORY a
inner join hr.EMPLOYEES b
on a.EMPLOYEE_ID = b.EMPLOYEE_ID
inner join hr.JOBS c
on a.JOB_ID = c.JOB_ID
inner join HR.DEPARTMENTS d
on a.DEPARTMENT_ID = d.DEPARTMENT_ID
--where a.EMPLOYEE_ID='101'

union all

select a.EMPLOYEE_ID,
       a.FIRST_NAME,
       (select max(b.END_DATE) + 1 from hr.JOB_HISTORY b where a.EMPLOYEE_ID = b.EMPLOYEE_ID) as START_DATE,
       sysdate END_DATE,
       a.JOB_ID,
       c.JOB_TITLE,
       a.DEPARTMENT_ID,
       d.DEPARTMENT_NAME
from hr.EMPLOYEES a
inner join hr.JOBS c
on a.JOB_ID = c.JOB_ID
inner join HR.DEPARTMENTS d
on a.DEPARTMENT_ID = d.DEPARTMENT_ID
--where a.EMPLOYEE_ID = '101'
order by 1 asc,3 asc;

--consultando view
select * from v_hist_func
where EMPLOYEE_ID = '101';

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
47.TEMP TABLE

--Tabelas Temporarias:
	TEMPORARY: Indica que a tabela criada será temporária, o que significa que ela expira assim q sua "sessao ou transação no Oracle terminar".

	Uma tabela temporária é uma tabela com vida útil de uma sessão ou transação. Ela está vazia quando a sessão ou transação começa e descarta os dados ao fim da sessão ou transação
	Uma tabela temporária é associada a uma transação, isto significa q ao términio da transação os dados da tabela são perdidos, porém, sua descrição permanece gravada no banco de 
	dados mesmo após a mudança de sessao.
	
	Em resumo a tabela permance ao fim da sessão, porém, sem dados...

-- Sequencia exemplo 1
--A cláusula indica que os dados devem ser excluídos no final da transação ou no final da sessão.
-- criando tabela temporaria

CREATE GLOBAL TEMPORARY TABLE minha_temp (
  id    NUMBER,
  nome  VARCHAR2(20)
)
ON COMMIT DELETE ROWS; -- com essa clausula, estou dizendo q quando ouver um commit, deve deletar os registros...

-- Inserindo, mas nao realizando commit, .
INSERT INTO minha_temp VALUES (1, 'Teste1');
INSERT INTO minha_temp VALUES (2, 'Teste2');
INSERT INTO minha_temp VALUES (3, 'Teste3');

-- analisando counteudo
SELECT COUNT(*) FROM minha_temp;
select * from minha_temp;

-- Commit and check contents.
COMMIT;

-- analisando counteudo
SELECT COUNT(*) FROM minha_temp;

-- sequencia exemplo 2
--A cláusula indica que as linhas devem persistir além do final da transação.
-- Eles serão removidos apenas no final da sessão.
CREATE GLOBAL TEMPORARY TABLE minha_temp (
  id           NUMBER,
  nome  VARCHAR2(20)
)
ON COMMIT PRESERVE ROWS;

-- Inserindo, realizando commit, .
INSERT INTO minha_temp VALUES (1, 'Teste1');
INSERT INTO minha_temp VALUES (2, 'Teste2');
INSERT INTO minha_temp VALUES (3, 'Teste3');
commit;
-- analisando counteudo
SELECT COUNT(*) FROM minha_temp;
-- desconecta
--reconecta

SELECT COUNT(*) FROM minha_temp;

--carregando uma tabela temp com dados de uma tabela normal
--criando tabela
CREATE global temporary TABLE empregados_temp
(
  EMPLOYEE_ID NUMBER(6, 0) NOT NULL 
, FIRST_NAME VARCHAR2(20 BYTE) 
, LAST_NAME VARCHAR2(25 BYTE) NOT NULL 
, COMMISSION_PCT NUMBER(2, 2) 
) ON COMMIT DELETE ROWS;

--inserindo registros na temp
insert into empregados_temp
select a.EMPLOYEE_ID,a.FIRST_NAME,a.LAST_NAME,a.COMMISSION_PCT
from HR.EMPLOYEES a;

--verificando dados antes do committ
select count(*) from empregados_temp;

commit;

--verificando dados apos do committ
select count(*) from empregados_temp;

drop table empregados_temp;
drop table minha_temp;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
48.Siga em frente! Vamos até o final!!


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
SECAO 7:PL/SQL
49.INTRODUCAO

A linguagem PL/SQL inclui a linguagem procedural para banco de dados, tais como: LOOP, WHILE, FOR, ARRAY e etc.
Essa linguagem permite também a declaração e criação de variáveis, constantes e tipos. Podemos usar PL/SQL em:

Bloco anônimo, Procedures, Triggers, Packages, Functions e Types.

Obs: Blocos anônimos são blocos sem nomes. Eles são declarados em um ponto do aplicativo onde eles devem ser executados e são passados para o mecanismo PL/SQL para serem executados
em tempo de execução...


Estrutura de bloco PL/SQL

DECLARE - Opcional
	Variáveis, Curosres, Execoes definidas pelo usuário.
	
BEGIN - Obrigatório
		Instrucao SQL
		Instrucao PL/SQL
		
EXCEPTION - Opcional
			Acoes a serem desenpenhadas quando ocorrem erros
			
END - Obrigatorio

Toda unidade PL/SQL compreende um ou mais blocos. Onde esses blocos podem ser inteiramente separados ou aninhados um dentro do outro. Existem 3 tipos de blocos:
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
BLOCO ANONIMO:

BEGIN
	
	statements
	
	EXCEPTION -- Opcional
END;
			
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
BLOCO DE PROCEDIMENTO:

	PROCEDURE NOME
	IS
	BEGIN
		statements
		
		EXCEPTION -- Opcional
	END;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
BLOCO DE FUNCAO:

	FUNCTION NAME
	RETURN datatype
	IS
	BEGIN
		statements
		
		RETURN value
		EXCEPTION -- Opcional
	END;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
50.Conjunto de Caracteres

@ = Indicador de localização
<<e>>  = Delimitadores de tabelas

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
51.Variaveis

Exemplo de Variáveis:

VDATA_NASC DATE;
VCOD_FUNC NUMBER(2) NOT NULL := 10; -- Como e not null, foi atribuido valor
VCIDADE VARCHAR2(30) := 'JUNDIAI';
VPI CONSTANT NUMBER := 3.1415;
VBLOQUEADO BOOLEAN := FALSE;

EXEMPLO BLOCO ANONIMO:
	
DECLARE

v_tot_sal NUMBER(10,2);
v_depto NUMBER;
v_qtd int;

BEGIN
v_depto := 100;

SELECT SUM(A.salary), count(*) qtd
  INTO v_tot_sal, v_qtd
  FROM hr.employees A WHERE A.department_id = v_depto;
 
 dbms_output.put_line('Total de salario depto  '||v_depto||' é '||v_tot_sal);
 dbms_output.put_line('Total de de Colaboradores é  '||v_qtd);
 dbms_output.put_line('Media de Salario  '||round(v_tot_sal/v_qtd,2)); -- 2 de duas casas decimais

END;

SELECT SUM(SALARY), COUNT(*) AS QTDE
FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID = 100



-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
52.Atributos Type e Rowtype

%TYPE - Para o campo
%ROWTYPE - Para a tabela toda


-- Exibe dados de um funcionario da tabela 'employees', schema 'hr' --
--% comercial na variavel fora PL/SQL pedir valor para variavel
--usando TYPE

set SERVEROUTPUT OFF;
DECLARE
   v_id hr.employees.employee_id%TYPE;
   v_name hr.employees.first_name%TYPE;
   v_sal hr.employees.salary%TYPE;
BEGIN
   SELECT a.employee_id, a.first_name, a.salary 
   INTO v_id, v_name, v_sal
   FROM hr.employees a
   WHERE a.employee_id = &emp_id;
 
   DBMS_OUTPUT.PUT_LINE('-----------------------------------');
   DBMS_OUTPUT.PUT_LINE('ID: ' || TO_CHAR(v_id));
   DBMS_OUTPUT.PUT_LINE('Nome: ' || TO_CHAR(v_name));
   DBMS_OUTPUT.PUT_LINE('Salario: ' || TO_CHAR(v_sal));
   DBMS_OUTPUT.PUT_LINE('-----------------------------------');
END;
/
SELECT * FROM hr.employees;

set SERVEROUTPUT ON;
--------------------------------------------------------------------------------------------------------------------------------------------------------
DECLARE
   v_emp hr.employees%ROWTYPE; -- Se usar todos os campos da tabela, nao precisa declaras todos os campos... Apenas umvariavel herdando todos os campos da tabela....
BEGIN
   SELECT * INTO v_emp -- Atribuindo todos os campos dentro dessa variavel
   FROM hr.employees
   WHERE employee_id = &emp_id;
 
   DBMS_OUTPUT.PUT_LINE('-----------------------------------');
   DBMS_OUTPUT.PUT_LINE('ID: ' || TO_CHAR(v_emp.employee_id));
   DBMS_OUTPUT.PUT_LINE('Nome: ' || TO_CHAR(v_emp.first_name));
   DBMS_OUTPUT.PUT_LINE('Sobrenome: ' || TO_CHAR(v_emp.last_name));
   DBMS_OUTPUT.PUT_LINE('-----------------------------------');
END;
/

-- tratando codigo nao existente

-- Exibe dados de um funcionario da tabela 'employees', schema 'hr' --
--% comercial na variavel fora PL/SQL pedir valor para variavel

DECLARE
   v_emp hr.employees%ROWTYPE;
   
BEGIN

   SELECT * INTO v_emp
   FROM hr.employees
   WHERE employee_id = &emp_id;


   DBMS_OUTPUT.PUT_LINE('-----------------------------------');
   DBMS_OUTPUT.PUT_LINE('ID: ' || TO_CHAR(v_emp.employee_id));
   DBMS_OUTPUT.PUT_LINE('Nome: ' || TO_CHAR(v_emp.first_name));
   DBMS_OUTPUT.PUT_LINE('Sobrenome: ' || TO_CHAR(v_emp.last_name));
   DBMS_OUTPUT.PUT_LINE('-----------------------------------');
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Matricula não existe');
      
END;
/
    

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------    
53.Tipos de Registros

PL/SQL - TIPOS DE REGISTROS

Um registro é uma coleção de valores individuais que estão relacionados de alguma forma. Com frequência "os registros são usados para representar uma linha de uma tabela",
e assim o relacioamento se baseia no fato de que todos os valores vêm da mesma linha. Cada campo de um registro é exclusivo e tem seus próprios valores.
Um registro como um todo não tem um valor.

DECLARE
	-- Definição de tipos
	
	TYPE TFuncionsarios IS RECORD 
		(NOME VARCHAR2(40),
		 DEPTO VARCHAR2(20),
		 SALARIO NUMBER(10,2),
		 );
		 -- Declaração de variaveis
		 VFunc TFuncionsario;  -- Essa variavel pega todos os valores do tipo do registro...
		 
		 BEGIN
		 
		 END;;;
							

EXEMPLO:

-- Exibe dados de um funcionario da tabela 'employees', schema 'hr' --
--% comercial na variavel fora PL/SQL pedir valor para variavel
SET SERVEROUTPUT ON;

DECLARE
-- Definição de tipos
TYPE TFuncionario IS RECORD (Nome VARCHAR2(40),
                             Depto VARCHAR2(20),
                             Salario NUMBER(10,2)
                            );
-- Declaração de variáveis
vFunc TFuncionario;
BEGIN
-- Atribuir valor para o registro vProduto
SELECT a.FIRST_NAME, a.DEPARTMENT_ID, a.SALARY
INTO vFunc.Nome, vFunc.Depto, vFunc.Salario
FROM hr.employees a
WHERE a.EMPLOYEE_ID = 103;
-- Imprimir na tela os dados recuperados
dbms_output.put_line('Nome do Func: '||vFunc.Nome||chr(10)
                                     ||'Depto: '||vFunc.Depto||chr(10)
                                     ||'Salario: '||to_char(vFunc.Salario));
END;
/


							
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------    
54.Escopo de Variaveis

Obs: Não podemos declarar "uma variável duas vezes no mesmo bloco", mas podemos declarar a mesma variavel em dois blocos diferentes!!!

--SET SERVEROUTPUT OFF;

<<BLOCOPRINCIPAL>> --Declaracao de label de escopo

DECLARE
V_NUM1 NUMBER := 100;

BEGIN -- BLOCO PRINCIPAL --
    DECLARE
        V_NUM1 NUMBER := 50;
			--  BLOCO INTERMEDIARIO --
            BEGIN 
            DBMS_OUTPUT.PUT_LINE('Impressão 1 '||BLOCOPRINCIPAL.V_NUM1); -- Aqui vale 100, por conta da referencia "BLOCOPRINCIPAL"
            DBMS_OUTPUT.PUT_LINE('Impressão 2 '||V_NUM1);
            END;
    DBMS_OUTPUT.PUT_LINE('Impressão 3 '||V_NUM1);
END;
/

--------------------------------------------------------------------------------------------------------------------------------------------------------
--outro exemplo
DECLARE 
    V_TEMP NUMBER := 100;

BEGIN
  DBMS_OUTPUT.PUT_LINE(V_TEMP);
  
      DECLARE 
        V_TEMP NUMBER := 200;
      BEGIN
        DBMS_OUTPUT.PUT_LINE(V_TEMP);
      END;
      
  DBMS_OUTPUT.PUT_LINE(V_TEMP);
END;
/

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	
55.Identificadores


Variavel: Deve conter no maximo 30 caracteres
		  Começar com uma letra
		  Não pode conter Whitespace
		  
		  

Para conhece as palavras reservadas, podemos executar essa VIEW: V$RESERVED_WORDS;		  
		SELECT * FROM V$RESERVED_WORDS;
	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	
56.Blocos Anônimos

	
-- Exemplo mostras quantidade de  funcionarios na tabela EMPLOYEES
set SERVEROUTPUT ON;
DECLARE
-- Declaração de variáveis
vCount INTEGER;

BEGIN
    -- Recuperar quantidade de Funcionarios cadastrados
    SELECT count(*)
    INTO vCount
    FROM HR.EMPLOYEES;
    -- Imprimir, na tela, a quantidade de Funcionarios cadastrados
    dbms_output.put_line('Existem '||to_char(vCount)||' Funcionarios cadastrados.');
    EXCEPTION
    /* Se ocorrer qualquer erro, informar o usuário que não foi possível verificar a quantidade de produtos cadastrados */
    WHEN OTHERS THEN
    dbms_output.put_line('Não foi possível verificar a quantidade de'||'Funcionarios cadastrados.');
END;
/

-- Exemplo print de data

DECLARE
    V_HOJE date default sysdate;
BEGIN
    -- IMPRIME A DATA
    DBMS_OUTPUT.PUT_LINE('HOJE É '||V_HOJE);
END;

--CONTANDO DIAS DE VIDA
DECLARE
  V_DATA_NASC DATE := '07/03/1985';
  V_HOJE DATE default sysdate;
  V_DIAS INT;
  BEGIN
    V_DIAS:= V_HOJE - V_DATA_NASC;
    DBMS_OUTPUT.PUT_LINE('ESTOU VIVO A  '||V_DIAS||' DIAS');
  END;
  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	
57.Estrutura IF-THEN / IF-THEN-ELSE / IF-THEN-ELSIF


-- Bloco if then comparando valores
SET SERVEROUTPUT ON
ACCEPT v_digitado PROMPT 'Digite o numero da sorte:' -- ACCPT: Recurso utilizado, quando se usa a janela.
                                                     -- Exemplo abaixo: v_digitado

DECLARE
      v_numero int;
      v_sorte int default 5;     
  BEGIN
      v_numero :=&v_digitado;
      IF v_numero = v_sorte THEN
        DBMS_OUTPUT.PUT_LINE('Parabens!!! Você acertou!!!');
      END IF;
  END;
  /
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
-- exemplo usando a estrutura IF - THEN - ELSE  
  SET SERVEROUTPUT ON
ACCEPT v_digitado PROMPT 'Digite o nuemero da sorte:'
DECLARE
      v_numero int;
      v_sorte int default 5;     
  BEGIN
      v_numero:=&v_digitado;
      IF v_numero = v_sorte THEN
        DBMS_OUTPUT.PUT_LINE('Parabens!!! Voce acertou');
        else
         DBMS_OUTPUT.PUT_LINE('oh oHH!! errou tente outra vez!');
   END IF;
  END;
  /
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
-- USANDO A ESTRUTURA IF THEN ELSEIF  
  SET SERVEROUTPUT OFF
  ACCEPT v_digitado PROMPT 'Digite um numero de 0 a 100:'
 
  DECLARE
      v_numero int;     
  BEGIN
      v_numero :=&v_digitado;
      IF v_numero <=10 THEN
            DBMS_OUTPUT.PUT_LINE('seu numero esta entre 0 a 10');
        ELSIF  v_numero > 10 and v_numero <=30 THEN
            DBMS_OUTPUT.PUT_LINE('seu numero esta entre 11 a 30');
        ELSIF  v_numero > 30 and v_numero<=50 THEN
            DBMS_OUTPUT.PUT_LINE('seu numero esta entre 31 a 50');
        ELSIF  v_numero > 50 and v_numero<=100 THEN
            DBMS_OUTPUT.PUT_LINE('seu numero esta entre 51 a 100');
        else
            DBMS_OUTPUT.PUT_LINE('seu numero esta fora os limites');
      END IF;
  END;
  /
    
    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	
58.Estrutura de Case when
/*
A instrução CASE é uma forma mais compacta para realizar a avaliação de uma única condição e escolher entre algumas ações alternativas.
No caso de termos mais de dois IF's, de certa forma, passa a ser mais aplicável a ultilização de CASES.
*/
--exemplo usando case
SET SERVEROUTPUT ON
ACCEPT v_nota_dig PROMPT 'Digite sua Nota:'

DECLARE
      v_nota integer;
    BEGIN
      v_nota := &v_nota_dig;
    
     CASE v_nota
        WHEN 10 THEN DBMS_OUTPUT.PUT_LINE('Nota Excelente');
        WHEN 9 THEN DBMS_OUTPUT.PUT_LINE('Nota muito boa');
        WHEN 8 THEN DBMS_OUTPUT.PUT_LINE('Boa nota');
        WHEN 7 THEN DBMS_OUTPUT.PUT_LINE('Nota na média');
        WHEN 6 THEN DBMS_OUTPUT.PUT_LINE('Nota abaixo da média');
        ELSE DBMS_OUTPUT.PUT_LINE('Sem classificação de notas');
      END CASE;
   END;
   /
   
 -- exemplo usando case com EXCEPTION  
 -- exemplo usando case com EXCEPTION  
SET SERVEROUTPUT ON
ACCEPT v_nota_dig PROMPT 'Digite sua Nota:'

DECLARE
      v_nota integer;
    BEGIN
      v_nota := &v_nota_dig;   
     CASE v_nota
        WHEN 10 THEN DBMS_OUTPUT.PUT_LINE('Nota Excelente');
        WHEN 9 THEN DBMS_OUTPUT.PUT_LINE('Nota muito boa');
        WHEN 8 THEN DBMS_OUTPUT.PUT_LINE('Boa nota');
        WHEN 7 THEN DBMS_OUTPUT.PUT_LINE('Nota na média');
        WHEN 6 THEN DBMS_OUTPUT.PUT_LINE('Nota abaixo da média');
      END CASE;
      -- NESSE EXEMPLO, NAO ESTOU USANDO O ELSE, PQ UTILIZO O EXCPTION!!!
      EXCEPTION
        WHEN CASE_NOT_FOUND THEN
          DBMS_OUTPUT.PUT_LINE('Sem classificação de notas');
   END;
   /
   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	
59.GOTO

Com a declaração GOTO, o controle é transferido para a label incondicionalmente, onde temos também que o label deve ser único dentro de um escopo e deve ser posto antes de uma declaração executável ou mesmo de um bloco PL/SQL.

-- VERIFICANDO NUMERO PAR OU IMPAR
SET SERVEROUTPUT ON

DECLARE
    tipo_numero VARCHAR2(100);
    j INTEGER;
BEGIN 
    FOR j in 1..10 LOOP
      IF MOD(J,2) = 0 THEN -- se esse numero nao tem sobra, é par!!!
        tipo_numero := ' Numero par';
        
         GOTO mensagem; -- necessari para trabalhar com:    <<mensagem>> +      DBMS_OUTPUT.PUT_LINE(), conforme exemplo abaixo...
        ELSE
        tipo_numero := ' Numero impar';
        
        GOTO mensagem;
      END IF;
    <<mensagem>>
    DBMS_OUTPUT.PUT_LINE(TO_CHAR(j) || tipo_numero);
    
     END LOOP;
  END;
  /

--ANALISE NUMERO PRIMO
/*
A definição mais comum é que "um número é primo se for divisível por 1 e por ele mesmo" ou então "é 
todo o número com dois e somente dois divisores, ele próprio e a unidade
*/

/*
Variável escalar numérica:
São as variáveis utilizadas para armazenar números inteiros ou valores reais. Existem três derivações deste tipo de variável no PL/SQL: NUMBER, PLS_INTEGER e BINARY_INTEGER.
*/

SET SERVEROUTPUT ON
DECLARE
    tipo_numero VARCHAR2(100);
    valor PLS_INTEGER := 12; --  armazenar números inteiros ou valores reais
  BEGIN
    FOR j in 2..ROUND(SQRT(valor)) LOOP
      IF valor MOD j = 0 THEN
        tipo_numero := ' este não é um número primo';
        GOTO mensagem;
      END IF;
    END LOOP;
    tipo_numero := ' Este é um número primo';
    <<mensagem>>
    DBMS_OUTPUT.PUT_LINE(TO_CHAR(valor) || tipo_numero);
  END;
  /


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	
60.LOOP FOR

-- Laço for para tabuada

--CRIANDO SET SERVEROUTPUT ON
ACCEPT V_Digitado PROMPT 'Digite a tabuada:'

DECLARE
 
 V_TAB INT :=2;
 
 BEGIN
    --V_TAB :=&V_Digitado;
    
    FOR  SEQ IN 1..10 LOOP -- SEQ: Essa variavel e o indicie.
         DBMS_OUTPUT.PUT_LINE (SEQ||' X '||V_TAB||' = '||SEQ * V_TAB);
     END LOOP;
 END;
 
 
--TABELA DE TESTE
CREATE TABLE TESTE_FOR
                (NUMERO1 INT,
                 NUMERO2 INT
                );

--LOOP PARA INSERT

 BEGIN  
    FOR  VALOR IN 1..10 LOOP
         INSERT INTO TESTE_FOR (NUMERO1) VALUES (VALOR);
     END LOOP;
     COMMIT;
 END;
 
 --VERIFCANDO
 SELECT * FROM TESTE_FOR;

--EXEMPLO UPDATE

 BEGIN  
    FOR  VALOR IN 1..10 LOOP
         UPDATE TESTE_FOR SET NUMERO2 = NUMERO1 * VALOR
         WHERE numero1 = VALOR;
     END LOOP;
     COMMIT;
 END;

--
 --VERIFCANDO
 SELECT * FROM TESTE_FOR;
 
 
 --LOOP REVERSE
 BEGIN
   
       FOR x IN 1..5 LOOP
          dbms_output.put_line('Contador crescente : '|| TO_CHAR(x) );
       END LOOP;
   
       dbms_output.put_line(' - ');
       
       FOR x IN REVERSE 1..5 LOOP -- REVERSE, IMPORTANTE SABER USAR...
        dbms_output.put_line('Contador decrescente : '|| TO_CHAR(x) );
       END LOOP;
 
  END;
  
  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	
61.LOOP CONTINUE
-- ENQUANTO A CONDICAO FOR VALIDO SERA EXECUTADO, DO CONTRARIO O LAÇO SAIRA FORA...
-- OBS: QUANDO SE TRABALHA COM LOOP, TEM Q USAR UMA VARIAVEL CONTADORA, PARA Q O LOOP NAO FIQUE INFINITO...

-- EXEMPLO USANDO REPETICAO WHILE
SET SERVEROUTPUT ON
ACCEPT V_Digitado PROMPT 'Digite a tabuada:'

DECLARE
 V_TAB int :=5;
 V_LIMIT int default 1;
 BEGIN
   --V_TAB :=&V_Digitado;
   
  WHILE  V_LIMIT <= 10 LOOP
    DBMS_OUTPUT.PUT_LINE (V_LIMIT||' X '||V_TAB||' = '||V_LIMIT*V_TAB);
    --CONTADOR
    V_LIMIT:=V_LIMIT+1;
  END LOOP;
 END;
 
 -- EXEMPLO USANDO ESTRUTURA WHILE COM EXIT
 
 SET SERVEROUTPUT ON
ACCEPT V_Digitado PROMPT 'Digite a tabuada:'

DECLARE
 V_TAB int;
 V_LIMIT int default 1;
 
 BEGIN
   V_TAB:=&V_Digitado;
  WHILE  V_LIMIT <=10 LOOP
    DBMS_OUTPUT.PUT_LINE (V_LIMIT||' X '||V_TAB||' = '||V_LIMIT*V_TAB);
    V_LIMIT := V_LIMIT+1;
    EXIT WHEN V_LIMIT >5; -- UMA CONDICAO P SAIR DO LOOP...
  END LOOP;
 END;
 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	
62.LOOP CONTINUE

DECLARE
    P_VALOR NUMBER := 0;
    
  BEGIN
    LOOP
      DBMS_OUTPUT.PUT_LINE ('Dentro do Loop o valor e igual a: '||TO_CHAR(P_VALOR));
      P_VALOR := P_VALOR + 1;
      CONTINUE WHEN P_VALOR < 5;
      DBMS_OUTPUT.NEW_LINE;
      
      DBMS_OUTPUT.PUT_LINE ('Apos a cláusula CONTINUE, o valor e igual a: '||TO_CHAR(P_VALOR));
      EXIT WHEN P_VALOR = 5;
      END LOOP;
      DBMS_OUTPUT.NEW_LINE;
    
    DBMS_OUTPUT.PUT_LINE ('Apos o loop, o valor e igual a:' || TO_CHAR(P_VALOR));
  END;
  /
  
 -- outro exemplo 
  
  DECLARE
   valor NUMBER := 0;
   
  BEGIN
    LOOP -- Após a declaração CONTINUE
      DBMS_OUTPUT.PUT_LINE ('Valor apresentado no interior do loop é igual a: ' || TO_CHAR(valor));
      valor := valor + 1;
      IF valor < 15 THEN
        CONTINUE;
      END IF;
      DBMS_OUTPUT.NEW_LINE;
      
      DBMS_OUTPUT.PUT_LINE ('No interior do loop, após a cláusula IF-CONTINUE, o valor é igual a: ' || TO_CHAR(valor));
      EXIT WHEN valor > 15;
    END LOOP;
    DBMS_OUTPUT.NEW_LINE;
    
    DBMS_OUTPUT.PUT_LINE ('Após o loop, o valor é igual a: ' || TO_CHAR(valor));
  END;
  /
 
  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	
SECAO 8:EXCESSÕES
63.INTRODUCAO

Geralmente quando um erro ocorre, o processamento do bloco PL/SQL é imediatamente encerrado.

EXISTEM TRÊS TIPO DE EXCEÇÕES NA PL/SQL:

** Erros predefinidos da Oracle;
** Erros não definidos da Oracle;
** Erros definidos pelo usuário;

 	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	
64.Tratando Excessões

-- TRATANDO EXCESSOES 1
SET SERVEROUTPUT ON

DECLARE
lv_excessao EXCEPTION; -- Variavel do tipo exception

PRAGMA exception_init (lv_excessao,-6502); -- 

BEGIN
   
    RAISE lv_excessao;  -- Raise chama o erro!!!
    EXCEPTION -- Aqui comeca a tratativa
    WHEN OTHERS THEN
    IF SQLCODE = 1 THEN
        dbms_output.put_line('Erro que usuario tratou linha 1'||SQLCODE||' - '||sqlerrm);
        ELSE 
        dbms_output.put_line('Erro que usuario tratou linha 2'||SQLCODE||' - '||sqlerrm);
    END IF;
END;

-- TRATANDO EXCESSOES 2
set SERVEROUTPUT ON
declare
lv_excessao exception;
pragma EXCEPTION_INIT (lv_excessao,-20000);
begin
   
    RAISE_APPLICATION_ERROR(-20000, 'Mensagem Tratada');
    exception
    when lv_excessao then
        dbms_output.put_line(SQLCODE);
        dbms_output.put_line(SQLERRM);
end;


-- TRATANDO EXCESSOES 3
-- TRATAR NUMEROS INTERVALOS ENTRE 50 E 100
set SERVEROUTPUT ON
declare
    P_NUM INT DEFAULT 75;
    EXC_MENOR exception;
    EXC_MAIOR exception;
   
BEGIN
    IF P_NUM>100 THEN
    RAISE EXC_MAIOR;
    ELSIF P_NUM<50 THEN
    RAISE EXC_MENOR;
    ELSE
     dbms_output.put_line('OK!!!!');
    END IF;
    
    EXCEPTION
    when EXC_MENOR THEN
        dbms_output.put_line('Numero menor que 50 digite um entre 50 e 100');
    when EXC_MAIOR THEN
        dbms_output.put_line('Numero maior que 100 digite um entre 50 e 100'); 
    WHEN OTHERS THEN
        dbms_output.put_line('CODIGO E ERRO '||SQLCODE||'MSG '||SQLERRM);
         
end;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- ERRO DEFINIDO PELA ORACLE --
-- TRATANDO EXCESSOES 4
--divide por zero
DECLARE
v_num  NUMBER;
BEGIN

   v_num := 1/1;

    EXCEPTION
      WHEN ZERO_DIVIDE THEN -- este é o “rótulo” dado pelo Oracle
                            -- para o tipo de erro disparado
                            -- quando ocorre a divisão por zero.
 
         DBMS_OUTPUT.PUT_LINE('----------------------------------');
         DBMS_OUTPUT.PUT_LINE('Erro: divisão por ZERO.');
         DBMS_OUTPUT.PUT_LINE('Não é possível obter ov_num = 1/0.');
         DBMS_OUTPUT.PUT_LINE('----------------------------------');
         DBMS_OUTPUT.PUT_LINE('Código Oracle: ' || SQLCODE);
         DBMS_OUTPUT.PUT_LINE('Mensagem Oracle: ' || SQLERRM);        
         
END ;

-- TRATANDO EXCESSOES 5
--tratando outros erros
DECLARE
v_num  NUMBER;
BEGIN

   v_num := 1/0;
EXCEPTION
WHEN OTHERS THEN
    IF     sqlcode ='-12170' THEN --> Erro de CONEXÃO 
    dbms_output.put_line('Erro de conexão! Verifique se a maquina esta ligada!');
   ELSE
     dbms_output.put_line('Erro na integração!'||SQLERRM);
   END IF;                     
  END;

    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	  
SECAO 9:CURSORES PL/SQL
65.CURSORES INTRODUCAO

Os cursores da PL/SQL fornecem um modo pelo qual seu programa pode selecionar várias linhas de dados do banco de dados e depois processar cada linha individual.

Existem dois tipos de cursores:

Cursores Implícitos: 
			São cursores declarados pelo PL/SQL implicitamente para todos os comandos DML e comandos SELECT no PL/SQL, independente da quantidade de registros processadas.
			
Cursores Explícitos: 
		Cursores definidos pelo usuário para manipular registros recuperados por declarações SELECT.


Atributos de Cursores Implícitos:

%rowcount: Mostra o número de linhas do cursores

%found: Retorna TRUE se o mais recente FETCH retornar uma linha

%notfound: Retorna TRUE se o mais recente FETCH não retornar um linha

%isopen: Retorna TRUE se o cursor estiver aberto

		
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	  
66.Cursores Parte 1

SET SERVEROUTPUT ON
DECLARE
-- Declaração de variáveis
viDFunc  HR.EMPLOYEES.EMPLOYEE_ID%type;
vNome    HR.EMPLOYEES.FIRST_NAME%type;
VSalario HR.EMPLOYEES.SALARY%type;

-- Declaração de cursores
CURSOR cs_salario_top_10 is

    SELECT a.EMPLOYEE_ID, a.FIRST_NAME, a.SALARY FROM HR.EMPLOYEES a ORDER BY a.salary DESC;

BEGIN
    -- Abre cursor
    OPEN cs_salario_top_10;
        -- Executa um loop com 10 ciclos
        FOR i IN 1..10 LOOP
        -- Extrai dados o registro corrente do cursor e avança para o próximo
        FETCH cs_salario_top_10 INTO viDFunc, vNome, VSalario;
        -- Imprime dados extraídos na tela
        dbms_output.put_line(viDFunc||' - '||vNome||' - '||VSalario);
        END LOOP;
        --fecha cursor
    CLOSE cs_salario_top_10;
END;
/
				
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 				
67.Cursores Parte 2
SET SERVEROUTPUT ON
DECLARE
-- Declaração de variáveis
viDFunc HR.EMPLOYEES.EMPLOYEE_ID%type;
vNome HR.EMPLOYEES.FIRST_NAME%type;
VSalario HR.EMPLOYEES.SALARY%type;

-- Declaração de cursores
CURSOR cs_top_10 is

 SELECT a.EMPLOYEE_ID, a.FIRST_NAME, a.SALARY FROM HR.EMPLOYEES a ORDER BY a.salary DESC;
 
BEGIN
-- Abre cursor se ainda não estiver aberto
    IF NOT cs_top_10%ISOPEN THEN
        OPEN cs_top_10;
    END IF;
    -- Executa um loop com 10 ciclos
        FOR i IN 1..10 LOOP
        -- Extrai dados o registro corrente do cursor e avança para o próximo
        FETCH cs_top_10 INTO  viDFunc, vNome, VSalario;
        -- Imprime dados extraídos na tela
        dbms_output.put_line(i||'-'||viDFunc||' - '||vNome||' - '||VSalario);
        END LOOP;
    -- Fechar cursor
    CLOSE cs_top_10;
END;
/
	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
68.Cursores Parte 3

SET SERVEROUTPUT ON
DECLARE
-- Declaração de variáveis
viDFunc HR.EMPLOYEES.EMPLOYEE_ID%type;
vNome HR.EMPLOYEES.FIRST_NAME%type;
VSalario HR.EMPLOYEES.SALARY%type;
v_posicao int default 0;

-- Declaração de cursores
CURSOR cs_salario is
 SELECT a.EMPLOYEE_ID, a.FIRST_NAME, a.SALARY FROM HR.EMPLOYEES a ORDER BY a.salary DESC;

BEGIN
-- Abre cursor se ainda não estiver aberto
IF NOT cs_salario%ISOPEN THEN
    OPEN cs_salario;
    END IF;
    -- Executa um loop 
        LOOP
        -- Extrai dados o registro corrente do cursor e avança para o próximo
        FETCH cs_salario INTO  viDFunc, vNome, VSalario;
        
        -- Sai do Loop quando não houver mais registros para processar
        EXIT WHEN cs_salario%NOTFOUND;
        -- Imprime dados extraídos na tela
        v_posicao:= v_posicao +1;
        dbms_output.put_line(v_posicao||' - '||viDFunc||' - '||vNome||' - '||VSalario);
        END LOOP;
    -- Fechar cursor
    CLOSE cs_salario;
END;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
69.Cursores Parte 4

SET SERVEROUTPUT ON
DECLARE
-- Declaração de tipo registro
TYPE TFuncionario IS RECORD(viDFunc HR.EMPLOYEES.EMPLOYEE_ID%type,
                            vNome HR.EMPLOYEES.FIRST_NAME%type,
                            VSalario HR.EMPLOYEES.SALARY%type);
-- Declaração de variáveis
VFunc TFuncionario;

-- Declaração de cursores
CURSOR cs_func is
 SELECT a.EMPLOYEE_ID,a.FIRST_NAME,a.SALARY FROM HR.EMPLOYEES a ORDER BY a.salary DESC;

BEGIN
-- Abre cursor se ainda não estiver aberto
IF NOT cs_func%ISOPEN THEN
    OPEN cs_func;
END IF;
    -- Executa um loop 
        LOOP
        -- Extrai dados o registro corrente do cursor e avança para o próximo
        FETCH cs_func INTO VFunc;
        -- Sai do Loop quando não houver mais registros para processar
        EXIT WHEN cs_func%NOTFOUND;
        -- Imprime dados extraídos na tela
        dbms_output.put_line(VFunc.viDFunc||' - '||VFunc.vNome||' - '||VFunc.VSalario);
        END LOOP;
    -- Fechar cursor
    CLOSE cs_func;
END;
/

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
70.Cursores Parte 5

--CURSOR IMPLICITO ORACLE
--NAO DECLARA O CURSOR E NEM A VARIAVEL...
BEGIN
    -- Inicia o loop no conjunto ativo do cursor
    FOR vFunc in (SELECT a.EMPLOYEE_ID,a.FIRST_NAME,a.SALARY FROM HR.EMPLOYEES a ORDER BY a.salary DESC)
        LOOP
        -- Imprime dados extraídos na tela
        dbms_output.put_line(VFunc.EMPLOYEE_ID||' - '||VFunc.FIRST_NAME||' - '||VFunc.SALARY);
        END LOOP;
END;
/
	

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 	
71.Cursores Parte 6

DECLARE
-- Declaração de cursores
CURSOR cs_func(pMenor NUMBER, 
               pMaior NUMBER) is
               
SELECT a.EMPLOYEE_ID, a.FIRST_NAME, a.SALARY FROM HR.EMPLOYEES a
    WHERE a.SALARY BETWEEN pMenor AND pMaior ORDER BY a.SALARY DESC ;

BEGIN
-- Abre cursor para Funcionarios com Salario entre 1000 e 9999
    dbms_output.put_line('Funcionarios com média entre 1000 e 9999');
    DBMS_OUTPUT.NEW_LINE;
    
    FOR rFunc in cs_func(1000,9999) LOOP
    /* Imprime na tela os Funcionarios com Salario no intervalo de 1000 e 9999
    */
    dbms_output.put_line(rFunc.EMPLOYEE_ID||' - '||rFunc.FIRST_NAME||' - '||rFunc.SALARY);
    END LOOP;
    DBMS_OUTPUT.NEW_LINE;
    
    -- Abre cursor para Funcionarios com Salario entre 10000 e 19000
    dbms_output.put_line('Funcionarios com média entre 10000 e 19000');
    DBMS_OUTPUT.NEW_LINE;
    FOR rFunc in cs_func(10000,19000) LOOP
    /* Imprime na tela os Funcionarios com Salario entre 10000 e 19000
    Está no intervalo de 10000 e 19000
    */
    dbms_output.put_line(rFunc.EMPLOYEE_ID||' - '||rFunc.FIRST_NAME||' - '||rFunc.SALARY);
    END LOOP;

END;
/
-------------------------------------------------------------------------------------------------------------------------------------------------------------

DECLARE
-- Declaração de cursores
CURSOR cs_func(pMenor NUMBER, 
               pMaior NUMBER) is
               
SELECT a.EMPLOYEE_ID,a.FIRST_NAME,a.SALARY FROM HR.EMPLOYEES a
    WHERE a.SALARY BETWEEN pMenor AND pMaior order by a.SALARY desc ;

BEGIN
-- Abre cursor para Funcionarios com Salario entre 1000 e 9999
dbms_output.put_line('Funcionarios com média entre 1000 e 9999');
DBMS_OUTPUT.NEW_LINE;
FOR rFunc in cs_func(10000,9999) LOOP
/* Imprime na tela os Funcionarios com Salario no intervalo de 1000 e 9999
*/
    dbms_output.put_line(rFunc.EMPLOYEE_ID||' - '||rFunc.FIRST_NAME||' - '||rFunc.SALARY);
    END LOOP;
    DBMS_OUTPUT.NEW_LINE;
    
    -- Abre cursor para Funcionarios com Salario entre 10000 e 19000
    dbms_output.put_line('Funcionarios com média entre 10000 e 19000');
    DBMS_OUTPUT.NEW_LINE;
    FOR rFunc in cs_func(10000,19000) LOOP
    /* Imprime na tela os Funcionarios com Salario entre 10000 e 19000
    Está no intervalo de 10000 e 19000
    */
    dbms_output.put_line(rFunc.EMPLOYEE_ID||' - '||rFunc.FIRST_NAME||' - '||rFunc.SALARY);
    END LOOP;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('NÃO TEM REGISTROS');
     WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
END;
/	
	
	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
SECAO 10:FUNÇÕES
72.Introdução

Uma FUNCTION é um bloco PL/SQL muito semelhante a uma procedure. O que podemos entender de início entre esses dois tipos de blocos é q os blocos "function
retornam valores" e as procedures podem ou não retornar um valor. As functions tem duas características q diferem das procedures, as quais não podemos 
deixar de tratar.

*** AS FUNCTIONS SEMPRE RETORNAM VALORES!!!
*** FUNCTIONS SÃO USADAS COMO PARTE DE UMA EXPRESSÃO.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
73.Funções Parte 1

--criando funçao para media ponderada;

CREATE OR REPLACE FUNCTION Fn_mediaPond
                    (nota1 in number,
                     peso1 in number,
                     nota2 in number,
                     peso2 in number)
return number
is
media_pond number;
begin
        media_pond:=(nota1*peso1+nota2*peso2)/(peso1+peso2);
        return media_pond;
end;
/

-- retornance valor de função
select  Fn_mediaPond(10,1,10,1) from SYS.DUAL;

-- REtornando atraves de output]
SET SERVEROUTPUT ON
BEGIN
dbms_output.put_line(Fn_mediaPond(5,5,10,1)); 
END;
/


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
74.Funções Parte 2

-- sem paramentros
-- sem paramentros
CREATE OR REPLACE FUNCTION FnNome
   RETURN varchar IS
   v_nome varchar(20);
   
    BEGIN
       SELECT a.FIRST_NAME
       INTO   v_nome
       FROM   hr.EMPLOYEES a WHERE a.EMPLOYEE_ID = 100;
     RETURN v_nome;
    END;
/
select FnNome from DUAL;
SELECT FnNome FROM SYS.dual;

BEGIN
   DBMS_OUTPUT.PUT_LINE(FnNome);
END;
/




--com paramentros

CREATE OR REPLACE FUNCTION FnNome2(p_id in number)
   RETURN varchar IS
   v_nome varchar(20);
   
BEGIN
   SELECT a.FIRST_NAME
   INTO   v_nome
   FROM   hr.EMPLOYEES a WHERE a.EMPLOYEE_ID = p_id;

   RETURN v_nome;
END;
/

select FnNome2(103) from DUAL;

BEGIN
    DBMS_OUTPUT.PUT_LINE(FnNome2(103));
END;


--function simula aumento

CREATE OR REPLACE FUNCTION FnAumento(p_pct in number,
                                     p_id_func in number)-- PODE RECEBER VARIOS PARAMETROS, POREM, SO RETORNARÁ UM...
   RETURN number IS  -- VALOR DO NOVO SALARIO...
   v_Sal_novo number(20);
   
BEGIN
   SELECT ((a.SALARY/100)* p_pct)+ a.SALARY
   INTO   v_Sal_novo
   FROM   hr.EMPLOYEES a where a.EMPLOYEE_ID = p_id_func;

   RETURN v_Sal_novo;
   
END;
/

--EXEC DA FUNÇÃO.
select a.FIRST_NAME,
       a.SALARY as sal_antigo, 
       FnAumento(10,a.EMPLOYEE_ID) as sal_novo
from  hr.EMPLOYEES a;


SELECT * FROM 	hr.EMPLOYEES WHERE EMPLOYEE_ID = 102;
    
select FnAumento(10,102) as sal_novo from DUAL;    

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
75. Funcções Parte 3
--Essa procedure na será como um processo armazenado, e sim como um bloco anônimo...
-- funcão como  bloco anônimo concluído
--PEGAR DOIS NUMEROS A DIZER QUAL É O MAIOR
SET serveroutput ON;
 
DECLARE
  PNUM1 NUMBER;
  PNUM2 NUMBER;
  PNUM_AUX NUMBER;
 
  FUNCTION FN_MAX_VAL(PNUM1 IN NUMBER,
					  PNUM2 IN NUMBER)
    RETURN NUMBER
  AS
    PNUM_AUX NUMBER;
  BEGIN
    IF PNUM1 > PNUM2 THEN
      PNUM_AUX := PNUM1;
    ELSE
      PNUM_AUX:= PNUM2;
    END IF;
    RETURN PNUM_AUX;
  END;
  
  BEGIN
    PNUM1 := 122;
    PNUM2 := 99;
    PNUM_AUX := FN_MAX_VAL (PNUM1, PNUM2);
    dbms_output.put_line('O maior valor entre ' || PNUM1 ||' e ' || PNUM2 || ' é =>> ' || PNUM_AUX);  
END;
  / 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------   
76.Funções Parte 4

--1) Cria tabelas 
create table notas (id_aluno int,
                    nota1 number,
                    peso1 number,
                    nota2 number,
                    peso2 number,
                    media number);
 
 --2 inserindo dados
 insert into notas (id_aluno,nota1,peso1,nota2,peso2) values (1,8,4,6,6);
 insert into notas (id_aluno,nota1,peso1,nota2,peso2) values (2,10,4,10,6);
 insert into notas (id_aluno,nota1,peso1,nota2,peso2) values (3,5,4,5,6);
 
 --select
 select * from notas;
 --atualiza
 UPDATE notas SET media = FN_MEDIAPOND (nota1, peso1, nota2, peso2) -- chamou a funcao FN_MEDIAPOND
 where 1=1;
 
 --verifica

 select * from notas;

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
77.Funções Parte 5


-- criando funcao para retornar numero de salarios minimos

CREATE OR REPLACE FUNCTION FN_SAL_MIN (P_SALARIO IN NUMBER)
RETURN NUMBER
    IS
QTD_SAL_MIN NUMBER(10,2); -- 2 casas decimais

BEGIN 
    QTD_SAL_MIN :=P_SALARIO/954;
RETURN QTD_SAL_MIN;
END;
/
-- USANDO A FUNCAO,

SELECT A.FIRST_NAME,
       A.SALARY,
       FN_SAL_MIN(A.SALARY) AS QTD_MIN
FROM HR.EMPLOYEES A;


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
78.Função Parte 6

CREATE OR REPLACE FUNCTION FUN_CALCULO(PAR1 IN NUMBER, 
                                       PAR2 IN NUMBER, 
                                       RES OUT NUMBER)

    RETURN NUMBER
    IS
    AUX NUMBER :=0;
    
    BEGIN
    RES := PAR1 + PAR2;
    AUX := RES + 100;
    RETURN(AUX);
    EXCEPTION
        WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Erro: '||SQLERRM);
    END;

--testando 
SET SERVEROUTPUT ON;
DECLARE
res0 NUMBER := 0; -- Apenas zerando essa variavel
res1 NUMBER := 0; -- Apenas zerando essa variavel

BEGIN
    res0 := fun_calculo(6, 14, res1);
    dbms_output.put_line('O resultado é: '||res0||' e '||res1); -- res1, saida do output...
END;

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
SECAO 11: PROCEDURES
79.Introdução

Uma store procedure é um bloco de uma instrução PL/SLQ que executa uma ou mais tarefas específicas. São bem similares com as procedures de outras linguagens
de programação. Uma PROC pode ou não retornar valores, normalmente as procedures são criadas dentro de pacotes ou em blocos PL/SQL.
Podemos passar parâmetros para uma procedure de três maneiras.

IN: Passamos o valor na própria procedure.
OUT: Recebemos o valor a partir da chamada de blocos externos.
IN OUT: Passamos um valor inicial para a procedure e recebemos de volta uma atualização.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
80.Procedures Parte 1

-- PROCEDURE SEM PARAMETRO DE ENTRADA
CREATE OR REPLACE
PROCEDURE PROC_DET_FUNC
IS
  CURSOR emp_cur
  IS
    SELECT first_name, last_name, salary FROM HR.EMPLOYEES WHERE ROWNUM <=5;
    
    emp_rec emp_cur%rowtype; --RECEBENDO VALORES DO CURSOR
BEGIN
  FOR emp_rec IN emp_cur  -- Leia as variaveis do cursor: emp_cur...
  LOOP
    dbms_output.put_line('Nome do funcionario: ' || emp_rec.first_name);
    dbms_output.put_line('Sobrenome do funcionario: ' ||emp_rec.last_name);
    dbms_output.put_line('Salário do funcionario: ' ||emp_rec.salary);
    dbms_output.put_line('---------------------------------------------');
  END LOOP;
END;

--executando procedure
SET serveroutput on
begin
 PROC_DET_FUNC;
end;

--outra forma de execucao
EXECUTE PROC_DET_FUNC;

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
81.Procedure Parte 2


-- criando uma procedure para retornar informações

CREATE OR REPLACE PROCEDURE PROC_INF_DEPTO
IS
  CURSOR FUN_CURSOR
  IS
    SELECT a.DEPARTMENT_ID,b.DEPARTMENT_NAME,SUM(salary)SALARIO FROM HR.EMPLOYEES a
    inner join HR.DEPARTMENTS b 
        on a.department_id = b.department_id
    group by a.DEPARTMENT_ID, b.DEPARTMENT_NAME;
    
    FUN_REC FUN_CURSOR%rowtype;
BEGIN
  FOR FUN_REC IN FUN_CURSOR
  LOOP
    dbms_output.put_line('Codigo Depto: ' || FUN_REC.DEPARTMENT_ID || 
     '. Nome Depto: ' ||FUN_REC.DEPARTMENT_NAME || '. Total Salário do Depto: ' ||FUN_REC.salario);
  END LOOP;
  exception
  when others then
  dbms_output.put_line('Erro: '||sqlerrm);
END;
/

--EXECUTANDO
EXECUTE PROC_INF_DEPTO;

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
82.Procedure Parte 3

--PROCEDURE CALCULADORA
CREATE OR replace PROCEDURE proc_calc(operacao IN VARCHAR, --A ADICAO --D DIVISAO --S -SUBTR M --MULTIPL
                                      pnum1    IN NUMBER, 
                                      pnum2    IN NUMBER, 
                                      retorno OUT NUMBER) 

IS 
MSG_OUTRAS EXCEPTION;
BEGIN 

 IF operacao = 'A' THEN 
    retorno := pnum1 + pnum2; 
  ELSIF operacao = 'S' THEN 
    retorno := pnum1 - pnum2; 
  ELSIF operacao = 'M' THEN 
    retorno := pnum1 * pnum2; 
  ELSIF operacao = 'D' THEN 
    retorno := pnum1/pnum2; 
    else
    raise MSG_OUTRAS;
END IF; 
  EXCEPTION 
  WHEN MSG_OUTRAS THEN 
    dbms_output.put_line('Erro nao catalogado'); 
 
  WHEN OTHERS THEN 
    dbms_output.put_line('erro: '||SQLERRM); 
  END;
  /
  
  --EXECUTANDO PROCEDURE
  DECLARE
  retorno number:=0; -- Quando tem retorno e obrigatorio declarar...
  BEGIN
    proc_calc ('M',10,3,retorno);
    dbms_output.put_line(retorno);
  END;
  
 
  
  /
  
  
--OUTRO EXEMPLO

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
83.Procedure Parte 4

-- criando tabela para popular com procedure
--DROP TABLE EMPLOYEES_COPIA;
  CREATE TABLE EMPLOYEES_COPIA 
   (EMPLOYEE_ID NUMBER(6,0) PRIMARY KEY, 
	FIRST_NAME VARCHAR2(20 BYTE), 
	LAST_NAME VARCHAR2(25 BYTE), 
	EMAIL VARCHAR2(25 BYTE), 
	PHONE_NUMBER VARCHAR2(20 BYTE), 
	HIRE_DATE DATE, 
	JOB_ID VARCHAR2(10 BYTE), 
	SALARY NUMBER(8,2), 
	COMMISSION_PCT NUMBER(2,2), 
	MANAGER_ID NUMBER(6,0), 
	DEPARTMENT_ID NUMBER(4,0)
   );
   
-- VERIFICANDO TABELA CRIADA
SELECT * FROM EMPLOYEES_COPIA
 
-- criando procedure

CREATE OR REPLACE PROCEDURE PROC_COPIA_FUNC

is

BEGIN
        For func in (SELECT * FROM HR.EMPLOYEES)
      LOOP
        insert into EMPLOYEES_COPIA (EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID) 
                                values
                                    (func.EMPLOYEE_ID,func.FIRST_NAME,func.LAST_NAME,func.EMAIL,func.PHONE_NUMBER,func.HIRE_DATE,func.JOB_ID,func.SALARY,func.COMMISSION_PCT,func.MANAGER_ID,func.DEPARTMENT_ID);
      END LOOP;
      
     dbms_output.put_line('OK CARGA REALIZADA'); 
     COMMIT;
     
     exception
      when others then
        dbms_output.put_line('ERRO: '||sqlerrm);
        ROllBACK;
    
END PROC_COPIA_FUNC;

-- EXECUTANDO PROCEDURE
EXECUTE PROC_COPIA_FUNC;

--Verificando dados;
   
-- VERIFICANDO TABELA CRIADA
SELECT * FROM EMPLOYEES_COPIA;
SELECT COUNT(*) FROM EMPLOYEES_COPIA;

-- EXECUTANDO PROCEDURE
EXECUTE PROC_COPIA_FUNC;

DROP TABLE EMPLOYEES_COPIA;
DROP PROCEDURE PROC_COPIA_FUNC;
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
84.Procedure Parte 5


--DROP TABLE CAD_PESSOA;
CREATE TABLE CAD_PESSOA 
(
    ID_PESSOA INT NOT NULL PRIMARY KEY,
    NOME VARCHAR2(50),
    EMAIL VARCHAR(30),
    SITUACAO CHAR(1),
    CONSTRAINT CK_SITUA CHECK(SITUACAO IN('B','A')) -- B: Bloquedo A: Ativo... Esse campo so podera receber esse valor.
    );
--SELECT * FROM CAD_PESSOA;
--PROCEDURE DE CADASTRO
CREATE OR REPLACE PROCEDURE SP_CRUD (V_OPER       CHAR, --I INSERIR --A -ATUALIZA --S SELECIONA - D--DELETE
                                     V_ID_PESSOA  INTEGER,
                                     V_NOME       VARCHAR2,
                                     V_EMAIL      VARCHAR2,
                                     V_SITUACAO   CHAR)
IS
-- Se o usuario escolher S, eu vou precisar dessas variaveis para atribuir valor quando selecionado essa opção.
 --declarando variaveis
  V_SID_PESSOA INTEGER;
  V_SNOME VARCHAR2(50);
  V_SEMAIL VARCHAR2(30);
  V_SSITUACAO CHAR(1);
  
--declarando except
  v_EXCEPTION EXCEPTION;
  v_FALTA_CPO_INSERT EXCEPTION;
  v_FALTA_ID_DELETE EXCEPTION;
  v_FALTA_ID_UPDATE EXCEPTION;
BEGIN   
--verifica operacao de insert
  IF (V_OPER = 'I') THEN
    IF (V_ID_PESSOA is null or V_ID_PESSOA = '' or V_NOME is null OR V_NOME = '' or  V_EMAIL is null or V_EMAIL = '')
        then 
            ROLLBACK;
            RAISE v_FALTA_CPO_INSERT; -- Raise chama o erro!!!
        else
        INSERT INTO CAD_PESSOA(ID_PESSOA, NOME,EMAIL, SITUACAO) VALUES (v_id_pessoa, v_NOME, v_email,'A');
    END IF;
    
--verifica operacao de atualização
  ELSIF (V_OPER = 'A') THEN
     
     IF (V_ID_PESSOA is null or   V_ID_PESSOA = '') -- Obs: Null é <> de vazio!!!
     THEN
        ROLLBACK;
        RAISE v_FALTA_ID_UPDATE;
        ELSE
            UPDATE CAD_PESSOA SET NOME = NVL(V_NOME,NOME), EMAIL = NVL(V_EMAIL,EMAIL), SITUACAO = NVL(V_SITUACAO,SITUACAO)--Se tem valor na variavel, será atualizado, se não permanecerá o valor original do campo...
           WHERE ID_PESSOA = V_ID_PESSOA;
      END IF;  
      
  --verifica operacao de delete
  ELSIF(V_OPER = 'D')THEN
  
     IF (V_ID_PESSOA is null or V_ID_PESSOA = '') 
       THEN
        ROLLBACK;
        RAISE v_FALTA_ID_DELETE;
        ELSE
            DELETE FROM CAD_PESSOA WHERE ID_PESSOA = V_ID_PESSOA;
     END IF;
     
 --verifica operacao de select
   ELSIF(V_OPER = 'S')THEN
   
    SELECT * 
    INTO  V_SID_PESSOA, V_SNOME, V_SEMAIL, V_SSITUACAO 
    FROM CAD_PESSOA WHERE ID_PESSOA = V_ID_PESSOA;
    
     dbms_output.put_line('ID: '||V_SID_PESSOA); 
     dbms_output.put_line('Nome: '||V_SNOME); 
     dbms_output.put_line('e-mail: '||V_SEMAIL); 
     dbms_output.put_line('Situacao: '||V_SSITUACAO); 
    ELSE -- SE NAO FOI NADA DISSO CHAMA O ERRO
    RAISE v_EXCEPTION; -- Chama o exception..
  END IF;
    
 COMMIT;
    dbms_output.put_line('DADOS SELECIONADOS,INSERIDOS OU ATUALIZADO COM SUCESSO'); 
 --execpt   
  EXCEPTION
   
    WHEN v_EXCEPTION THEN 
      RAISE_APPLICATION_ERROR(-20999,'ATENÇÃO! Operação diferente de I, D, A OU S', FALSE);
    
    WHEN v_FALTA_CPO_INSERT THEN    
      dbms_output.put_line('FALHA NO INSERT, CAMPOS NAO PREENCHIDOS CORRETAMENTE!'); 
    
    WHEN v_FALTA_ID_UPDATE THEN  
      dbms_output.put_line('FALHA NO UPDATE, INFORME O ID!'); 
   
    WHEN v_FALTA_ID_DELETE THEN   
      dbms_output.put_line('FALHA NO DELETE, INFORME O ID!'); 
     
     WHEN OTHERS THEN
        IF SQLCODE = '-00001' THEN -- SQLCODE: PARA TRABALHAR COM OS ERROS MEPEADOS PELA ORACLE
             DBMS_OUTPUT.PUT_LINE('ERRO: CODIGO JA EXISTE! '); -- -00001 ESSE COD SIGNIFICA Q ELE ESTA DESEJANDO VIOLAR UMA PK, COD MAPEADO PELA ORACLE
             DBMS_OUTPUT.PUT_LINE('ERRO: '||SQLERRM); -- MESMO ASSIM ESTOU INFORMANDO O ERRO DO ORACLE.
        ELSE
            DBMS_OUTPUT.PUT_LINE('CODIGO: '||SQLCODE);
            DBMS_OUTPUT.PUT_LINE('ERRO: '||SQLERRM);
            RAISE;
        END IF;
    ROLLBACK;
      
END ;
/
----I INSERIR --A -ATUALIZA --S SELECIONA - D--DELETE
--EXECUTANDO 
--REALIZANDO INSERT PARAM V_OPER,V_ID_PESSOA,V_NOME,V_EMAIL,V_SITUACAO

SET SERVEROUTPUT ON
DECLARE
    P_OPER CHAR(1);
    P_ID INT;
    P_NOME VARCHAR2(50);
    P_EMAIL VARCHAR2(30);
    P_SIT CHAR(1);
    
    BEGIN
      P_OPER  := 'S';
      P_ID    := 1;
      P_NOME  := 'JEFF';
      P_EMAIL := 'NULL'; --OBS: SE EU COMENTAR ESSA LINHA, NÃO VAI SETAR NULL, VAI MANTER O DADO ATUAL DO CAMPO...
      P_SIT   := 'B';
    
        SP_CRUD(P_OPER,P_ID,P_NOME,P_EMAIL,P_SIT);
    END;
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
85.Procedure Estoque Parte 1

-- criando tabelas para procedure atualiza estoque

CREATE TABLE MATERIAL (COD_MAT INT PRIMARY KEY,
                       DESCRICAO VARCHAR2(50) NOT NULL,
                       PRECO_UNIT NUMBER(10,2)
                       );

 CREATE SEQUENCE  SEQ_COD_MAT
	INCREMENT BY 1
	START WITH 1
	ORDER
	CACHE 10;
 
CREATE TABLE ESTOQUE (COD_MAT INT  PRIMARY KEY NOT NULL, 
                      SALDO   DECIMAL (10, 2) NULL 
                      );
  

CREATE TABLE ESTOQUE_LOTE (COD_MAT INT NOT NULL,
                           LOTE    VARCHAR (15) NOT NULL, 
                           SALDO   DECIMAL (10, 2) NULL, 
                           FOREIGN KEY (COD_MAT) REFERENCES MATERIAL(COD_MAT), 
                           PRIMARY KEY (COD_MAT, LOTE) 
                           );

CREATE TABLE mov_estoque (transacao  INT PRIMARY KEY NOT NULL,
                          mov VARCHAR2 (1) NOT NULL, 
                          cod_mat    INT NOT NULL, 
                          lote       VARCHAR (15) NOT NULL, 
                          qtd        INT NOT NULL, 
                          usuario    VARCHAR2 (30) NOT NULL, 
                          dt_hor_mov DATE NOT NULL 
                          );
  
    CREATE SEQUENCE  seq_mov_estoque
	INCREMENT BY 1
	START WITH 1
	ORDER
	CACHE 10;



ALTER TABLE estoque 
  ADD FOREIGN KEY (cod_mat) REFERENCES material(cod_mat); 


ALTER TABLE mov_estoque 
  ADD FOREIGN KEY (cod_mat) REFERENCES material(cod_mat); 
  
 --inserindo dados 
  INSERT INTO material   (cod_mat,descricao,preco_unit) VALUES
        (seq_cod_mat.NEXTVAL,'SMART TV 40',2200.99);
  INSERT INTO material   (cod_mat,descricao,preco_unit) VALUES
        (seq_cod_mat.NEXTVAL,'SMARTPHONE',1990.99);
  INSERT INTO material   (cod_mat,descricao,preco_unit) VALUES
        (seq_cod_mat.NEXTVAL,'HOME THEATER',999.99);  
        


SELECT * FROM MATERIAL;
--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- CRIANDO PROCEDURE PARA ALIMENTAR ESTOQUE
--REGRAS
/*
VERIFICAR SE A OPERACAO E PERMITIDA (-E ENTRADA E S SAIDA
VERIFICAR SE O MATERIAL EXISTE

-- VERIFICOES DE SAIDA
1 VERIFICAR SE MATERIAL TEM SALDO ESTOQUE E E QTD SAIDA E MENOR QUE SALDO
2 VERIFICAR SE MATERIAL TEM SALDO ESTOQUE_LOTE E E QTD SAIDA E MENOR QUE SALDO DO LOTE

-- VERIFICACOES ENTRADA
1 SE MATERIAL EXISTE UPDATE
2 SENAO EXISTE INSERT

TABELAS ENVOLVIDAS
ESTOQUE
ESTOQUE_LOTE
ESTQUE_MOV
-- EXECOES ROLLBACK


*/
CREATE OR REPLACE PROCEDURE PRC_MOV_ESTOQUE (P_OPER IN VARCHAR2,
                                             P_COD_MAT IN INT,
                                             P_LOTE IN VARCHAR2,
                                             P_QTD IN INT)
IS
V_SALDO_ESTOQUE INT;
V_SALDO_ESTOQUE_LOTE INT;
V_MAT_EXISTE INT ;
V_REG_ESTOQUE INT;
V_REG_ESTOQUE_LOTE INT;

EXC_MAT_N_EXISTE EXCEPTION;
EXC_OPERACAO_NAO_PERMITIDA EXCEPTION;
EXC_ESTOQUE_NEGATIVO EXCEPTION;
EXC_ESTOQUE_NEGATIVO_LOTE EXCEPTION;

BEGIN 
    -- VERIFICANDO SE OPERACAO É PERMITIDA;
    IF P_OPER NOT IN ('E','S') THEN
    RAISE EXC_OPERACAO_NAO_PERMITIDA;
    ELSE 
    dbms_output.put_line('OPERACAO OK! CONTINUA!');
    END IF;
    
    -- VERIFICANDO SE MATERIAL EXISTE
    SELECT COUNT(*) INTO V_MAT_EXISTE FROM MATERIAL WHERE COD_MAT = P_COD_MAT;
    IF V_MAT_EXISTE = 0 THEN
    RAISE EXC_MAT_N_EXISTE;
    ELSE
        dbms_output.put_line('MATERIAL EXISTE! CONTINUA');
    END IF;
  
  --VERIFICANDO SE EXISTE REGISTRO EM ESTOQUE
  SELECT COUNT(*) INTO V_REG_ESTOQUE 
  FROM ESTOQUE 
  WHERE COD_MAT = P_COD_MAT;
   dbms_output.put_line('QTD REG ESTOQUE '||V_REG_ESTOQUE);
   
  -- VERIFICANDO OPERACAO DE SAIDA SE MATERIAL EXISTE NAO ESTOQUE
  IF P_OPER = 'S' AND V_REG_ESTOQUE = 0 
  THEN
      RAISE EXC_ESTOQUE_NEGATIVO;
      ELSIF  P_OPER = 'S' AND V_REG_ESTOQUE > 0  THEN
       -- ATRIBUINDO SALDO DE ESTOQUE E QTD REGISTRO
        SELECT SALDO, COUNT(*) INTO V_SALDO_ESTOQUE, V_REG_ESTOQUE -- QUARDANDO O SALDO NESSAS DUAS VARIAVEIS
        FROM ESTOQUE 
        WHERE COD_MAT = P_COD_MAT 
        GROUP BY SALDO;
        dbms_output.put_line('TEM ESTOQUE');
  END IF;
  
  --VERIFICANDO SE EXISTE REGISTRO EM ESTOQUE LOTE
  SELECT COUNT(*) INTO V_REG_ESTOQUE_LOTE 
  FROM ESTOQUE_LOTE 
  WHERE COD_MAT = P_COD_MAT AND LOTE = P_LOTE;
  dbms_output.put_line('QTD REG ESTOQUE LOTE '||V_REG_ESTOQUE_LOTE);
  
  -- VERIFICANDO OPERACAO DE SAIDA SE MATERIAL EXISTE NAO ESTOQUE
  IF P_OPER = 'S' AND V_REG_ESTOQUE_LOTE = 0 
  THEN
      RAISE EXC_ESTOQUE_NEGATIVO_LOTE;
      ELSIF P_OPER = 'S' AND V_REG_ESTOQUE_LOTE > 0 THEN
      -- ATRIBUINDO SALDO DE ESTOQUE_LOTE E QTD REGISTRO
        SELECT SUM(SALDO) ,COUNT(*) INTO V_SALDO_ESTOQUE_LOTE, V_REG_ESTOQUE_LOTE FROM ESTOQUE_LOTE 
        WHERE COD_MAT = P_COD_MAT AND LOTE = P_LOTE;
        dbms_output.put_line('TEM ESTOQUE LOTE');
  END IF;
  
  -- VERIFICANDO ANTES DE FAZER A OPERACAO SE O ESTOQUE VAI FICAR NEGATIVO, SE FICAR JA CAI NO EXCEPTION...
  IF P_OPER = 'S' AND  (V_SALDO_ESTOQUE_LOTE - P_QTD < 0 OR V_SALDO_ESTOQUE - P_QTD < 0) THEN
     RAISE EXC_ESTOQUE_NEGATIVO_LOTE;
    ELSIF P_OPER = 'S' AND  V_SALDO_ESTOQUE_LOTE - P_QTD >= 0 AND V_SALDO_ESTOQUE - P_QTD >= 0 THEN
    -- ATUALIZA ESTOQUE
    UPDATE ESTOQUE SET SALDO = SALDO - P_QTD WHERE COD_MAT = P_COD_MAT;
    
    -- ATUALIZA ESTOQUE LOTE
    UPDATE ESTOQUE_LOTE SET SALDO = SALDO - P_QTD WHERE COD_MAT = P_COD_MAT AND LOTE = P_LOTE;
    
    -- INSERE ESTOQUE MOV: TABELA DE AUDITORIA
    INSERT INTO MOV_ESTOQUE (transacao, mov, cod_mat, lote,qtd, usuario, dt_hor_mov) VALUES
        (seq_mov_estoque.NEXTVAL, P_OPER, P_COD_MAT, P_LOTE, P_QTD, USER, SYSDATE);
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('OPERACAO FINALIZADA');
    END IF;
    
    -- FINALIZA OPERACAO PARA SAIDA
    --INICIA OPERACAO PARA ENTRADA
    
    --VERIFCANDO SE MATERIAL TEM REGISTRO NA ESTOQUE E ESTOQUE LOTE
    IF P_OPER = 'E' AND V_REG_ESTOQUE_LOTE > 0 AND V_REG_ESTOQUE > 0 THEN
    
        -- ATUALIZANDO ESTOQUE
         UPDATE ESTOQUE SET SALDO = SALDO + P_QTD WHERE COD_MAT = P_COD_MAT;
         
          -- ATUALIZANDO ESTOQUE_LOTE
         UPDATE ESTOQUE_LOTE SET SALDO = SALDO + P_QTD WHERE COD_MAT = P_COD_MAT AND LOTE = P_LOTE;
         
         -- INSERE ESTOQUE MOV -- ESSA TAB NUNCA E ATUALIZADA, APENAS RECEBE REGISTROS...
         INSERT INTO MOV_ESTOQUE (transacao, mov, cod_mat, lote, qtd, usuario, dt_hor_mov) VALUES
                                 (seq_mov_estoque.NEXTVAL, P_OPER, P_COD_MAT, P_LOTE, P_QTD, USER, SYSDATE);
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('OPERACAO FINALIZADA');
        
        -- VERIFICA QUE EXISTE ESTOQUE MAS NAO EXISTE ESTOQUE LOTE PARA INSERT ESTOQUE LOTE E UPDATE ESTOQUE
    ELSIF P_OPER = 'E' AND V_REG_ESTOQUE_LOTE = 0 AND V_REG_ESTOQUE > 0 THEN
        -- ATUALIZANDO ESTOQUE
         UPDATE ESTOQUE SET SALDO = SALDO + P_QTD WHERE COD_MAT = P_COD_MAT;
         
        --INSERINDO REGISTRO NA ESTOQUE LOTE
         INSERT INTO ESTOQUE_LOTE (COD_MAT,SALDO,LOTE) VALUES 
                                  (P_COD_MAT,P_QTD,P_LOTE);
          -- INSERE ESTOQUE MOV
         INSERT INTO MOV_ESTOQUE (transacao,mov,cod_mat,lote,qtd,usuario,dt_hor_mov) VALUES
            (seq_mov_estoque.NEXTVAL,P_OPER,P_COD_MAT,P_LOTE,P_QTD,USER,SYSDATE);
         COMMIT;
        DBMS_OUTPUT.PUT_LINE('OPERACAO FINALIZADA');
        
        -- VERIFICANDO QUE NAO EXISTE ESTOQUE E ESTOQUE LOTE PARA INSERT
    ELSIF P_OPER = 'E' AND V_REG_ESTOQUE_LOTE = 0 AND V_REG_ESTOQUE = 0 THEN
            -- INSERINDO ESTOQUE
         INSERT INTO  ESTOQUE (COD_MAT,SALDO) VALUES (P_COD_MAT,P_QTD);
         
        --INSERINDO REGISTRO NA ESTOQUE LOTE
         INSERT INTO ESTOQUE_LOTE (COD_MAT,SALDO,LOTE) VALUES (P_COD_MAT,P_QTD,P_LOTE);
         
          -- INSERE ESTOQUE MOV
         INSERT INTO MOV_ESTOQUE (transacao,mov,cod_mat,lote,qtd,usuario,dt_hor_mov) VALUES
            (seq_mov_estoque.NEXTVAL,P_OPER,P_COD_MAT,P_LOTE,P_QTD,USER,SYSDATE);
         COMMIT;
        DBMS_OUTPUT.PUT_LINE('OPERACAO FINALIZADA');
    END IF;
    -- TERMINA ENTRADA
    
    --INICIA EXCESSOES
EXCEPTION
    when EXC_OPERACAO_NAO_PERMITIDA THEN
        DBMS_OUTPUT.PUT_LINE('A OPERACAO DEVER SER E-ENTRADA OU S-SAIDA');
        ROLLBACK;
     
     when EXC_MAT_N_EXISTE THEN
        DBMS_OUTPUT.PUT_LINE('MATERIAL NAO EXISTE CADASTRO');
        ROLLBACK;
     
    when EXC_ESTOQUE_NEGATIVO THEN
        DBMS_OUTPUT.PUT_LINE('ESTOQUE NEGATIVO,OPERACAO NAO PERMITIDA!!!');
        ROLLBACK;
     
    when EXC_ESTOQUE_NEGATIVO_LOTE THEN
        DBMS_OUTPUT.PUT_LINE('ESTOQUE LOTE NEGATIVO,OPERACAO NAO PERMITIDA!!!');
        ROLLBACK;
    
    when NO_DATA_FOUND THEN 
        DBMS_OUTPUT.PUT_LINE('REGISTRO NAO ENCONTRADO!');
        DBMS_OUTPUT.PUT_LINE('Linha: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);-- CASO ACONTECA ALGUMA COISA, INFORMA NA PROC QUAL LUGAR OCORREU O ERRP... ISSO AJUDA A IDENTIFICAR O ERRO.
        ROLLBACK;
         
     WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('CODIGO DO ERRO '||SQLCODE||' MSG '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Linha: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);-- ESSA LINHA E MAIS P/ O PROGRAMADOR IDENTIFICAR O ERRO.
        ROLLBACK;

end;

-- testando procedure
--PARAMETROS OPERACAO,MATERIAL,LOTE,QTD
execute PRC_MOV_ESTOQUE ('S',1,'ABC',10);


      
select * from ESTOQUE;
SELECT * FROM ESTOQUE_LOTE;
SELECT a.*,to_char(a.DT_HOR_MOV,'dd/mm/yyyy hh24:mi:ss') data 
FROM MOV_ESTOQUE a;
/*
DELETE from ESTOQUE;
DELETE FROM ESTOQUE_LOTE;
DELETE FROM MOV_ESTOQUE;
*/


select to_char(DT_HOR_MOV,'cc dd/mm/yyyy hh24:mi:ss') data from MOV_ESTOQUE;
select to_char(sysdate,'cc dd/mm/yyyy hh24:mi:ss') data from dual;

select to_char(sysdate,'cc dd/mm/yyyy hh24:mi:ss'),
       to_char(current_date,'cc dd/mm/yyyy hh24:mi:ss'),
       sysdate,
       current_date from dual;



------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
86.Procedure Estoque Parte 2


-- testando procedure
--PARAMETROS OPERACAO,MATERIAL,LOTE,QTD



P_OPER
P_COD_MAT 
P_LOTE 
P_QTD 


execute PRC_MOV_ESTOQUE ('X',1,'ABC',10); -- Testando exception, x nao e uma operação valida...
EXEC PRC_MOV_ESTOQUE ('S',1,'ABC',10); -- Operacao de saida nao sera permitido quando as tabelas estiver vazias...
EXEC PRC_MOV_ESTOQUE ('S',10,'ABC',10); -- Quando o material nao existe, erro!!! (10)

EXEC PRC_MOV_ESTOQUE ('E',2,'ZWR',5); -- Op. E...
EXEC PRC_MOV_ESTOQUE ('S',1,'ABC',10); -- Op. S...

      
select * from ESTOQUE;
SELECT * FROM ESTOQUE_LOTE;
SELECT * FROM MOV_ESTOQUE;
SELECT a.*, to_char(a.DT_HOR_MOV,'dd/mm/yyyy hh24:mi:ss') data 
FROM MOV_ESTOQUE a;
SELECT A.*, 
       TO_CHAR(A.DT_HOR_MOV,'DD/MM/YYYY HH24:MI:SS') AS DATA
FROM MOV_ESTOQUE A;       


/*
DELETE from ESTOQUE;
DELETE FROM ESTOQUE_LOTE;
DELETE FROM MOV_ESTOQUE;
*/


select to_char(DT_HOR_MOV,'cc dd/mm/yyyy hh24:mi:ss') data from MOV_ESTOQUE;
select to_char(sysdate,'cc dd/mm/yyyy hh24:mi:ss') data from dual;

select to_char(sysdate,'cc dd/mm/yyyy hh24:mi:ss'),
       to_char(current_date,'cc dd/mm/yyyy hh24:mi:ss'),
       sysdate,
       current_date from dual;


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
SECAO 12: TRIGGERS
87.Introdução

Tipos de Triggers.

Os triggers podem ser do tipo ROW LEVEL (Linha) ou STATEMENT (Tabela).
Além  disso, os Triggers podem ocorrer (BEFORE) antes ou (AFTER) depois q a ação tenha ocorrido, e por fim pode ocorrer para as açãoes de INSERT, UPDATE e DELETE em uma tabela.

ROW LEVEL:
	As triggers Row Level são utilizadas para operações como:
	Gravação de logs de auditoria de uma aplicação;
	Verificação de dados (Consistencias);
	Implementação de integridade referencial;
	
STATEMENT:
		Os Triggers do tipo STATEMENT tem a finalidade de tratar a execução de ação sobre tabelas independente de quantas linhas forem afetadas.
		Através desde tipo de trigger podemos registrar a execução de comandos INSERT, UPDATE e DELETE contra tabelas que tenham Triggers contemplando essas ações.
		
MODIFICADORES:

	Podemos nos caso de triggers de linha, fazer referência a valores contidos nas colunas e com isso podemos querer saber os valores antes da alteração e depois dos valores efetivamente alterados. Isso vale na ação de UPDATE, nos casos de INSERT E DELETE os valores de OLD(INSERT) e NEW(DELETE) são nullos.
	Estes modificadores podem ser usados APENAS em TRIGGERS. Não podemos usá-los em PROCEDURES, FUNCTIONS ou PACKAGES.
	
	Os valores são referênciados da seguinte forma :OLD.nomecoluna e :NEW.nomecoluna.
	Não importa se a TRIGGER for BEFORE ou AFTER os modificadores OLD e NEW não são afetados.
	
TIPOS DE OPERADORES:

	INSERTING, UPDATING e DELETING
	
	Podemos criar Triggers para serem disparados para várias ações de banco de dados.
	Dessa forma como podemos diferenciar uma ação de insert de outra de delete ou ainda update.
	Estes modificadores podem ser feitos APENAS dentro de TRIGGERS.
	
RESTRICOES:

	Não podemos realizar os comandos COMMIT,ROLLBACK e SAVEPOINT em um Trigger, mesmo que seja uma procedure executada em uma Trigger.
	Não podemos fazer select na mesma tabela que sofre a ação de um trigger, pois isso pode provocar um erro chamado MUTANT TABLE. 
	mesmo porque se quisermos saber o valor de uma coluna do registro que está sendo tratado em um Trigger basta colocarmos :new.nomecoluna ou 
    :old.nomecoluna para termos respectivamente os valores atuais e anteriores a alteração.

	Triggers tornam as operações mais lentas, isso ocorre principalmente em casos de triggers de linha.
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
88.TRIGGERS EXEMPLOS 

--drop table EMPREGADOS;
--drop table log_salario;
--drop trigger trg_salario_aud
--SELECT USER FROM DUAL;
CREATE TABLE EMPREGADOS(CODIGO INT NOT NULL PRIMARY KEY,
                        NOME VARCHAR2(20),
                        SALARIO DECIMAL(10,2)
                        );
    
CREATE TABLE log_salario(codigo INT,
                         salario_anterior DECIMAL(10,2),
                         salario_atual  DECIMAL(10,2),
                         data_alteracao DATE,
                         usuario VARCHAR2(20),
                         operacao varchar2(10)
                         );
    

--exemplo each row
CREATE OR REPLACE TRIGGER trg_salario_aud
after INSERT ON EMPREGADOS
FOR EACH ROW
BEGIN
INSERT INTO log_salario 
                   (codigo,salario_anterior,salario_atual,data_alteracao,usuario,operacao) 
                VALUES       
                   (:NEW.codigo,:OLD.SALARIO,:NEW.SALARIO,SYSDATE,USER,'');
END;

--Teste insert
INSERT INTO EMPREGADOS VALUES (1,'Peter',2999);
INSERT INTO EMPREGADOS VALUES (2,'john',3499);

select * from EMPREGADOS;

--select * from log_salario;
--SELECT L.*, TO_CHAR(L.DATA_ALTERACAO,'DD/MM/YYYY HH24:MI:SS') AS DATA_ALTERACAO FROM LOG_SALARIO L;

SELECT L.CODIGO, 
       --DECODE(L.SALARIO_ANTERIOR,NULL,'NÃO TEVE PROMOCAO')AS ANTIGO_SALARIO, 
       L.SALARIO_ANTERIOR,
       L.SALARIO_ATUAL,
       TO_CHAR(L.DATA_ALTERACAO,'DD/MM/YYYY HH24:MI:SS') AS DATA_ALTERACAO, 
       L.USUARIO,
       NVL(L.OPERACAO,'XXXX') AS OPERACAO
FROM LOG_SALARIO L;       
       
       
       
--teste update
-- COM ESSE APDATE NAO VAI CONSTAR NA TAB LOG_SALARIO, PQ E APOS A ACAO...
update EMPREGADOS 
set salario = salario *1.10
where CODIGO = '1';


--desabilitando trigger
alter trigger trg_salario_aud disable;

--apos disable
INSERT INTO EMPREGADOS VALUES (3,'Mary',4499);
--habilitando trigger
alter trigger trg_salario_aud enable;

-- Exemplo com operadores  
--Exemplo statements/declaracao de operadores
CREATE OR replace TRIGGER trg_salario_aud 
  AFTER INSERT OR DELETE OR UPDATE ON empregados 
  FOR EACH ROW
  
  DECLARE
    p_oper VARCHAR2(10);
BEGIN 
    IF inserting THEN 
      p_oper := 'insere';
      INSERT INTO log_salario 
                  (codigo,salario_anterior,salario_atual,data_alteracao,usuario,operacao) 
                VALUES      
                  (:NEW.codigo,NULL,:NEW.SALARIO,SYSDATE,USER,P_oper);
      
    ELSIF updating THEN 
       p_oper := 'atualiza';
      INSERT INTO log_salario 
                   (codigo,salario_anterior,salario_atual,data_alteracao,usuario,operacao) 
                VALUES      
                   (:NEW.codigo,:OLD.SALARIO,:NEW.SALARIO,SYSDATE,USER,P_oper); 
    ELSIF deleting THEN 
      p_oper := 'deleta';
       INSERT INTO log_salario 
                  (codigo,salario_anterior,salario_atual,data_alteracao,usuario,operacao) 
                VALUES      
                  (:old.codigo,:OLD.SALARIO,NULL,SYSDATE,USER,p_oper); 
    END IF; 
END; 
/ 

--testando 

INSERT INTO EMPREGADOS VALUES (5,'Lennon',3499);

update empregados set salario = salario * 1.05 where codigo = '5';

delete from EMPREGADOS where codigo = '5'

select * from log_salario;

-- exemplo de trigger de restrição de horario
CREATE OR REPLACE TRIGGER trg_restricao_emp
BEFORE INSERT OR DELETE OR UPDATE
ON empregados
REFERENCING NEW AS NEW OLD AS OLD
BEGIN
    IF TO_NUMBER (TO_CHAR (SYSDATE, 'hh24')) NOT BETWEEN 07 AND 12 THEN
    raise_application_error(-20001,'Operação não pode ser executada fora do horário de expediente.');
    END IF;

END;
/

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
SECAO 13: PACKAGES
89.PACKAGE INTRODUCAO


	Uma package é uma coleção de objetos PL/SQL agrupados logicamente sob o nome de pacote. Os packages podem incluir procedures, functions, cursores, declarações, tipos e também variáveis.
	
	Os packages geralmente possuem duas partes, uma que se refere a spec(Especificação)  e a segunda parte que é o body(Corpo).
	A speck é o q chamamos de interface para o package. É nela que declaramos os tipos, variáveis, constantes, exceções, cursores e subprogramas que poderão ser referenciados a partir de partes externas ao package.
	
	Por outro lado, no body definimos as consultas para os cursores e o código para os subprogramas. Em alguns casos pode ser que não haja a necessidade de se ter um body.
	
	Package PL/SQL é um grupo de funções relacionadas, procedimentos, tipos, cursores dentre outros. Os packages são como uma biblioteca, pois uma vez escrito é armazenado no banco de dados Oracle e pode ser usado por muitas aplicações.
	

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
90.PACKAGE EXEMPLO

--criando especificação do package
--criando a package com 2 funções e uma procedure

CREATE OR REPLACE PACKAGE PKG_FUNC AS
  
    ---PROCEDURE SIMULA SALARIO AUMENTO
    PROCEDURE PROC_SIMULA(n_func_id NUMBER); -- O parametro IN e o retorno da function...
	
  -- get nome completo do funcionario
    FUNCTION get_nomeCompleto(n_func_id NUMBER) 
      RETURN VARCHAR2;
	  
   --  get salario do funcionario
    FUNCTION get_salario(n_func_id NUMBER)
      RETURN NUMBER;

  END PKG_FUNC;
  
  

--criando o boby
/*
    Package PKG_FUNC body
  */
  CREATE OR REPLACE PACKAGE BODY PKG_FUNC AS
  --get funcionario nomeCompleto
    FUNCTION get_nomeCompleto(n_func_id NUMBER) RETURN VARCHAR2 IS
        v_nomeCompleto VARCHAR2(50);
    BEGIN
      SELECT a.FIRST_NAME || ',' ||  a.LAST_NAME
      INTO v_nomeCompleto
      FROM HR.EMPLOYEES a
      WHERE a.employee_id = n_func_id;
      
      RETURN v_nomeCompleto;
   
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN NULL;
    WHEN TOO_MANY_ROWS THEN
      RETURN NULL;
    END; 
    --end get_nomeCompleto
   
    -- get salario
    FUNCTION get_salario(n_func_id NUMBER) RETURN NUMBER IS
      n_salario NUMBER(8,2);
    BEGIN
      SELECT a.SALARY
      INTO n_salario
      FROM HR.EMPLOYEES a
      WHERE a.EMPLOYEE_ID = n_func_id;
   
      RETURN n_salario;
   
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          RETURN NULL;
        WHEN TOO_MANY_ROWS THEN
          RETURN NULL;
    END;
-- END get_salario
--PROCEDURE

  PROCEDURE PROC_SIMULA(n_func_id NUMBER) IS
    V_SAL_NOVO NUMBER(8,2);
    BEGIN
        SELECT a.SALARY *1.10 
        INTO V_SAL_NOVO 
        FROM HR.EMPLOYEES a
        where a.EMPLOYEE_ID = n_func_id;
        dbms_output.put_line('O Novo salario é->> '||V_SAL_NOVO);
    END;
    --fim PROCEDURE
  END PKG_FUNC;
/

--Chamada do package
--package_name.package_element
--Executando pkg

SET SERVEROUTPUT ON SIZE 1000000; -- Comando q define o tamanho do buffer

  DECLARE
    n_salario NUMBER(8,2);
    v_nome   VARCHAR2(50);
    n_func_id NUMBER := &ID_FUNC;
    
   
  BEGIN
        v_nome    := PKG_FUNC.get_nomeCompleto(n_func_id);
        n_salario := PKG_FUNC.get_salario(n_func_id);
 
    IF v_nome  IS NOT NULL AND n_salario IS NOT NULL
    THEN
      dbms_output.put_line('Funcionário: ' || v_nome);
      dbms_output.put_line('Recebe salário = ' || n_salario);
      PKG_FUNC.PROC_SIMULA(n_func_id);
    END IF;
  END;
  
  
  
--Essa package contem duas dunctions, vou executar apenas uma...Obs.  
--executando um objeto
SET SERVEROUTPUT ON SIZE 1000000;
  DECLARE
    n_salario NUMBER(8,2);
    v_nome   VARCHAR2(50);
    n_func_id NUMBER := &empresa_id;
  BEGIN
   
    v_nome   := PKG_FUNC.get_nomeCompleto(n_func_id);
   
    IF v_nome  IS NOT NULL 
    THEN
      
      dbms_output.put_line('Funcionário: '|| v_nome);
     
    END IF;
  END;


--EXCUTANDO SO A PROCEDURE

  SET SERVEROUTPUT ON SIZE 1000000;
  DECLARE
   
    n_func_id NUMBER := &ID_FUNC;
  BEGIN
    PKG_FUNC.PROC_SIMULA(n_func_id);
  END;
  

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
SECAO 14: PROJETO - MINI ERP MULTI EMPRESAS 
91.OVERVIEW PROJETO

	ANALISE DE REQUISITOS:
		Criação de documentos, minimundos e modelos externos. (Entrevista com o cliente)
		A primeira etapa do projeto de banco de dados é a identificação dos requisitos que o banco de dados deve atender.
		

	PROJETO CONCEITUAL:
		Criação do Modelo Conceitual.
		"Baseia na especificação de requisitos criada na etapa amterior". A partir deste insumo de informações é gerado  um esquema conceitual do banco de dados. Esquema conceitual é uma visão macro do banco de dados, uma descrição de alto nível da estrutura. Os MODELOS DE ENTIDADE-RELACIONAMENTO são muito utilizados.
		
	PROJETO LÓGICO:
		Criação do modelo interno.
		"Mapeamos o conceito dos modelos de entidade-relacionamento em objetivos de banco de dados". Nesta fase criamos os MODELOS INTERNOS de bancos de dados, com detalhe sobre tabelas, relacionamentos, regras, tipo de dados das colunas (Tipo, Tamanho, Obrigatoriedade)...
		
	PROJETO FÍSICO:
		Criação de script's, modelos físicos, estratégias de armazenamento e bacKup.        '
		Parte final do projeto de banco de dados, nesta etapa define-se detalhes técnicos da implementação do banco de dados, por exemplo, a forma como os dados serão armazenados, os script's para a criação dos objetos no banco de dados (Tabela, Visões, Colunas, rotinas, ....), permissão de acesso de usuário e etc.   '
		
	O QUE SERÁ CONTEMPLADO NESSE ERP?
		Banco de dados
		Cadastro de usuário (Login e Senha)
		Produção 
		Suprimentos (Controle de Estoque)
		RH (Cadastro de Funcionários/Folha de pag.)
		Financeiro (O q foi comprado e precisa pagar, (à receber))
		Comercial (o q foi vendido pelo comercial)
		Fiscal 
		
		
		PROJETO PROCEDURES:
		
		PEDIDO DE VENDA = INCLUSÃO DO PEDIDO DE VENDAS = TABELAS: PED_VENDAS/ PED_VENDAS_ITENS
		
		ORDEM DE PRODUCAO = GERA ORDEM DE PROD. COM BASE NA DEMANDA DE PEDIDOS = PROCEDURE: PROC_PLAN_ORDEM
		
		PEDIDO DE COMPRAS = GERA PED. DE COMPRAR C/ BASE NAS ORDENS PROD PLAN = PROCEDURE: PROC_GER_PED_COMPRAS
		
		MOVIMENTA ESTOQUE (E/S) = GERA MOVIMENTO DE ESTOQUE ENTRADA E SAIDA = PROCEDURE: PROC_GERA_ESTOQUE
		
		GERA NOTA FISCAL (E/S) = GERA NOTA FISCAL DE "E" DE PED. COMPRAS E GERA NOTA FISCAL "S" DE PED DE VENDAS = PROCEDURE; PROC_GERA_NF 
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
92.Criando TableSpace para Projeto.

 -- criando tablespace para o projeto BD erp Multi empresa TESTE
 create tablespace erp_mult_tst
         datafile
         'C:\oraclexe\app\oracle\oradata\XE\erp_mult_tst.dbf' 
		size 100m autoextend on next 50m maxsize 500m
         online
         permanent
         extent management local autoallocate
         segment space management auto;

-- criando usuario
create user user_tst
          identified by 123456
          default tablespace erp_mult_tst
          temporary tablespace TEMP;

-- concendendo permissoes para o usuario
grant ALL PRIVILEGES to user_tst;

-- alterando limite de cota para o usuario
alter user user_tst quota unlimited on erp_mult_tst;



 -- criando tablespace para o projeto BD erp Multi empresa PRODUCAO
 create tablespace erp_mult_prd
         datafile
         'C:\oraclexe\app\oracle\oradata\XE\erp_mult_prd.dbf' 
		size 100m autoextend on next 50m maxsize 500m
         online
         permanent
         extent management local autoallocate
         segment space management auto;

-- criando usuario
create user user_prd
          identified by 123456
          default tablespace erp_mult_prd
          temporary tablespace TEMP;

-- concendendo permissoes para o usuario
grant ALL PRIVILEGES to user_prd;

-- alterando limite de cota para o usuario
alter user user_prd quota unlimited on erp_mult_prd;


-- drop objetos
/*
drop user user_prd CASCADE; -- Qunado eu elimino o usuario, elimino tbm os objetos q pertence a ele.
drop user user_tst CASCADE;

drop tablespace erp_mult_prd INCLUDING CONTENTS AND DATAFILES; -- quando elimino o a tableSpace tbm elimino o datafiles, 
drop tablespace erp_mult_tst INCLUDING CONTENTS AND DATAFILES;
*/

Não esquecer de criar a conexão!!!

	
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
93.Criando as tabelas: Parte 1

-- CRIANDO A TABELA EMPRESA
CREATE TABLE EMPRESA (
 COD_EMPRESA INT NOT NULL PRIMARY KEY,
 NOME_EMPRESA VARCHAR2(50),
 FANTASIA VARCHAR2(15)
 );
 
 --CRIANDO SEQUENCIA PARA O CODIGO EMPRESA
 
 CREATE SEQUENCE SEQ_EMP START WITH 1 INCREMENT BY 1 NOMAXVALUE;

-- CADASTRO DE UNIDADE FEDERAL, UTLIZADO POR TODAS EMPRESAS
--DROP TABLE UF;
CREATE TABLE UF
(
	COD_UF VARCHAR2(2) NOT NULL PRIMARY KEY,
    SIGLA_UF VARCHAR2(2) NOT NULL,
	NOME_UF VARCHAR2(30) NOT NULL
);

 
--TABELAS CIDADES
-- CADASTRO DE CIDADES, UTLIZADO POR TODAS EMPRESAS
--DROP TABLE CIDADES;
CREATE TABLE CIDADES
	(
	COD_CIDADE VARCHAR2(7) NOT NULL PRIMARY KEY,
	COD_UF VARCHAR2(2) NOT NULL,
	NOME_CIDADE VARCHAR2(50) NOT NULL,
	CONSTRAINT FK_CID1 FOREIGN KEY (COD_UF) REFERENCES UF(COD_UF)
	);

--CRIANDO TABELAS CLIENTES
CREATE TABLE CLIENTES
	(
    COD_EMPRESA INT NOT NULL,
	ID_CLIENTE INT NOT NULL PRIMARY KEY,
	RAZAO_CLIENTE VARCHAR2(100)NOT NULL,
	FANTASIA VARCHAR2(15) NOT NULL,
	ENDERECO VARCHAR2(50) NOT NULL,
	NRO VARCHAR2(10) NOT NULL,
	BAIRRO VARCHAR2(20) NOT NULL,
	COD_CIDADE VARCHAR2(7) NOT NULL,
	CEP VARCHAR2(8),
	CNPJ_CPF VARCHAR2(15),
	TIPO_CLIENTE CHAR(1) CONSTRAINT CK_TC1 CHECK (TIPO_CLIENTE in ('F', 'J')),
	DATA_CADASTRO DATE NOT NULL,
	COD_PAGTO INT ,
    CONSTRAINT FK_COD_EMP1 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA),
	CONSTRAINT FK_CLI1 FOREIGN KEY (COD_CIDADE) REFERENCES CIDADES(COD_CIDADE)
	);

 -- CRIANDO SEQUENCIA PARA CLIENTES;  
 CREATE SEQUENCE SEQ_CLI START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--CRIACAO TABELA FORNECEDORES
CREATE TABLE FORNECEDORES
(   COD_EMPRESA INT NOT NULL,
    ID_FOR INT  NOT NULL PRIMARY KEY,
	RAZAO_FORNEC VARCHAR2(100)NOT NULL,
	FANTASIA VARCHAR2(15) NOT NULL,
	ENDERECO VARCHAR2(50) NOT NULL,
	NRO VARCHAR2(10) NOT NULL,
	BAIRRO VARCHAR2(20) NOT NULL,
	COD_CIDADE VARCHAR2(7) NOT NULL,
	CEP VARCHAR2(8),
	CNPJ_CPF VARCHAR2(15),
	TIPO_FORNEC CHAR(1) CONSTRAINT CK_TF1 CHECK (TIPO_FORNEC in ('F', 'J')),
	DATA_CADASTRO DATE NOT NULL,
	COD_PAGTO INT ,
    CONSTRAINT FK_COD_EMP2 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA),
	CONSTRAINT FK_FOR1 FOREIGN KEY (COD_CIDADE) REFERENCES CIDADES(COD_CIDADE)
	);
    
 -- CRIANDO SEQUENCIA PARA FORNECEDORES;  
 CREATE SEQUENCE SEQ_FOR START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--TABELAS TIPO DE MATERIAL
CREATE TABLE TIPO_MAT
	(
	COD_TIP_MAT INT  NOT NULL PRIMARY KEY,
	DESC_TIP_MAT VARCHAR2(20) NOT NULL
	);
    
--CRIANDO SEQUENCIA TIPO MATERIAL
 CREATE SEQUENCE SEQ_TIP_MAT START WITH 1 INCREMENT BY 1 NOMAXVALUE;
 
--CRIANDO TABELAS MATERIAL
CREATE TABLE MATERIAL
	(
    COD_EMPRESA INT NOT NULL,
	COD_MAT INT NOT NULL,
	DESCRICAO VARCHAR2(50) NOT NULL,
	PRECO_UNIT DECIMAL(10,2) NOT NULL,
	COD_TIP_MAT INT NOT NULL,
    CONSTRAINT FK_COD_EMP3 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA),
	CONSTRAINT FK_MAT1 FOREIGN KEY (COD_TIP_MAT) REFERENCES TIPO_MAT(COD_TIP_MAT),
    CONSTRAINT PK_EMP_MAT PRIMARY KEY (COD_EMPRESA,COD_MAT)
	);


    
CREATE TABLE MAT_FORNEC
(
    COD_EMPRESA INT NOT NULL,
    COD_MAT INT NOT NULL,
    ID_FOR INT NOT NULL,
    CONSTRAINT PK_MAT_FOR PRIMARY KEY (COD_EMPRESA,COD_MAT,ID_FOR),
    CONSTRAINT FK_MAT_FOR1 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA),
    CONSTRAINT FK_MAR_FOR2 FOREIGN KEY (ID_FOR) REFERENCES FORNECEDORES(ID_FOR)
    );

--CRIANDO INDEX
--SIMULA ERRO INDEX DE CHAVE PRIMARIA
--CREATE INDEX IX_MAT1 ON MATERIAL(COD_EMPRESA,COD_MAT);
--CRIANDO INDEX TIPO MAT
CREATE INDEX IX_MAT2 ON MATERIAL(COD_TIP_MAT);

	
--PRODUCAO
CREATE TABLE ORDEM_PROD
	(
    COD_EMPRESA INT NOT NULL,
	ID_ORDEM INT NOT NULL PRIMARY KEY,
	COD_MAT_PROD INT NOT NULL,
	QTD_PLAN DECIMAL(10,2) NOT NULL,
	QTD_PROD DECIMAL(10,2) NOT NULL,
	DATA_INI DATE,
	DATA_FIM DATE,
	SITUACAO CHAR(1) CONSTRAINT CK_OP1 CHECK (SITUACAO in ('A','P','F')),--A-ABERTA, P-PLANEJADA -F-FECHADA
    CONSTRAINT FK_OP1 FOREIGN KEY (COD_MAT_PROD,COD_EMPRESA) REFERENCES MATERIAL(COD_MAT,COD_EMPRESA)
    --CONSTRAINT FK_COD_EMP4 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
	);
    
--CRIANDO SEQUENCIA ORDEM DE PRODUCAO
 CREATE SEQUENCE SEQ_OP START WITH 1 INCREMENT BY 1 NOMAXVALUE;
    
--CRIACAO DE TABELAS APONTAMENTOS DE PRODUCAO
--DROP TABLE APONTAMENTOS
CREATE TABLE APONTAMENTOS
	(
    COD_EMPRESA INT NOT NULL,
	ID_APON INT NOT NULL PRIMARY KEY,
	ID_ORDEM INT NOT NULL,
	COD_MAT_PROD INT,
	QTD_APON DECIMAL(10,2),
	DATA_APON DATE NOT NULL,
	--CAMPO LOTE CRIADO NO FINAL
	--LOGIN, SERA CRIADO APOIS CRIACAO DA TABELA USUARIOS
    CONSTRAINT FK_AP1 FOREIGN KEY (COD_MAT_PROD,COD_EMPRESA) REFERENCES MATERIAL(COD_MAT,COD_EMPRESA),
	CONSTRAINT FK_APON1 FOREIGN KEY (ID_ORDEM) REFERENCES ORDEM_PROD(ID_ORDEM)
	);
    
-- CRIANDO SEQUENCIA PARA TABELA APONTAMENTOS
CREATE SEQUENCE SEQ_APON START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--CRIACAO DA TABELA FICHA TECNICA
CREATE TABLE FICHA_TECNICA
(
    COD_EMPRESA INT NOT NULL,
	COD_MAT_PROD INT NOT NULL,
	COD_MAT_NECES INT NOT NULL,
	QTD_NECES DECIMAL(10,2) NOT NULL,
	CONSTRAINT FK_FIC1 FOREIGN KEY (COD_EMPRESA,COD_MAT_PROD) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT),
	CONSTRAINT FK_FIC2 FOREIGN KEY (COD_EMPRESA,COD_MAT_NECES) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT)
	);
    
-- CRIANDO SEQUENCIA PARA TABELA FICHA_TECNICA
CREATE SEQUENCE SEQ_FT START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--CRIACAO DA TABELA CONSUMO
--DROP TABLE CONSUMO
CREATE TABLE CONSUMO
(
	ID_APON INT NOT NULL,
    COD_EMPRESA INT NOT NULL,
	COD_MAT_NECES INT NOT NULL,
	QTD_CONSUMIDA DECIMAL(10,2) NOT NULL,
	LOTE VARCHAR2(20) NOT NULL,
	CONSTRAINT FK_CONS1 FOREIGN KEY (COD_EMPRESA,COD_MAT_NECES) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT),
	CONSTRAINT FK_CONS2 FOREIGN KEY (ID_APON)  REFERENCES APONTAMENTOS(ID_APON)
	);


--SUPRIMENTOS
--CRIACAO DA TABELA 
CREATE TABLE ESTOQUE
	(
    COD_EMPRESA INT NOT NULL,
    COD_MAT INT NOT NULL,
	QTD_SALDO DECIMAL(10,2) NOT NULL,
	CONSTRAINT FK_EST1 FOREIGN KEY (COD_EMPRESA,COD_MAT) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT),
    CONSTRAINT PK_ESTOQUE1 PRIMARY KEY (COD_EMPRESA,COD_MAT)
	);
    
--DROP TABLE ESTOQUE_LOTE
--CRIACAO TABELAS ESTOQUE_LOTE
CREATE TABLE ESTOQUE_LOTE
	(
    COD_EMPRESA INT NOT NULL,
	COD_MAT INT NOT NULL,
	LOTE VARCHAR2(20) NOT NULL,
	QTD_LOTE DECIMAL(10,2) NOT NULL,
	CONSTRAINT PK_ESTL1 PRIMARY KEY (COD_EMPRESA,COD_MAT,LOTE), --PK COMPOSTA
	CONSTRAINT FK_ESTL1 FOREIGN KEY (COD_EMPRESA,COD_MAT) 
	REFERENCES MATERIAL(COD_EMPRESA,COD_MAT)
	);
--CRIACAO TABELA MOV ESTOQUE
--DROP TABLE ESTOQUE_MOV
	CREATE TABLE ESTOQUE_MOV
	(
	ID_MOV INT  NOT NULL PRIMARY KEY,
    COD_EMPRESA INT NOT NULL,
	TIP_MOV VARCHAR2(1),CONSTRAINT CK_MOV CHECK (TIP_MOV in ('S','E')), --S=SAIDA ,E=ENTRADA
	COD_MAT INT NOT NULL,
	LOTE  VARCHAR2(20) NOT NULL,
	QTD DECIMAL(10,2) NOT NULL,
	DATA_MOV DATE NOT NULL,
	DATA_HORA DATE NOT NULL,
	CONSTRAINT FK_ESTM1 FOREIGN KEY (COD_EMPRESA,COD_MAT) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT)
	--CAMPO LOGIN TABELA ESTOQUE_MOV CRIACAO APOS TABELA USUARIO
	);
    
    
-- CRIANDO SEQUENCIA PARA TABELA ESTOQUE_MOV
CREATE SEQUENCE SEQ_MOVEST START WITH 1 INCREMENT BY 1 NOMAXVALUE;
--CRIACAO TABELAS PED_COMPRAS
--DROP TABLE PED_COMPRAS	
CREATE TABLE PED_COMPRAS
	(
    COD_EMPRESA INT NOT NULL,
	NUM_PEDIDO INT  NOT NULL,
	ID_FOR INT NOT NULL,
	COD_PAGTO INT NOT NULL, --ALTERAR  COD_PAGTO TAB PED_COMPRAS PARA FOREIGN KEY APOS TABELA COND_PAGTO  	
	DATA_PEDIDO DATE NOT NULL,
	DATA_ENTREGA DATE NOT NULL,
	SITUACAO NCHAR(1) NOT NULL, --A-ABERTO P-PLANEJADO -F FINALIZADO
	TOTAL_PED DECIMAL(10,2),
	CONSTRAINT FK_PEDC1 FOREIGN KEY (ID_FOR) REFERENCES FORNECEDORES(ID_FOR),
    CONSTRAINT PK_PEDC1 PRIMARY KEY (COD_EMPRESA,NUM_PEDIDO)
	);
    
    -- CRIACAO DE TABELA DE PARAMETROS DE NUMEROS DE PEDIDO POR EMPRESA
    CREATE TABLE PARAM_PED_COMPRAS
    (
     COD_EMPRESA INT NOT NULL PRIMARY KEY,
     NUM_PED INT NOT NULL,
     CONSTRAINT FK_PPC FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
     );
     
--CRIACAO DA TABELA PEDIDO COMPRAS
CREATE TABLE PED_COMPRAS_ITENS
	(
    COD_EMPRESA INT NOT NULL,
	NUM_PEDIDO INT NOT NULL,
	SEQ_MAT INT NOT NULL,
	COD_MAT INT NOT NULL,
	QTD     INT NOT NULL,
	VAL_UNIT DECIMAL(10,2) NOT NULL,
	CONSTRAINT FK_PEDIT1 FOREIGN KEY (COD_EMPRESA,NUM_PEDIDO) REFERENCES PED_COMPRAS(COD_EMPRESA,NUM_PEDIDO),
	CONSTRAINT FK_PEDIT2 FOREIGN KEY (COD_EMPRESA,COD_MAT) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT),
    CONSTRAINT PK_PED_C_IT PRIMARY KEY (COD_EMPRESA,NUM_PEDIDO,SEQ_MAT)
	);
	

--RH
--CRIACAO TABELAS CENTRO DE CUSTO
CREATE TABLE CENTRO_CUSTO
	(
    COD_EMPRESA INT NOT NULL,
	COD_CC VARCHAR2(4) NOT NULL,
	NOME_CC VARCHAR2(20) NOT NULL,
    CONSTRAINT FK_CC1  FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA),
    CONSTRAINT PK_CC1 PRIMARY KEY (COD_EMPRESA,COD_CC)
	);

--CRIACAO TABELAS CARGOS]
-- AVALIAR CENARIOS 
CREATE TABLE CARGOS 
	(COD_EMPRESA INT NOT NULL,
     COD_CARGO INT  NOT NULL,
	 NOME_CARGO VARCHAR2(50),
     CONSTRAINT FK_CARG1  FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA),
     CONSTRAINT PK_CARG1 PRIMARY KEY (COD_EMPRESA,COD_CARGO)
	 );
--CRIACAO TABELA FUNCIONARIO
CREATE TABLE FUNCIONARIO 
	(
    COD_EMPRESA INT NOT NULL,
	MATRICULA INT NOT NULL ,
	COD_CC VARCHAR2(4) NOT NULL,
	NOME   VARCHAR2(50) NOT NULL,
	RG     VARCHAR2(15) NOT NULL,
	CPF    VARCHAR2(15) NOT NULL,
	ENDERECO  VARCHAR2(50)NOT NULL,
	NUMERO VARCHAR2(10) NOT NULL,
	BAIRRO VARCHAR2(50) NOT NULL,
	COD_CIDADE VARCHAR2(7) NOT NULL,
	DATA_ADMISS DATE NOT NULL,
	DATE_DEMISS DATE,
	DATA_NASC DATE NOT NULL,
	TELEFONE VARCHAR2(15) NOT NULL,
	COD_CARGO INT NOT NULL,
	CONSTRAINT FK_FUNC1 FOREIGN KEY (COD_EMPRESA,COD_CC) REFERENCES CENTRO_CUSTO(COD_EMPRESA,COD_CC),
	CONSTRAINT FK_FUNC2 FOREIGN KEY (COD_CIDADE) REFERENCES CIDADES(COD_CIDADE),
	CONSTRAINT FK_FUNC3 FOREIGN KEY (COD_EMPRESA,COD_CARGO) REFERENCES CARGOS(COD_EMPRESA,COD_CARGO),
    CONSTRAINT PK_FUNC1 PRIMARY KEY(COD_EMPRESA,MATRICULA)
    );

-- TABELAS DE PARAMETROS DE MATRICULA POR EMPRESA
 CREATE TABLE PARAM_MATRICULA
  (
   COD_EMPRESA INT NOT NULL PRIMARY KEY,
   MATRICULA INT NOT NULL,
   CONSTRAINT FK_PMAT1 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
   );

--CRIACAO TABELA SALARIO
CREATE TABLE SALARIO
	(
    COD_EMPRESA INT NOT NULL,
	MATRICULA INT NOT NULL,
	SALARIO DECIMAL(10,2)NOT NULL,
	CONSTRAINT FK_SAL1 FOREIGN KEY (COD_EMPRESA,MATRICULA) REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA),
    CONSTRAINT PK_SAL1 PRIMARY KEY (COD_EMPRESA,MATRICULA) 
    );
--CRIACAO TABLE FOLHA DE PAGTO
--DROP TABLE FOLHA_PAGTO
CREATE TABLE FOLHA_PAGTO
	(
    COD_EMPRESA INT NOT NULL,
	MATRICULA INT NOT NULL,
	TIPO_PGTO CHAR(1) NOT NULL,-- (M-FOLHA,A-ADTO,F-FERIAS,D-13º,R-RESC),
	TIPO CHAR(1)  NOT NULL,--P=PROVENTOS D-DESCONTO
	EVENTO VARCHAR2(30) NOT NULL, 
	MES_REF VARCHAR2(2)NOT NULL,
	ANO_REF VARCHAR2(4)NOT NULL,
	DATA_PAGTO DATE NOT NULL,
	VALOR DECIMAL(10,2) NOT NULL,
    CONSTRAINT FK_FP1 FOREIGN KEY (COD_EMPRESA,MATRICULA) REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA)
	);
    
-- CRIANDO INDEX PARA OTIMARIZAR CONSULTAS
CREATE INDEX IX1_FPAG ON FOLHA_PAGTO(COD_EMPRESA,MES_REF,ANO_REF);



--SEGURANCA
--CRIACAO TA TABELAS USARIOS 
CREATE TABLE USUARIOS
	(
    COD_EMPRESA INT NOT NULL,
	LOGIN VARCHAR2(30) NOT NULL ,
	MATRICULA INT NOT NULL,
	SENHA   VARCHAR2(32) NOT NULL,
	SITUACAO CHAR(1) NOT NULL, --A=ATIVO -B BLOQUEADO
	CONSTRAINT FK_US1 FOREIGN KEY (COD_EMPRESA,MATRICULA) 
	REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA),
    CONSTRAINT PK_USER PRIMARY KEY(COD_EMPRESA,MATRICULA)
	);
    
-- CRIANDO INDEX UNIQUE PARA LOGIN
CREATE UNIQUE INDEX IX1_USER ON USUARIOS (LOGIN);


--FINANCEIRO
--CRIACAO TABELA CONTAS A RECEBER
CREATE TABLE CONTAS_RECEBER
	(
    COD_EMPRESA INT NOT NULL,
	ID_DOC INT  NOT NULL PRIMARY KEY,
    ID_CLIENTE INT NOT NULL,
	ID_DOC_ORIG INT NOT NULL, --ALTER CAMPO ID_DOC_ORIG PARA FK TABELA NOTA_FISCAL
	PARC INT NOT NULL,
	DATA_VENC DATE NOT NULL,
	DATA_PAGTO DATE,
	VALOR DECIMAL(10,2),
	CONSTRAINT FK_CR1 FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTES(ID_CLIENTE),
    CONSTRAINT FK_CR2 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
	);
    
-- CRIANDO SEQUENCIA PARA TABELA CONTAS_RECEBER
CREATE SEQUENCE SEQ_CRE START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--CRIACAO TABELA CONTAS A PAGAR
--DROP TABLE CONTAS_PAGAR
CREATE TABLE CONTAS_PAGAR
	(
    COD_EMPRESA INT NOT NULL,
	ID_DOC INT  NOT NULL PRIMARY KEY,
    ID_FOR INT NOT NULL,
	ID_DOC_ORIG INT NOT NULL, --ALTER CAMPO ID_DOC_ORIG PARA FK TABELA NOTA_FISCAL
	PARC INT NOT NULL,
	DATA_VENC DATE NOT NULL,
	DATA_PAGTO DATE ,
	VALOR DECIMAL(10,2),
	CONSTRAINT FK_CP1 FOREIGN KEY (ID_FOR) REFERENCES FORNECEDORES(ID_FOR),
    CONSTRAINT FK_CP2 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
	);
    
-- CRIANDO SEQUENCIA PARA TABELA CONTAS_PAGAR
CREATE SEQUENCE SEQ_CAP START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--CRIACAO TABELA CONDIÇÕES DE PAGTO
CREATE TABLE COND_PAGTO
	(
	COD_PAGTO INT  NOT NULL PRIMARY KEY,
	NOME_CP VARCHAR2(50) NOT NULL 
	);
    
-- CRIANDO SEQUENCIA PARA TABELA COND_PAGTO
CREATE SEQUENCE SEQ_PAGTO START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--CRIACAO DA TABELAS DETALHES DE CONDICAO DE PAGTO COM PARCELA
CREATE TABLE COND_PAGTO_DET
	(
	COD_PAGTO INT NOT NULL,
	PARC     INT NOT NULL,
	DIAS     INT NOT NULL,
	PCT  DECIMAL(10,2)NOT NULL,--PERCENTUAL DA PARCELA
	CONSTRAINT FK_CONDP1 FOREIGN KEY (COD_PAGTO) 
	REFERENCES COND_PAGTO(COD_PAGTO)
	);

--COMERCIAL
--CRIACAO TABELA PEDIDO DE VENDAS
CREATE TABLE PED_VENDAS
	(
    COD_EMPRESA INT NOT NULL,
	NUM_PEDIDO INT  NOT NULL,
	ID_CLIENTE INT NOT NULL,
	COD_PAGTO INT NOT NULL, 
	DATA_PEDIDO DATE NOT NULL,
	DATA_ENTREGA DATE NOT NULL,
	SITUACAO NCHAR(1) NOT NULL, --A-ABERTO P-PLANEJADO -F FINALIZADO
	TOTAL_PED DECIMAL(10,2),
	CONSTRAINT FK_PV1 FOREIGN KEY (ID_CLIENTE)REFERENCES CLIENTES(ID_CLIENTE),
	CONSTRAINT FK_PV2 FOREIGN KEY (COD_PAGTO) REFERENCES COND_PAGTO(COD_PAGTO),
    CONSTRAINT FK_PV3 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA),
    CONSTRAINT PK_PV1 PRIMARY KEY(COD_EMPRESA,NUM_PEDIDO)
	);
    
   -- CRIACAO DE TABELA DE PARAMETROS DE NUMEROS DE PEDIDO DE VENDAS POR EMPRESA
    CREATE TABLE PARAM_PED_VENDAS
    (
     COD_EMPRESA INT NOT NULL PRIMARY KEY,
     NUM_PED INT NOT NULL,
     CONSTRAINT FK_PV FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
     );
    
--CRIACAO DA TABELA PEDIDO VENDAS ITENS
--DROP TABLE PED_VENDAS_ITENS
CREATE TABLE PED_VENDAS_ITENS
	(
    COD_EMPRESA INT NOT NULL,
	NUM_PEDIDO INT NOT NULL,
	SEQ_MAT INT NOT NULL,
	COD_MAT INT NOT NULL,
	QTD     INT NOT NULL,
	VAL_UNIT DECIMAL(10,2) NOT NULL,
	CONSTRAINT FK_PVIT1 FOREIGN KEY (COD_EMPRESA,NUM_PEDIDO) REFERENCES PED_VENDAS(COD_EMPRESA,NUM_PEDIDO),
    CONSTRAINT FK_PVIT2 FOREIGN KEY (COD_EMPRESA,COD_MAT) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT)
	);

--CRIACAO TABELAS VENDEDORES
--DROP TABLE VENDEDORES
CREATE TABLE VENDEDORES
    (
     COD_EMPRESA INT NOT NULL,
     ID_VEND INT NOT NULL,
	 MATRICULA INT NOT NULL,
 	 CONSTRAINT FK_VEND1 FOREIGN KEY (COD_EMPRESA,MATRICULA) REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA),
     CONSTRAINT PK_VEND1 PRIMARY KEY (COD_EMPRESA,MATRICULA)
	 );
    
-- CRIANDO SEQUENCIA PARA COD DO VENDEDOR
CREATE SEQUENCE SEQ_VENDEDORES START WITH 1 INCREMENT BY 1 NOMAXVALUE;
    
--CRIACAO DE TAB GERENTES DE VENDAS
CREATE TABLE GERENTES
    ( COD_EMPRESA INT NOT NULL,
      ID_GER INT  NOT NULL,
	  MATRICULA INT NOT NULL,
 	CONSTRAINT FK_GER1 FOREIGN KEY (COD_EMPRESA,MATRICULA) REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA),
    CONSTRAINT PK_GER1 PRIMARY KEY (COD_EMPRESA,MATRICULA)
	 );
     
    
-- CRIANDO SEQUENCIA PARA COD DO VENDEDOR
CREATE SEQUENCE SEQ_GERENTES START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--CANAL DE VENDAS RELACIONA GERENTE COM VENDEDOR
CREATE TABLE CANAL_VENDAS_G_V
	(
    COD_EMPRESA INT NOT NULL,
	ID_GER INT NOT NULL,
	ID_VEND INT NOT NULL,
    CONSTRAINT FK_CGV3 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
	);
    

--CANAL DE VENDAS RELACIONA VENDEDOR COM CLIENTE
--DROP TABLE CANAL_VENDAS_V_C
CREATE TABLE CANAL_VENDAS_V_C
	(
    COD_EMPRESA INT NOT NULL,
	ID_VEND INT NOT NULL,
	ID_CLIENTE INT NOT NULL,
	CONSTRAINT FK_CVC2 FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTES(ID_CLIENTE),
    CONSTRAINT FK_CCV1 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA) 
	);
--CRIACAO DE TABELA PARA REGISTRA META DE VENDAS MES A MES/ANO
CREATE TABLE META_VENDAS
	(
    COD_EMPRESA INT NOT NULL,
	ID_VEND INT NOT NULL,
	ANO VARCHAR2(4) NOT NULL,
	MES VARCHAR2(2) NOT NULL,
	VALOR DECIMAL(10,2),
	CONSTRAINT FK_MV1 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
	);


--FISCAL
--CRIACAO DA TABELA DOS CODIGO DE OPERACOES FISCAIS
--DROP TABLE CFOP
	CREATE TABLE CFOP
	(
	COD_CFOP VARCHAR2(5) NOT NULL PRIMARY KEY,
	DESC_CFOP VARCHAR2(255) NOT NULL
	);
--CRIACAO DA TABELA NOTA_FISCAL
--DROP TABLE NOTA_FISCAL
--DROP TABLE NOTA_FISCAL_ITENS
CREATE TABLE NOTA_FISCAL
	(
    COD_EMPRESA INT NOT NULL,
	NUM_NF INT NOT NULL,
	TIP_NF CHAR(1) NOT NULL, --E ENTRADA, S- SAIDA
	COD_CFOP VARCHAR2(5) NOT NULL,
	ID_CLIFOR INT NOT NULL,
	COD_PAGTO INT NOT NULL, 
	DATA_EMISSAO DATE NOT NULL,
	DATA_ENTREGA DATE NOT NULL,
	TOTAL_NF DECIMAL(10,2),
	INTEGRADA_FIN CHAR(1) DEFAULT('N'),
	INTEGRADA_SUP CHAR(1) DEFAULT('N'),
	CONSTRAINT FK_NF1 FOREIGN KEY (COD_CFOP) REFERENCES CFOP(COD_CFOP),
	CONSTRAINT FK_NF2 FOREIGN KEY (COD_PAGTO) REFERENCES COND_PAGTO(COD_PAGTO),
    CONSTRAINT PK_NF1 PRIMARY KEY (COD_EMPRESA,NUM_NF)
	);
--CRIACAO DA TABELA NOTA_FISCAL_ITENS
CREATE TABLE NOTA_FISCAL_ITENS
	(
    COD_EMPRESA INT NOT NULL,
	NUM_NF INT NOT NULL,
	SEQ_MAT INT NOT NULL,
	COD_MAT INT NOT NULL,
	QTD     INT NOT NULL,
	VAL_UNIT DECIMAL(10,2) NOT NULL,
	PED_ORIG  INT NOT NULL,
	CONSTRAINT FK_NFIT1 FOREIGN KEY (COD_EMPRESA,NUM_NF) REFERENCES NOTA_FISCAL(COD_EMPRESA,NUM_NF),
	CONSTRAINT FK_NFIT2 FOREIGN KEY (COD_EMPRESA,COD_MAT) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT)
	);
    
    --CRIACAO TABELAS PARAMETRO NUMERACAO NFE

    CREATE TABLE PARAM_NFE
    (
     COD_EMPRESA INT NOT NULL PRIMARY KEY,
     NUM_NFE INT NOT NULL,
     CONSTRAINT FK_NFE1 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
     );
    


--CRIACAO TABELAS PARAMETRO DE INSS

CREATE TABLE PARAM_INSS
(
 VIGENCIA_INI DATE,
 VIGENCIA_FIM DATE,
 VALOR_DE DECIMAL(10,2) NOT NULL,
 VALOR_ATE DECIMAL(10,2) NOT NULL,
 PCT DECIMAL(10,2) NOT NULL
 );

--CRIACAO DE TABELAS DE PARAMETRO DO IRRF
CREATE TABLE PARAM_IRRF
(
 VIGENCIA_INI DATE,
 VIGENCIA_FIM DATE,
 VALOR_DE DECIMAL(10,2) NOT NULL,
 VALOR_ATE DECIMAL(10,2) NOT NULL,
 PCT DECIMAL(10,2) NOT NULL,
 VAL_ISENT DECIMAL(10,2)
 );


 --CRIACAO TABELAS AUDIT SALARIO
 CREATE TABLE AUDITORIA_SALARIO
 (  
    COD_EMPRESA INT NOT NULL,
	MATRICULA INT NOT NULL,
	SAL_ANTES DECIMAL(10, 2) NOT NULL,
	SAL_DEPOIS DECIMAL(10, 2) NOT NULL,
	USUARIO VARCHAR2(20) NOT NULL,
	DATA_ATUALIZACAO DATE NOT NULL,
    CONSTRAINT FK_AUDIT1 FOREIGN KEY (COD_EMPRESA,MATRICULA) REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA)
);

--ADD CAMPO LOGIN TABELA APONTAMENTOS CRIACAO APOS TABELA USUARIOS E FK
  ALTER TABLE APONTAMENTOS ADD LOGIN VARCHAR2(30)NOT NULL;
 
  ALTER TABLE APONTAMENTOS ADD LOTE VARCHAR2(20) NOT NULL;
  --REMOVENDO CONSTRAINT PARA TESTE
  ALTER TABLE CONSUMO DROP CONSTRAINT  FK_CONS2;
  --ALTER TABLE APONTAMENTOS DROP CONSTRAINT  FK_APONT3

--ADD CAMPO LOGIN TABELA ESTOQUE_MOV  CRIACAO APOS TABELA USUARIO
  ALTER TABLE ESTOQUE_MOV ADD LOGIN VARCHAR2(30)NOT NULL;
  
 

--ALTERAR  COD_PAGTO TAB PED_COMPRAS PARA FOREIGN KEY APOS TABELA COND_PAGTO
  ALTER TABLE PED_COMPRAS ADD 
  FOREIGN KEY (COD_PAGTO) REFERENCES COND_PAGTO(COD_PAGTO);

  
 
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
94.Criando as Tabelas Parte 2

--SUPRIMENTOS
--CRIACAO DA TABELA 
CREATE TABLE ESTOQUE
	(
    COD_EMPRESA INT NOT NULL,
    COD_MAT INT NOT NULL,
	QTD_SALDO DECIMAL(10,2) NOT NULL,
	CONSTRAINT FK_EST1 FOREIGN KEY (COD_EMPRESA,COD_MAT) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT),
    CONSTRAINT PK_ESTOQUE1 PRIMARY KEY (COD_EMPRESA,COD_MAT)
	);
    
--DROP TABLE ESTOQUE_LOTE
--CRIACAO TABELAS ESTOQUE_LOTE
CREATE TABLE ESTOQUE_LOTE
	(
    COD_EMPRESA INT NOT NULL,
	COD_MAT INT NOT NULL,
	LOTE VARCHAR2(20) NOT NULL,
	QTD_LOTE DECIMAL(10,2) NOT NULL,
	CONSTRAINT PK_ESTL1 PRIMARY KEY (COD_EMPRESA,COD_MAT,LOTE), --PK COMPOSTA
	CONSTRAINT FK_ESTL1 FOREIGN KEY (COD_EMPRESA,COD_MAT) 
	REFERENCES MATERIAL(COD_EMPRESA,COD_MAT)
	);
--CRIACAO TABELA MOV ESTOQUE
--DROP TABLE ESTOQUE_MOV
	CREATE TABLE ESTOQUE_MOV
	(
	ID_MOV INT  NOT NULL PRIMARY KEY,
    COD_EMPRESA INT NOT NULL,
	TIP_MOV VARCHAR2(1),CONSTRAINT CK_MOV CHECK (TIP_MOV in ('S','E')), --S=SAIDA ,E=ENTRADA
	COD_MAT INT NOT NULL,
	LOTE  VARCHAR2(20) NOT NULL,
	QTD DECIMAL(10,2) NOT NULL,
	DATA_MOV DATE NOT NULL,
	DATA_HORA DATE NOT NULL,
	CONSTRAINT FK_ESTM1 FOREIGN KEY (COD_EMPRESA,COD_MAT) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT)
	--CAMPO LOGIN TABELA ESTOQUE_MOV CRIACAO APOS TABELA USUARIO
	);
    
    
-- CRIANDO SEQUENCIA PARA TABELA ESTOQUE_MOV
CREATE SEQUENCE SEQ_MOVEST START WITH 1 INCREMENT BY 1 NOMAXVALUE;
--CRIACAO TABELAS PED_COMPRAS
--DROP TABLE PED_COMPRAS	
CREATE TABLE PED_COMPRAS
	(
    COD_EMPRESA INT NOT NULL,
	NUM_PEDIDO INT  NOT NULL,
	ID_FOR INT NOT NULL,
	COD_PAGTO INT NOT NULL, --ALTERAR  COD_PAGTO TAB PED_COMPRAS PARA FOREIGN KEY APOS TABELA COND_PAGTO  	
	DATA_PEDIDO DATE NOT NULL,
	DATA_ENTREGA DATE NOT NULL,
	SITUACAO NCHAR(1) NOT NULL, --A-ABERTO P-PLANEJADO -F FINALIZADO
	TOTAL_PED DECIMAL(10,2),
	CONSTRAINT FK_PEDC1 FOREIGN KEY (ID_FOR) REFERENCES FORNECEDORES(ID_FOR),
    CONSTRAINT PK_PEDC1 PRIMARY KEY (COD_EMPRESA,NUM_PEDIDO)
	);
    
    -- CRIACAO DE TABELA DE PARAMETROS DE NUMEROS DE PEDIDO POR EMPRESA
    CREATE TABLE PARAM_PED_COMPRAS
    (
     COD_EMPRESA INT NOT NULL PRIMARY KEY,
     NUM_PED INT NOT NULL,
     CONSTRAINT FK_PPC FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
     );
     
--CRIACAO DA TABELA PEDIDO COMPRAS
CREATE TABLE PED_COMPRAS_ITENS
	(
    COD_EMPRESA INT NOT NULL,
	NUM_PEDIDO INT NOT NULL,
	SEQ_MAT INT NOT NULL,
	COD_MAT INT NOT NULL,
	QTD     INT NOT NULL,
	VAL_UNIT DECIMAL(10,2) NOT NULL,
	CONSTRAINT FK_PEDIT1 FOREIGN KEY (COD_EMPRESA,NUM_PEDIDO) REFERENCES PED_COMPRAS(COD_EMPRESA,NUM_PEDIDO),
	CONSTRAINT FK_PEDIT2 FOREIGN KEY (COD_EMPRESA,COD_MAT) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT),
    CONSTRAINT PK_PED_C_IT PRIMARY KEY (COD_EMPRESA,NUM_PEDIDO,SEQ_MAT)
	);
	

--RH
--CRIACAO TABELAS CENTRO DE CUSTO
CREATE TABLE CENTRO_CUSTO
	(
    COD_EMPRESA INT NOT NULL,
	COD_CC VARCHAR2(4) NOT NULL,
	NOME_CC VARCHAR2(20) NOT NULL,
    CONSTRAINT FK_CC1  FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA),
    CONSTRAINT PK_CC1 PRIMARY KEY (COD_EMPRESA,COD_CC)
	);

--CRIACAO TABELAS CARGOS]
-- AVALIAR CENARIOS 
CREATE TABLE CARGOS 
	(COD_EMPRESA INT NOT NULL,
     COD_CARGO INT  NOT NULL,
	 NOME_CARGO VARCHAR2(50),
     CONSTRAINT FK_CARG1  FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA),
     CONSTRAINT PK_CARG1 PRIMARY KEY (COD_EMPRESA,COD_CARGO)
	 );
     
--CRIACAO TABELA FUNCIONARIO
CREATE TABLE FUNCIONARIO 
	(
    COD_EMPRESA INT NOT NULL,
	MATRICULA INT NOT NULL ,
	COD_CC VARCHAR2(4) NOT NULL,
	NOME   VARCHAR2(50) NOT NULL,
	RG     VARCHAR2(15) NOT NULL,
	CPF    VARCHAR2(15) NOT NULL,
	ENDERECO  VARCHAR2(50)NOT NULL,
	NUMERO VARCHAR2(10) NOT NULL,
	BAIRRO VARCHAR2(50) NOT NULL,
	COD_CIDADE VARCHAR2(7) NOT NULL,
	DATA_ADMISS DATE NOT NULL,
	DATE_DEMISS DATE,
	DATA_NASC DATE NOT NULL,
	TELEFONE VARCHAR2(15) NOT NULL,
	COD_CARGO INT NOT NULL,
	CONSTRAINT FK_FUNC1 FOREIGN KEY (COD_EMPRESA,COD_CC) REFERENCES CENTRO_CUSTO(COD_EMPRESA,COD_CC),
	CONSTRAINT FK_FUNC2 FOREIGN KEY (COD_CIDADE) REFERENCES CIDADES(COD_CIDADE),
	CONSTRAINT FK_FUNC3 FOREIGN KEY (COD_EMPRESA,COD_CARGO) REFERENCES CARGOS(COD_EMPRESA,COD_CARGO),
    CONSTRAINT PK_FUNC1 PRIMARY KEY(COD_EMPRESA,MATRICULA)
    );

-- TABELAS DE PARAMETROS DE MATRICULA POR EMPRESA
 CREATE TABLE PARAM_MATRICULA
  (
   COD_EMPRESA INT NOT NULL PRIMARY KEY,
   MATRICULA INT NOT NULL,
   CONSTRAINT FK_PMAT1 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
   );

--CRIACAO TABELA SALARIO
CREATE TABLE SALARIO
	(
    COD_EMPRESA INT NOT NULL,
	MATRICULA INT NOT NULL,
	SALARIO DECIMAL(10,2)NOT NULL,
	CONSTRAINT FK_SAL1 FOREIGN KEY (COD_EMPRESA,MATRICULA) REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA),
    CONSTRAINT PK_SAL1 PRIMARY KEY (COD_EMPRESA,MATRICULA) 
    );
    
--CRIACAO TABLE FOLHA DE PAGTO
--DROP TABLE FOLHA_PAGTO
CREATE TABLE FOLHA_PAGTO
	(
    COD_EMPRESA INT NOT NULL,
	MATRICULA INT NOT NULL,
	TIPO_PGTO CHAR(1) NOT NULL,-- (M-FOLHA,A-ADTO,F-FERIAS,D-13º,R-RESC),
	TIPO CHAR(1)  NOT NULL,--P=PROVENTOS D-DESCONTO
	EVENTO VARCHAR2(30) NOT NULL, 
	MES_REF VARCHAR2(2)NOT NULL,
	ANO_REF VARCHAR2(4)NOT NULL,
	DATA_PAGTO DATE NOT NULL,
	VALOR DECIMAL(10,2) NOT NULL,
    CONSTRAINT FK_FP1 FOREIGN KEY (COD_EMPRESA,MATRICULA) REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA)
	);
    
-- CRIANDO INDEX PARA OTIMARIZAR CONSULTAS
CREATE INDEX IX1_FPAG ON FOLHA_PAGTO(COD_EMPRESA,MES_REF,ANO_REF);



--SEGURANCA
--CRIACAO TA TABELAS USARIOS 
CREATE TABLE USUARIOS
	(
    COD_EMPRESA INT NOT NULL,
	LOGIN VARCHAR2(30) NOT NULL ,
	MATRICULA INT NOT NULL,
	SENHA   VARCHAR2(32) NOT NULL,
	SITUACAO CHAR(1) NOT NULL, --A=ATIVO -B BLOQUEADO
	CONSTRAINT FK_US1 FOREIGN KEY (COD_EMPRESA,MATRICULA) 
	REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA),
    CONSTRAINT PK_USER PRIMARY KEY(COD_EMPRESA,MATRICULA)
	);
    
-- CRIANDO INDEX UNIQUE PARA LOGIN
CREATE UNIQUE INDEX IX1_USER ON USUARIOS (LOGIN);


--FINANCEIRO
--CRIACAO TABELA CONTAS A RECEBER
CREATE TABLE CONTAS_RECEBER
	(
    COD_EMPRESA INT NOT NULL,
	ID_DOC INT  NOT NULL PRIMARY KEY,
    ID_CLIENTE INT NOT NULL,
	ID_DOC_ORIG INT NOT NULL, --ALTER CAMPO ID_DOC_ORIG PARA FK TABELA NOTA_FISCAL
	PARC INT NOT NULL,
	DATA_VENC DATE NOT NULL,
	DATA_PAGTO DATE,
	VALOR DECIMAL(10,2),
	CONSTRAINT FK_CR1 FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTES(ID_CLIENTE),
    CONSTRAINT FK_CR2 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
	);
    
-- CRIANDO SEQUENCIA PARA TABELA CONTAS_RECEBER
CREATE SEQUENCE SEQ_CRE START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--CRIACAO TABELA CONTAS A PAGAR
--DROP TABLE CONTAS_PAGAR
CREATE TABLE CONTAS_PAGAR
	(
    COD_EMPRESA INT NOT NULL,
	ID_DOC INT  NOT NULL PRIMARY KEY,
    ID_FOR INT NOT NULL,
	ID_DOC_ORIG INT NOT NULL, --ALTER CAMPO ID_DOC_ORIG PARA FK TABELA NOTA_FISCAL
	PARC INT NOT NULL,
	DATA_VENC DATE NOT NULL,
	DATA_PAGTO DATE ,
	VALOR DECIMAL(10,2),
	CONSTRAINT FK_CP1 FOREIGN KEY (ID_FOR) REFERENCES FORNECEDORES(ID_FOR),
    CONSTRAINT FK_CP2 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
	);
    
-- CRIANDO SEQUENCIA PARA TABELA CONTAS_PAGAR
CREATE SEQUENCE SEQ_CAP START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--CRIACAO TABELA CONDIÇÕES DE PAGTO
CREATE TABLE COND_PAGTO
	(
	COD_PAGTO INT  NOT NULL PRIMARY KEY,
	NOME_CP VARCHAR2(50) NOT NULL 
	);
    
-- CRIANDO SEQUENCIA PARA TABELA COND_PAGTO
CREATE SEQUENCE SEQ_PAGTO START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--CRIACAO DA TABELAS DETALHES DE CONDICAO DE PAGTO COM PARCELA
CREATE TABLE COND_PAGTO_DET
	(
	COD_PAGTO INT NOT NULL,
	PARC     INT NOT NULL,
	DIAS     INT NOT NULL,
	PCT  DECIMAL(10,2)NOT NULL,--PERCENTUAL DA PARCELA
	CONSTRAINT FK_CONDP1 FOREIGN KEY (COD_PAGTO) 
	REFERENCES COND_PAGTO(COD_PAGTO)
	);

--COMERCIAL
--CRIACAO TABELA PEDIDO DE VENDAS
CREATE TABLE PED_VENDAS
	(
    COD_EMPRESA INT NOT NULL,
	NUM_PEDIDO INT  NOT NULL,
	ID_CLIENTE INT NOT NULL,
	COD_PAGTO INT NOT NULL, 
	DATA_PEDIDO DATE NOT NULL,
	DATA_ENTREGA DATE NOT NULL,
	SITUACAO NCHAR(1) NOT NULL, --A-ABERTO P-PLANEJADO -F FINALIZADO
	TOTAL_PED DECIMAL(10,2),
	CONSTRAINT FK_PV1 FOREIGN KEY (ID_CLIENTE)REFERENCES CLIENTES(ID_CLIENTE),
	CONSTRAINT FK_PV2 FOREIGN KEY (COD_PAGTO) REFERENCES COND_PAGTO(COD_PAGTO),
    CONSTRAINT FK_PV3 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA),
    CONSTRAINT PK_PV1 PRIMARY KEY(COD_EMPRESA,NUM_PEDIDO)
	);
    
   -- CRIACAO DE TABELA DE PARAMETROS DE NUMEROS DE PEDIDO DE VENDAS POR EMPRESA
    CREATE TABLE PARAM_PED_VENDAS
    (
     COD_EMPRESA INT NOT NULL PRIMARY KEY,
     NUM_PED INT NOT NULL,
     CONSTRAINT FK_PV FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
     );
    
--CRIACAO DA TABELA PEDIDO VENDAS ITENS
--DROP TABLE PED_VENDAS_ITENS
CREATE TABLE PED_VENDAS_ITENS
	(
    COD_EMPRESA INT NOT NULL,
	NUM_PEDIDO INT NOT NULL,
	SEQ_MAT INT NOT NULL,
	COD_MAT INT NOT NULL,
	QTD     INT NOT NULL,
	VAL_UNIT DECIMAL(10,2) NOT NULL,
	CONSTRAINT FK_PVIT1 FOREIGN KEY (COD_EMPRESA,NUM_PEDIDO) REFERENCES PED_VENDAS(COD_EMPRESA,NUM_PEDIDO),
    CONSTRAINT FK_PVIT2 FOREIGN KEY (COD_EMPRESA,COD_MAT) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT)
	);

--CRIACAO TABELAS VENDEDORES
--DROP TABLE VENDEDORES
CREATE TABLE VENDEDORES
    (
     COD_EMPRESA INT NOT NULL,
     ID_VEND INT NOT NULL,
	 MATRICULA INT NOT NULL,
 	 CONSTRAINT FK_VEND1 FOREIGN KEY (COD_EMPRESA,MATRICULA) REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA),
     CONSTRAINT PK_VEND1 PRIMARY KEY (COD_EMPRESA,MATRICULA)
	 );
    
-- CRIANDO SEQUENCIA PARA COD DO VENDEDOR
CREATE SEQUENCE SEQ_VENDEDORES START WITH 1 INCREMENT BY 1 NOMAXVALUE;
    
--CRIACAO DE TAB GERENTES DE VENDAS
CREATE TABLE GERENTES
    ( COD_EMPRESA INT NOT NULL,
      ID_GER INT  NOT NULL,
	  MATRICULA INT NOT NULL,
 	CONSTRAINT FK_GER1 FOREIGN KEY (COD_EMPRESA,MATRICULA) REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA),
    CONSTRAINT PK_GER1 PRIMARY KEY (COD_EMPRESA,MATRICULA)
	 );
     
    
-- CRIANDO SEQUENCIA PARA COD DO VENDEDOR
CREATE SEQUENCE SEQ_GERENTES START WITH 1 INCREMENT BY 1 NOMAXVALUE;

--CANAL DE VENDAS RELACIONA GERENTE COM VENDEDOR
CREATE TABLE CANAL_VENDAS_G_V
	(
    COD_EMPRESA INT NOT NULL,
	ID_GER INT NOT NULL,
	ID_VEND INT NOT NULL,
    CONSTRAINT FK_CGV3 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
	);
    

--CANAL DE VENDAS RELACIONA VENDEDOR COM CLIENTE
--DROP TABLE CANAL_VENDAS_V_C
CREATE TABLE CANAL_VENDAS_V_C
	(
    COD_EMPRESA INT NOT NULL,
	ID_VEND INT NOT NULL,
	ID_CLIENTE INT NOT NULL,
	CONSTRAINT FK_CVC2 FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTES(ID_CLIENTE),
    CONSTRAINT FK_CCV1 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA) 
	);
    
--CRIACAO DE TABELA PARA REGISTRA META DE VENDAS MES A MES/ANO
CREATE TABLE META_VENDAS
	(
    COD_EMPRESA INT NOT NULL,
	ID_VEND INT NOT NULL,
	ANO VARCHAR2(4) NOT NULL,
	MES VARCHAR2(2) NOT NULL,
	VALOR DECIMAL(10,2),
	CONSTRAINT FK_MV1 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
	);


--FISCAL
--CRIACAO DA TABELA DOS CODIGO DE OPERACOES FISCAIS
--DROP TABLE CFOP
	CREATE TABLE CFOP
	(
	COD_CFOP VARCHAR2(5) NOT NULL PRIMARY KEY,
	DESC_CFOP VARCHAR2(255) NOT NULL
	);
    
--CRIACAO DA TABELA NOTA_FISCAL
--DROP TABLE NOTA_FISCAL
--DROP TABLE NOTA_FISCAL_ITENS
CREATE TABLE NOTA_FISCAL
	(
    COD_EMPRESA INT NOT NULL,
	NUM_NF INT NOT NULL,
	TIP_NF CHAR(1) NOT NULL, --E ENTRADA, S- SAIDA
	COD_CFOP VARCHAR2(5) NOT NULL,
	ID_CLIFOR INT NOT NULL,
	COD_PAGTO INT NOT NULL, 
	DATA_EMISSAO DATE NOT NULL,
	DATA_ENTREGA DATE NOT NULL,
	TOTAL_NF DECIMAL(10,2),
	INTEGRADA_FIN CHAR(1) DEFAULT('N'), -- N, Nasce padrao pq ainda n esta integrada c contas a pagar ou receber 
	INTEGRADA_SUP CHAR(1) DEFAULT('N'),
	CONSTRAINT FK_NF1 FOREIGN KEY (COD_CFOP) REFERENCES CFOP(COD_CFOP),
	CONSTRAINT FK_NF2 FOREIGN KEY (COD_PAGTO) REFERENCES COND_PAGTO(COD_PAGTO),
    CONSTRAINT PK_NF1 PRIMARY KEY (COD_EMPRESA,NUM_NF)
	);
    
--CRIACAO DA TABELA NOTA_FISCAL_ITENS
CREATE TABLE NOTA_FISCAL_ITENS
	(
    COD_EMPRESA INT NOT NULL,
	NUM_NF INT NOT NULL,
	SEQ_MAT INT NOT NULL,
	COD_MAT INT NOT NULL,
	QTD     INT NOT NULL,
	VAL_UNIT DECIMAL(10,2) NOT NULL,
	PED_ORIG  INT NOT NULL,
	CONSTRAINT FK_NFIT1 FOREIGN KEY (COD_EMPRESA,NUM_NF) REFERENCES NOTA_FISCAL(COD_EMPRESA,NUM_NF),
	CONSTRAINT FK_NFIT2 FOREIGN KEY (COD_EMPRESA,COD_MAT) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT)
	);
    
    --CRIACAO TABELAS PARAMETRO NUMERACAO NFE

    CREATE TABLE PARAM_NFE
    (
     COD_EMPRESA INT NOT NULL PRIMARY KEY,
     NUM_NFE INT NOT NULL,
     CONSTRAINT FK_NFE1 FOREIGN KEY (COD_EMPRESA) REFERENCES EMPRESA(COD_EMPRESA)
     );
    


--CRIACAO TABELAS PARAMETRO DE INSS

CREATE TABLE PARAM_INSS
(
 VIGENCIA_INI DATE,
 VIGENCIA_FIM DATE,
 VALOR_DE DECIMAL(10,2) NOT NULL,
 VALOR_ATE DECIMAL(10,2) NOT NULL,
 PCT DECIMAL(10,2) NOT NULL
 );

--CRIACAO DE TABELAS DE PARAMETRO DO IRRF
CREATE TABLE PARAM_IRRF
(
 VIGENCIA_INI DATE,
 VIGENCIA_FIM DATE,
 VALOR_DE DECIMAL(10,2) NOT NULL,
 VALOR_ATE DECIMAL(10,2) NOT NULL,
 PCT DECIMAL(10,2) NOT NULL,
 VAL_ISENT DECIMAL(10,2)
 );


 --CRIACAO TABELAS AUDIT SALARIO
 CREATE TABLE AUDITORIA_SALARIO
 (  
    COD_EMPRESA INT NOT NULL,
	MATRICULA INT NOT NULL,
	SAL_ANTES DECIMAL(10, 2) NOT NULL,
	SAL_DEPOIS DECIMAL(10, 2) NOT NULL,
	USUARIO VARCHAR2(20) NOT NULL,
	DATA_ATUALIZACAO DATE NOT NULL,
    CONSTRAINT FK_AUDIT1 FOREIGN KEY (COD_EMPRESA,MATRICULA) REFERENCES FUNCIONARIO(COD_EMPRESA,MATRICULA)
);

--ADD CAMPO LOGIN TABELA APONTAMENTOS CRIACAO APOS TABELA USUARIOS E FK
  ALTER TABLE APONTAMENTOS ADD LOGIN VARCHAR2(30)NOT NULL;
 
  ALTER TABLE APONTAMENTOS ADD LOTE VARCHAR2(20) NOT NULL;
  
  --REMOVENDO CONSTRAINT PARA TESTE
  ALTER TABLE CONSUMO DROP CONSTRAINT  FK_CONS2;
  --ALTER TABLE APONTAMENTOS DROP CONSTRAINT  FK_APONT3

--ADD CAMPO LOGIN TABELA ESTOQUE_MOV  CRIACAO APOS TABELA USUARIO
  ALTER TABLE ESTOQUE_MOV ADD LOGIN VARCHAR2(30)NOT NULL;
  
 

--ALTERAR  COD_PAGTO TAB PED_COMPRAS PARA FOREIGN KEY APOS TABELA COND_PAGTO
  ALTER TABLE PED_COMPRAS ADD 
  FOREIGN KEY (COD_PAGTO) REFERENCES COND_PAGTO(COD_PAGTO);


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
95.Triggers de Autonumeração


 -- TRIGGER PARA SEQUENCIAS 
  -- PARA TABELA EMPRESA
    
CREATE OR REPLACE TRIGGER TRG_EMPRESA1 
    BEFORE INSERT ON EMPRESA 
    FOR EACH ROW  
        BEGIN 
        IF :NEW.COD_EMPRESA IS NULL THEN 
            SELECT SEQ_EMP.NEXTVAL INTO :NEW.COD_EMPRESA FROM DUAL; 
        END IF; 
    END; 


 -- PARA TABELA APONTAMENTO
    
CREATE OR REPLACE TRIGGER TRG_APONT 
    BEFORE INSERT ON APONTAMENTOS
    FOR EACH ROW  
        BEGIN 
        IF :NEW.ID_APON IS NULL THEN 
            SELECT SEQ_APON.NEXTVAL INTO :NEW.ID_APON FROM DUAL; 
        END IF; 
    END; 


 -- PARA TABELA CONTAS A PAGAR
    
CREATE OR REPLACE TRIGGER TRG_CAP 
    BEFORE INSERT ON CONTAS_PAGAR
    FOR EACH ROW  
        BEGIN 
        IF :NEW.ID_DOC IS NULL THEN 
            SELECT SEQ_CAP.NEXTVAL INTO :NEW.ID_DOC FROM DUAL; 
        END IF; 
    END; 



-- PARA TABELA CLIENTES
--SEQ_CLI        CAMPO ID_CLIENTE    
CREATE OR REPLACE TRIGGER TRG_CLIENTE 
    BEFORE INSERT ON CLIENTES
    FOR EACH ROW  
        BEGIN 
        IF :NEW.ID_CLIENTE IS NULL THEN 
            SELECT SEQ_CLI.NEXTVAL INTO :NEW.ID_CLIENTE FROM DUAL; 
        END IF; 
    END; 



-- PARA TABELA CONTAS RECEBER
--SEQ_CRE        CAMPO ID_DOC  
CREATE OR REPLACE TRIGGER TRG_CRE 
    BEFORE INSERT ON CONTAS_RECEBER
    FOR EACH ROW  
        BEGIN 
        IF :NEW.ID_DOC IS NULL THEN 
            SELECT SEQ_CRE.NEXTVAL INTO :NEW.ID_DOC FROM DUAL; 
        END IF; 
    END; 

--SEQUENCIA PARA TABELAS FORNECEDOR
--SEQ_FOR        CAMPO ID_FOR
CREATE OR REPLACE TRIGGER TRG_FOR 
    BEFORE INSERT ON FORNECEDORES
    FOR EACH ROW  
        BEGIN 
        IF :NEW.ID_FOR IS NULL THEN 
            SELECT SEQ_FOR.NEXTVAL INTO :NEW.ID_FOR FROM DUAL; 
        END IF; 
    END; 

--SEQUENCIA PARA TABELA GERENTES
--SEQ_GERENTES   CAMPO ID_GER
CREATE OR REPLACE TRIGGER TRG_GER 
    BEFORE INSERT ON GERENTES
    FOR EACH ROW  
        BEGIN 
        IF :NEW.ID_GER IS NULL THEN 
            SELECT SEQ_GERENTES.NEXTVAL INTO :NEW.ID_GER FROM DUAL; 
        END IF; 
    END; 

-- SEQUENCIA PARA TABELA ESTOQUE MOV
--SEQ_MOVEST     CAMPO ID_MOV
CREATE OR REPLACE TRIGGER TRG_MOVEST 
    BEFORE INSERT ON ESTOQUE_MOV
    FOR EACH ROW  
        BEGIN 
        IF :NEW.ID_MOV IS NULL THEN 
            SELECT SEQ_MOVEST.NEXTVAL INTO :NEW.ID_MOV FROM DUAL; 
        END IF; 
    END; 

--SEQUENCIA PARA ORDEM DE PRODUCAO
--SEQ_OP         CAMPO ID_ORDEM
CREATE OR REPLACE TRIGGER TRG_OP 
    BEFORE INSERT ON ORDEM_PROD
    FOR EACH ROW  
        BEGIN 
        IF :NEW.ID_ORDEM IS NULL THEN 
            SELECT SEQ_OP.NEXTVAL INTO :NEW.ID_ORDEM FROM DUAL; 
        END IF; 
    END; 

--SEQUENCIA PARA CONDIÇÃO DE PAGAMENTO
--SEQ_PAGTO      CAMPO COD_PAGTO
CREATE OR REPLACE TRIGGER TRG_COD_PAGTO 
    BEFORE INSERT ON COND_PAGTO
    FOR EACH ROW  
        BEGIN 
        IF :NEW.COD_PAGTO IS NULL THEN 
            SELECT SEQ_PAGTO.NEXTVAL INTO :NEW.COD_PAGTO FROM DUAL; 
        END IF; 
    END; 

--SEQUENCIA PARA TIPO DE MATERIAL
--SEQ_TIP_MAT    CAMPO COD_TIP_MAT
CREATE OR REPLACE TRIGGER TRG_COD_TIP_MAT 
    BEFORE INSERT ON TIPO_MAT
    FOR EACH ROW  
        BEGIN 
        IF :NEW.COD_TIP_MAT IS NULL THEN 
            SELECT SEQ_TIP_MAT.NEXTVAL INTO :NEW.COD_TIP_MAT FROM DUAL; 
        END IF; 
    END; 

--SEQ_VENDEDORES CAMPO ID_VEND
CREATE OR REPLACE TRIGGER TRG_VENDEDOR 
    BEFORE INSERT ON VENDEDORES
    FOR EACH ROW  
        BEGIN 
        IF :NEW.ID_VEND IS NULL THEN 
            SELECT SEQ_VENDEDORES.NEXTVAL INTO :NEW.ID_VEND FROM DUAL; 
        END IF; 
    END; 


-- CRIAR TRIGGER PARA NUMERACAO DE NFE
    
CREATE OR REPLACE TRIGGER TRG_NUM_NFE 
    BEFORE INSERT ON NOTA_FISCAL 
    FOR EACH ROW 
     BEGIN 
         UPDATE PARAM_NFE SET NUM_NFE=NUM_NFE+1 WHERE COD_EMPRESA=:NEW.COD_EMPRESA;
         SELECT NUM_NFE INTO :NEW.NUM_NF  FROM PARAM_NFE WHERE COD_EMPRESA=:NEW.COD_EMPRESA; 
    END; 

-- CRIAR TRIGGER PARA PARAMETROS PEDIDO DE COMPRAS

CREATE OR REPLACE TRIGGER TRG_NUM_PED_COMPRAS 
    BEFORE INSERT ON PED_COMPRAS 
    FOR EACH ROW 
     BEGIN 
         UPDATE PARAM_PED_COMPRAS SET NUM_PED=NUM_PED+1 WHERE COD_EMPRESA=:NEW.COD_EMPRESA;
         SELECT NUM_PED INTO :NEW.NUM_PEDIDO  FROM PARAM_PED_COMPRAS WHERE COD_EMPRESA=:NEW.COD_EMPRESA; 
    END; 
    
-- CRIAR TRIGGER PARA PARAMETROS PEDIDO DE VENDAS
--DROP TRIGGER TRG_NUM_PED_VENDAS
CREATE OR REPLACE TRIGGER TRG_NUM_PED_VENDAS 
    BEFORE INSERT ON PED_VENDAS 
    FOR EACH ROW 
     BEGIN 
         UPDATE PARAM_PED_VENDAS SET NUM_PED=NUM_PED+1 WHERE COD_EMPRESA=:NEW.COD_EMPRESA;
         SELECT NUM_PED INTO :NEW.NUM_PEDIDO  FROM PARAM_PED_VENDAS WHERE COD_EMPRESA=:NEW.COD_EMPRESA; 
    END; 

-- CRIAR TRIGGER PARA PARAMETROS MATRICULA FUNCIONARIOS
CREATE OR REPLACE TRIGGER TRG_MAT_FUNC 
    BEFORE INSERT ON FUNCIONARIO
    FOR EACH ROW 
     BEGIN 
         UPDATE PARAM_MATRICULA SET MATRICULA=MATRICULA+1 WHERE COD_EMPRESA=:NEW.COD_EMPRESA;
         SELECT MATRICULA INTO :NEW.MATRICULA  FROM PARAM_MATRICULA WHERE COD_EMPRESA=:NEW.COD_EMPRESA; 
    END; 

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
96.Cargas de Tabela Parte 1

-- CARGA EMPRESA
INSERT INTO EMPRESA (NOME_EMPRESA,FANTASIA) VALUES ('COMPANY BIKE','BIKES');
INSERT INTO EMPRESA (NOME_EMPRESA,FANTASIA) VALUES ('COMPANY CAR','CARS');

-- VERFICANDO 
SELECT * FROM EMPRESA;

--CARGA PARAMETRO NFE
INSERT INTO PARAM_NFE (COD_EMPRESA,NUM_NFE) VALUES (1,0);
INSERT INTO PARAM_NFE (COD_EMPRESA,NUM_NFE) VALUES (2,0);

--VERFICANDO PARAM_NFE
SELECT * FROM PARAM_NFE;

--CARGA PARAMETRO PARAM_PED_COMPRAS
INSERT INTO PARAM_PED_COMPRAS (COD_EMPRESA,NUM_PED) VALUES (1,0);
INSERT INTO PARAM_PED_COMPRAS (COD_EMPRESA,NUM_PED) VALUES (2,0);


--VERFICANDO PARAM_PED_COMPRAS
SELECT * FROM PARAM_PED_COMPRAS;


--CARGA PARAMETRO PARAM_PED_COMPRAS
INSERT INTO PARAM_PED_VENDAS (COD_EMPRESA,NUM_PED) VALUES (1,0);
INSERT INTO PARAM_PED_VENDAS (COD_EMPRESA,NUM_PED) VALUES (2,0);


--VERFICANDO PARAM_PED_COMPRAS
SELECT * FROM PARAM_PED_VENDAS;

--CARGA PARAMETRO PARAM_MATRICULA
INSERT INTO PARAM_MATRICULA (COD_EMPRESA,MATRICULA) VALUES (1,0);
INSERT INTO PARAM_MATRICULA (COD_EMPRESA,MATRICULA) VALUES (2,0);


--VERFICANDO PARAM_MATRICULA
SELECT * FROM PARAM_MATRICULA;

--CARGA UF
--SELECT * FROM UF

INSERT INTO  UF
SELECT DISTINCT a.COD_UF, a.SIGLA_UF, a.ESTADO
	FROM ALUNO.UF a;

--delete from UF
    
--VERIFICANDO CARGAS
SELECT * FROM UF

--CARGA TABELA CIDADES
--select * from CIDADES
INSERT INTO CIDADES
SELECT distinct x.cod_mun, x.cod_uf, x.nome_mun  FROM ALUNO.SENSO x;


--CARGA TABELAS CLIENTES
--select * from clientes
INSERT INTO CLIENTES VALUES 
	(1,null,'CARLOS JACOB HOUSTON','CARLOS','RUA 1','375','SANTA HELENA','4203709','13290000','123456987','F',SYSDATE,1);
INSERT INTO CLIENTES VALUES 
	(1,null,'PEDRO LARSON OHIO','PEDRO','RUA 2','235','SANTA CLARA','4119608','13290987','123456989','F',SYSDATE,2);
INSERT INTO CLIENTES VALUES 
	(2,null,'BIKES ON LTDA','BIKES ON','RUA 14','279','MONTANHA','5300108','13293245','343456987','J',SYSDATE,3);
INSERT INTO CLIENTES VALUES 
	(2,null,'MY BIKE MY LIFE SA','BIKE LIFE','RUA 23','675','ALPES','3509502','13379245','11290340','J',SYSDATE,3);

--CARGA TABELAS FORNECEDORES	
--SELECT * FROM FORNECEDORES
INSERT INTO  FORNECEDORES VALUES
	(1,null,'SO BIKES LTDA','SO BIKES','RUA 10','375','SANTA HILDA','4203709','13290000','123456987','J',SYSDATE,1);
INSERT INTO  FORNECEDORES VALUES
	(1,null,'ESPECIAL BIKES LTDA','ESPECIAL BIKES','RUA 2','235','SANTA GENEBRA','4119608','13290987','123456989','J',SYSDATE,2);
INSERT INTO  FORNECEDORES VALUES
	(2,null,'MONTA BIKES ME','MONTA BIKES','RUA 67','345','ALADO','5300108','13293245','343456987','J',SYSDATE,3);
INSERT INTO  FORNECEDORES VALUES
	(2,null,'TREK BIKES ME','TREK BIKES','RUA 14','325','SANTA FE','3512704','13293245','343456987','J',SYSDATE,3);

--CARGA TABELA TIPO DE MATERIAL
--SELECT * FROM TIPO_MAT
INSERT INTO TIPO_MAT (DESC_TIP_MAT) VALUES ('MATERIA PRIMA');
INSERT INTO TIPO_MAT (DESC_TIP_MAT) VALUES('PRODUDO ACABADO');
INSERT INTO TIPO_MAT (DESC_TIP_MAT) VALUES('EMBALAGEM');
INSERT INTO TIPO_MAT (DESC_TIP_MAT) VALUES('CONSUMO');

--CARGA MATERIAL
--COD TIPO MAT
/* 
1	MATERIA PRIMA
2	PRODUDO ACABADO
3	EMBALAGEM
4	CONSUMO
*/
--SELECT * FROM MATERIAL
--DELETE FROM MATERIAL

INSERT INTO MATERIAL VALUES	(1,1,'BICICLETA ARO 29 PRETA MOD INFINITY','2500','2');
INSERT INTO MATERIAL VALUES (1,2,'BICICLETA ARO 29 BRANCA MOD INFINITY','2500','2');
INSERT INTO MATERIAL VALUES (1,3,'QUADRO ARO 29','500','1');
INSERT INTO MATERIAL VALUES (1,4,'KIT TRANSMISSAO','500','1');--FREIO+MARCHA-PEDEVELA-TROCADORES+K-7
INSERT INTO MATERIAL VALUES	(1,5,'ARO 29','70','1');
INSERT INTO MATERIAL VALUES (1,6,'PNEU 29','100','1');
INSERT INTO MATERIAL VALUES (1,7,'CAMARA 29','25','1');
INSERT INTO MATERIAL VALUES (1,8,'SUSPENSAO DIANTEIRA','250','1');
INSERT INTO MATERIAL VALUES (1,9,'BANCO','80','1');
INSERT INTO MATERIAL VALUES (1,10,'CANOTE','35','1');
INSERT INTO MATERIAL VALUES (1,11,'TINTA BRANCA','10','1');
INSERT INTO MATERIAL VALUES (1,12,'TINTA PRETA','10','1');
INSERT INTO MATERIAL VALUES (1,13,'MESA','500','1');
INSERT INTO MATERIAL VALUES (1,14,'GUIDON','50','1');
INSERT INTO MATERIAL VALUES (1,15,'LUVAS','30','1');
INSERT INTO MATERIAL VALUES (1,16,'CAIXA EMBALAGEM','10','3');
    
    
-- MAT_FORNEC
--SELECT * FROM FICHA_TECNICA
--FICHA TENICA BIKE PRETA	

INSERT INTO FICHA_TECNICA VALUES (1,'1','3',1);
INSERT INTO FICHA_TECNICA VALUES (1,'1','4',1);
INSERT INTO FICHA_TECNICA VALUES (1,'1','5',2);
INSERT INTO FICHA_TECNICA VALUES (1,'1','6',2);
INSERT INTO FICHA_TECNICA VALUES (1,'1','7',2);  
INSERT INTO FICHA_TECNICA VALUES (1,'1','8',1);
INSERT INTO FICHA_TECNICA VALUES (1,'1','9',1);
INSERT INTO FICHA_TECNICA VALUES (1,'1','10',1);
INSERT INTO FICHA_TECNICA VALUES (1,'1','12',0.250);
INSERT INTO FICHA_TECNICA VALUES (1,'1','13',1);
INSERT INTO FICHA_TECNICA VALUES (1,'1','14',1);
INSERT INTO FICHA_TECNICA VALUES (1,'1','15',2);
INSERT INTO FICHA_TECNICA VALUES (1,'1','16',1);
--FICHA TENICA BIKE PRETA
INSERT INTO FICHA_TECNICA VALUES (1,'2','3',1);
INSERT INTO FICHA_TECNICA VALUES (1,'2','4',1);
INSERT INTO FICHA_TECNICA VALUES (1,'2','5',2);
INSERT INTO FICHA_TECNICA VALUES (1,'2','6',2);
INSERT INTO FICHA_TECNICA VALUES (1,'2','7',2);
INSERT INTO FICHA_TECNICA VALUES (1,'2','8',1);
INSERT INTO FICHA_TECNICA VALUES (1,'2','9',1);
INSERT INTO FICHA_TECNICA VALUES (1,'2','10',1);
INSERT INTO FICHA_TECNICA VALUES (1,'2','11',0.250);
INSERT INTO FICHA_TECNICA VALUES (1,'2','13',1);
INSERT INTO FICHA_TECNICA VALUES (1,'2','14',1);
INSERT INTO FICHA_TECNICA VALUES (1,'2','15',2);
INSERT INTO FICHA_TECNICA VALUES (1,'2','16',1);

--SELECT * FROM CENTRO_CUSTO
--CARGA CENTRO DE CUSTOS
INSERT INTO CENTRO_CUSTO VALUES (1,'9001','PRESIDENCIA');
INSERT INTO CENTRO_CUSTO VALUES (1,'9002','ADMINISTRATIVO');
INSERT INTO CENTRO_CUSTO VALUES (1,'9003','PRODUCAO');
INSERT INTO CENTRO_CUSTO VALUES (1,'9004','SUPRIMENTOS');
INSERT INTO CENTRO_CUSTO VALUES (1,'9005','RH');
INSERT INTO CENTRO_CUSTO VALUES (1,'9006','FINANCEIRO');
INSERT INTO CENTRO_CUSTO VALUES (1,'9007','COMERCIAL');
INSERT INTO CENTRO_CUSTO VALUES (1,'9008','FISCAL');
INSERT INTO CENTRO_CUSTO VALUES (1,'9009','TI');

--CARGA DE CARGOS FUNCOES
--SELECT * FROM CARGOS
--SELECT * FROM CENTRO_CUSTO

INSERT INTO CARGOS VALUES (1,1,'PRESIDENTE');
INSERT INTO CARGOS VALUES (1,2,'GER COMERCIAL');
INSERT INTO CARGOS VALUES (1,3,'VENDEDOR');
INSERT INTO CARGOS VALUES (1,4,'GER ADM');
INSERT INTO CARGOS VALUES (1,5,'ASSINTENTE DE RH');
INSERT INTO CARGOS VALUES (1,6,'OPERADOR PRODUCAO');
INSERT INTO CARGOS VALUES (1,7,'ESTOQUISTA');
INSERT INTO CARGOS VALUES (1,8,'ANALISTA DE SISTEMA');
INSERT INTO CARGOS VALUES (1,9,'FATURISTA');
INSERT INTO CARGOS VALUES (1,10,'ASSISTENTE FINANCEIRO');

select sysdate from dual;
--CARGA TABELA FUNCIONARIO 
--DELETE FROM FUNCIONARIO
--SELECT * FROM FUNCIONARIO

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9001','JAMES LABRIE','1234567','123567990','RUA 1','2','SANTA CLAUS','3525904','10/03/1917',null,'25/12/1980','111111',1);

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9002','JONH LARAVEL','1234568','123567889','RUA 2','3','SANTA CLAUS','3525904','10/02/1917','','12/01/90','121212','4');

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9003','PETER DOTNESK','3434568','123564578','RUA 3','4','SANTA CLAUS','3525904','09/02/1917','','04/06/1988','12121121','6');

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9004','LARA POTTER','4434509','123576867','RUA 4','5','SANTA CLAUS','3525904','07/03/1917','','25/10/1990','65841','7');

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9005','JESSICA SUTER','4534576','120367887','RUA 5','6','SANTA CLAUS','3525904','03/03/2017','','09/03/1983','12154','5');

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9006','PEDRO TESLA','4334568','123703885','RUA 6','7','SANTA CLAUS','3525904','15/04/2017','','25/10/1987','56477','1');

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9007','TIAGO FIELDER','9834568','147034889','RUA 7','8','SANTA CLAUS','3525904','20/04/2017','','10/03/1982','985124','2');

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9007','MALCON DEXTER','9834568','147067889','RUA 17','28','SANTA CLAUS','3525904','20/04/2017','','05/05/1987','85445','3');

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9007','CHARLES NOIX','9894668','147067149','RUA 77','18','SANTA CLAUS','3525904','20/04/2017','','06/10/1979','654789','3');

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9008','JOAO SPARK','7734568','643567888','RUA 8','22','SANTA CLAUS','3525904','20/04/2017','','26/01/1984','32564','9');

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9009','DAVID MANDRAKE','6634568','345567887','RUA 8','56','SANTA CLAUS','3525904','05/07/2017','','10/10/1980','147852','8');

INSERT INTO FUNCIONARIO VALUES
 (1,NULL,'9002','SAMUEL DUPRET','8984568','159567887','RUA 23','89','SANTA CLAUS','3525904','05/07/2017','','26/10/1988','987452','10');

--CARGA TABELA USUARIOS
--DELETE FROM USUARIOS
--SELECT * FROM USUARIOS
--SELECT NOME,MATRICULA FROM FUNCIONARIO
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'JAMESL','1','0','A');
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'JONHL','2','0','A');
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'PETERD','3','0','A');
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'LARAP','4','0','A');
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'JESSICAS','5','0','A');
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'PEDROT','6','0','A');
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'TIAGOF','7','0','A');
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'MALCOND','8','0','A');
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'CHARLESN','9','0','A');
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'JOAOS','10','0','A');
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'DAVIDM','11','0','A');
INSERT INTO USUARIOS (COD_EMPRESA,LOGIN,MATRICULA,SENHA,SITUACAO) VALUES (1,'SAMUELD','12','0','A');


--CRIANDO FUNÇÃO PARA CRIPTOGRAFAR
 --criando função para gerar senha
   create or replace function md5 (valor varchar) 
     return varchar2 is
     v_input varchar2(2000) := valor;
     v_input_cripto varchar2(32) := null;
   begin
        v_input_cripto := rawtohex(dbms_obfuscation_toolkit.md5(input => utl_raw.cast_to_raw(v_input))); -- funcao: rawtohex
   return nvl(v_input_cripto,'');
   end;
   
---GRAVANDO E CRIPTOGRAFANDO SENHA COM MD5 COM SENHA INICIAL = MATRICULA
UPDATE USUARIOS  SET SENHA = MD5(MATRICULA)  WHERE 1=1; -- Ou seja, a senha e a matricula, porem, criptografada...


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
97.Cargas de Tabelas Parte 2

--CARGA TABELA CONDICAO DE PAGAMENTO
--SELECT * FROM COND_PAGTO
INSERT INTO COND_PAGTO (NOME_CP) VALUES ('A VISTA');
INSERT INTO COND_PAGTO VALUES (NULL,'3 X 30/60/90 DD'); 
INSERT INTO COND_PAGTO VALUES (NULL,'30 DD');

--CARGA DETALHE DE PAGAMENTO PARCELAS
--CONDICAO 1
INSERT INTO COND_PAGTO_DET VALUES
	('1','1',0,100); -- a vista 0 dias...
    
--CONDICAO 2
INSERT INTO COND_PAGTO_DET VALUES ('2','1',30,33.34);
INSERT INTO COND_PAGTO_DET VALUES ('2','2',60,33.33);
INSERT INTO COND_PAGTO_DET VALUES ('2','3',90,33.33);

--CONDICAO 3
INSERT INTO COND_PAGTO_DET VALUES ('3','1',30,100);
	
--CARGA VENDEDORES
--SELECT * FROM VENDEDORES
INSERT INTO VENDEDORES(COD_EMPRESA,MATRICULA)
SELECT COD_EMPRESA,MATRICULA FROM FUNCIONARIO
WHERE COD_CARGO IN (SELECT COD_CARGO FROM CARGOS WHERE NOME_CARGO = 'VENDEDOR')
AND MATRICULA NOT IN (SELECT MATRICULA FROM VENDEDORES);

--CARGA TABELA GERENTES
INSERT INTO GERENTES (COD_EMPRESA,MATRICULA)
SELECT COD_EMPRESA,MATRICULA FROM FUNCIONARIO
WHERE COD_CARGO IN (SELECT COD_CARGO FROM CARGOS WHERE NOME_CARGO = 'GER COMERCIAL')
AND MATRICULA NOT IN (SELECT MATRICULA FROM GERENTES);

--CARGA CANAL VENDAS GERENTE X VENDEDOR

SELECT * FROM CANAL_VENDAS_G_V;
INSERT INTO CANAL_VENDAS_G_V VALUES (1,1,1);
INSERT INTO CANAL_VENDAS_G_V VALUES (1,1,2);

--CARGA CANAL VENDAS VENDEDOR X CLIENTE
--SELECT * FROM CLIENTES
--SELECT * FROM CANAL_VENDAS_V_C
INSERT INTO CANAL_VENDAS_V_C   VALUES (1,1,1);
INSERT INTO CANAL_VENDAS_V_C VALUES (1,1,2);
--INSERT INTO CANAL_VENDAS_V_C VALUES (1,2,3);
--INSERT INTO CANAL_VENDAS_V_C VALUES (1,2,4);

--CARGA DE META DE VENDAS
--SELECT * FROM META_VENDAS
 INSERT INTO META_VENDAS VALUES (1,1,'2018','01',83.33);
 INSERT INTO META_VENDAS VALUES (1,1,'2018','02',83.33);
 INSERT INTO META_VENDAS VALUES (1,1,'2018','03',83.33);
 INSERT INTO META_VENDAS VALUES (1,1,'2018','04',83.33);
 INSERT INTO META_VENDAS VALUES (1,1,'2018','05',83.33);
 INSERT INTO META_VENDAS VALUES (1,1,'2018','05',83.33);
 INSERT INTO META_VENDAS VALUES (1,1,'2018','07',83.33);
 INSERT INTO META_VENDAS VALUES (1,1,'2018','08',83.33);
 INSERT INTO META_VENDAS VALUES (1,1,'2018','09',83.33);
 INSERT INTO META_VENDAS VALUES (1,1,'2018','10',83.33);
 INSERT INTO META_VENDAS VALUES (1,1,'2018','11',83.33);
 INSERT INTO META_VENDAS VALUES (1,1,'2018','12',83.33);

 INSERT INTO META_VENDAS VALUES (1,2,'2018','01',83.33);
 INSERT INTO META_VENDAS VALUES (1,2,'2018','02',83.33);
 INSERT INTO META_VENDAS VALUES (1,2,'2018','03',83.33);
 INSERT INTO META_VENDAS VALUES (1,2,'2018','04',83.33);
 INSERT INTO META_VENDAS VALUES (1,2,'2018','05',83.33);
 INSERT INTO META_VENDAS VALUES (1,2,'2018','07',83.33);
 INSERT INTO META_VENDAS VALUES (1,2,'2018','08',83.33);
 INSERT INTO META_VENDAS VALUES (1,2,'2018','09',83.33);
 INSERT INTO META_VENDAS VALUES (1,2,'2018','10',83.33);
 INSERT INTO META_VENDAS VALUES (1,2,'2018','11',83.33);
 INSERT INTO META_VENDAS VALUES (1,2,'2018','12',83.33);
 
 --CARGA CFOP CODIGO DE OPERACAOS FISCAIS
--  DELETE FROM CFOP
  INSERT INTO CFOP VALUES ('5.101','VENDAS DE MERC'); -- CFOP é a sigla de Código Fiscal de Operações e Prestações
  INSERT INTO CFOP VALUES ('1.101','COMPRAS DE MERC');
  SELECT * FROM CFOP;

--CARGA DE ORDENS DE PRODUCAO PARA PLANEJAMENTO

--DELETE  FROM ORDEM_PROD
/*
INSERT INTO ORDEM_PROD VALUES 
		(1,50,'2017-01-01','2017-01-31'),(2,50,'2017-01-01','2017-01-31'),
		(1,50,'2017-02-01','2017-02-28'),(2,50,'2017-01-02','2017-02-28'),
		(1,50,'2017-03-01','2017-03-31'),(2,50,'2017-01-03','2017-03-31'),
		(1,50,'2017-04-01','2017-04-30'),(2,50,'2017-01-04','2017-04-30'),
		(1,50,'2017-05-01','2017-05-31'),(2,50,'2017-01-05','2017-05-31'),
		(1,50,'2017-06-01','2017-06-30'),(2,50,'2017-01-06','2017-06-30'),
		(1,50,'2017-07-01','2017-07-31'),(2,50,'2017-01-07','2017-07-31'),
		(1,50,'2017-08-01','2017-08-31'),(2,50,'2017-01-08','2017-08-31'),
		(1,50,'2017-09-01','2017-09-30'),(2,50,'2017-01-09','2017-09-30'),
		(1,50,'2017-10-01','2017-10-31'),(2,50,'2017-01-10','2017-10-31'),
		(1,50,'2017-11-01','2017-11-30'),(2,50,'2017-01-11','2017-11-30'),
		(1,50,'2017-12-01','2017-12-31'),(2,50,'2017-01-12','2017-12-31')
*/	
--CARGA PEDIDO DE COMPRAS POR DEMANDA DE PRODUCAO
--SELECT
/*
SELECT A.COD_MAT_PROD,A.QTD_PROD,B.COD_MAT_NECES,B.QTD_NECES,A.QTD_PROD*B.QTD_NECES  NECESSIDADE,
	   C.ID_FOR
  FROM ORDEM_PROD A
	INNER JOIN FICHA_TECNICA B
	ON A.COD_MAT_PROD=B.COD_MAT_PROD
	INNER JOIN MATERIAL C
	ON B.COD_MAT_NECES=C.COD_MAT
		WHERE MONTH(DATA_FIM)=01 
		AND YEAR(DATA_FIM)=2017 

*/
--INSERT PED_VENDAS CABEÇALHO
--SELECT * FROM PED_VENDAS ORDER BY COD_EMPRESA,NUM_PEDIDO
--DELETE FROM PED_VENDAS
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (1,1,1,'13/01/2018','29/01/2018','A');
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (1,2,3,'13/02/2018','28/02/2018','A');
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (2,3,2,'13/03/2018','29/03/2018','A');
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (1,2,2,'13/04/2018','29/04/2018','A');
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (1,2,3,'13/05/2018','29/05/2018','A');
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (1,1,3,'13/06/2018','29/06/2018','A');
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (1,2,1,'13/07/2018','29/07/2018','A');
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (2,3,3,'13/08/2018','29/08/2018','A');
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (2,3,2,'13/09/2018','29/09/2018','A');
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (1,2,1,'13/10/2018','29/10/2018','A');
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (1,1,2,'13/11/2018','29/11/2018','A');
 INSERT INTO PED_VENDAS (COD_EMPRESA,ID_CLIENTE,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO) VALUES
 (2,3,2,'13/12/2018','29/12/2019','A');
 

--CARGA DETALHES DE PEDIDOS
--PED_VENDAS
--SELECT * FROM PED_VENDAS_ITENS
 INSERT INTO PED_VENDAS_ITENS VALUES (1,1,1,1,35,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (1,1,2,2,40,2500);
 
 INSERT INTO PED_VENDAS_ITENS VALUES (1,2,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (1,2,2,2,35,2500);
 
 INSERT INTO PED_VENDAS_ITENS VALUES (1,3,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (1,3,2,2,35,2500);
 
 INSERT INTO PED_VENDAS_ITENS VALUES (1,4,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (1,4,2,2,35,2500);
 
 INSERT INTO PED_VENDAS_ITENS VALUES (1,5,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (1,5,2,2,35,2500);
 
 INSERT INTO PED_VENDAS_ITENS VALUES (1,6,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (1,6,2,2,35,2500);
 
 INSERT INTO PED_VENDAS_ITENS VALUES (1,7,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (1,7,2,2,35,2500);
 
 INSERT INTO PED_VENDAS_ITENS VALUES (1,8,1,1,70,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (1,8,2,2,70,2500);
 
 --APOS INTEGRAÇÃO DE COPIA   
 INSERT INTO PED_VENDAS_ITENS VALUES (2,1,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,1,2,2,35,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,2,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,2,2,2,35,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,3,1,1,100,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,3,2,2,100,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,4,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,4,2,2,35,2500);

--CARGA FUNCIONARIO SALARIOS
--SELECT * FROM SALARIO
INSERT INTO SALARIO VALUES (1,1,7650);
INSERT INTO SALARIO VALUES (1,2,2650);
INSERT INTO SALARIO VALUES (1,3,2550);
INSERT INTO SALARIO VALUES (1,4,1550);
INSERT INTO SALARIO VALUES (1,5,4550);
INSERT INTO SALARIO VALUES (1,6,2850);
INSERT INTO SALARIO VALUES (1,7,1850);
INSERT INTO SALARIO VALUES (1,8,1560);
INSERT INTO SALARIO VALUES (1,9,3899);
INSERT INTO SALARIO VALUES (1,10,2345);
INSERT INTO SALARIO VALUES (1,11,3100);
INSERT INTO SALARIO VALUES (1,12,4500);
						  

--CARGA PARAMETROS INSS
--SELECT * FROM PARAM_INSS
   INSERT INTO PARAM_INSS VALUES ('01/01/2018','31/12/2018',0,1659.38,8);
   INSERT INTO PARAM_INSS VALUES ('01/01/2018','31/12/2018',1659.39,2765.66,9);
   INSERT INTO PARAM_INSS VALUES ('01/01/2018','31/12/2018',2765.67,5531.31,11);
   INSERT INTO PARAM_INSS VALUES ('01/01/2018','31/12/2018',5531.32,999999,0);

--CARGA PARAMETROS IRPF

--DELETE FROM PARAM_IRRF
 INSERT INTO PARAM_IRRF VALUES ('01/01/2018','31/12/2018',0,1903.98,0,0);
 INSERT INTO PARAM_IRRF VALUES ('01/01/2018','31/12/2018',1903.99,2826.65,7.5,142.80);
 INSERT INTO PARAM_IRRF VALUES ('01/01/2018','31/12/201',2826.66,3751.05,15,354.80);
 INSERT INTO PARAM_IRRF VALUES ('01/01/2018','31/12/2018',3751.06,4664.68,22.5,636.13);
 INSERT INTO PARAM_IRRF VALUES ('01/01/2018','31/12/2018',4664.68,999999,27.5,869.36);


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
98.Procedure de Cópia de Material 


--PROCEDURE PARA COPIA DE MATERIAL
--PROCEDURE P FACILITAR O PROCESSO DE COPIA DE UMA EMPRESA PARA A OUTRA..LEMBRESE-SE UM ERP, UMA NOVA LOJA TERA OS MESMO PRODUTOS!

CREATE OR REPLACE PROCEDURE PROC_COPIA_MAT (V_EMP_DE IN NUMBER,     -- EMPRESA ORIGEM
                                            V_EMP_PARA IN NUMBER,   -- EMPRESA DESTINO
                                            V_MAT IN NUMBER)        -- MATERIAL A SER COPIADO
                                         		    		   
                IS
    --EXCESSOES   
    V_EXECPT_EMP_DE EXCEPTION;
    V_EXECPT_EMP_PARA EXCEPTION;
    V_EXECPT_EMP_MAT_DE EXCEPTION;
    V_EXECPT_EMP_MAT_PARA EXCEPTION;
	
    --VARIAVES DE APOIO CONTROLE
    V_CONT_EMP_DE NUMBER;
    V_CONT_EMP_PARA NUMBER;
    V_CONT_EMP_MAT_DE NUMBER;
    V_CONT_EMP_MAT_PARA NUMBER;
   
 BEGIN
    --VERIFICA SE EMPRESA ORIGEM EXISTE (DE)
    SELECT COUNT(*) AS QTD INTO V_CONT_EMP_DE FROM EMPRESA WHERE COD_EMPRESA = V_EMP_DE; --  SELECT * FROM EMPRESA
    IF (V_CONT_EMP_DE = 0) THEN
        RAISE V_EXECPT_EMP_DE;
    END IF;
    
       --VERIFICA SE EMPRESA DESTINO EXISTE (PARA)
    SELECT COUNT(*) QTD INTO V_CONT_EMP_PARA FROM EMPRESA WHERE COD_EMPRESA = V_EMP_PARA;
    IF (V_CONT_EMP_PARA = 0) THEN
        RAISE V_EXECPT_EMP_PARA;
    END IF;
    
     --VERIFICA SE MATERIAL ORIGEM EXISTE
    SELECT COUNT(*) QTD INTO V_CONT_EMP_MAT_DE FROM MATERIAL WHERE COD_EMPRESA = V_EMP_DE AND COD_MAT = V_MAT;
    IF (V_CONT_EMP_MAT_DE = 0) THEN
        RAISE V_EXECPT_EMP_MAT_DE;
    END IF;
    
         --VERIFICA SE MATERIAL DESTINO JA EXISTE
    SELECT COUNT(*) QTD INTO V_CONT_EMP_MAT_PARA FROM MATERIAL WHERE COD_EMPRESA = V_EMP_PARA AND COD_MAT = V_MAT;
    IF (V_CONT_EMP_MAT_PARA = 1) THEN
        RAISE V_EXECPT_EMP_MAT_PARA;
    END IF;
    
    --SELECT * FROM MATERIAL;
    INSERT INTO MATERIAL
    SELECT V_EMP_PARA, COD_MAT, DESCRICAO, PRECO_UNIT, COD_TIP_MAT FROM MATERIAL
    WHERE COD_MAT = V_MAT AND COD_EMPRESA = V_EMP_DE;
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('COPIA REALIZADA COM SUCESSO!');
 
 EXCEPTION
 WHEN V_EXECPT_EMP_DE THEN
      DBMS_OUTPUT.PUT_LINE('ATENÇÃO! EMPRESA ORIGEM NAO EXISTE');
      
 WHEN V_EXECPT_EMP_PARA THEN
      DBMS_OUTPUT.PUT_LINE('ATENÇÃO! EMPRESA DESTINO NAO EXISTE');
      
 WHEN V_EXECPT_EMP_MAT_DE THEN
      DBMS_OUTPUT.PUT_LINE('ATENÇÃO! MATERIAL NAO EXISTE NA EMPRESA ORIGEM');
      
  WHEN V_EXECPT_EMP_MAT_PARA THEN
       --RAISE_APPLICATION_ERROR(-20999,'ATENÇÃO! MATERIAL JA EXISTE NA EMPRESA DESTINO', FALSE);
       DBMS_OUTPUT.PUT_LINE('ATENÇÃO! MATERIAL JA EXISTE NA EMPRESA DESTINO');
      
 WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('OCORREU UM ERRO - '||SQLCODE||' -ERROR- '||SQLERRM);

END;


--EXECUTANDO PREOCEDURE

--PARAMENTROS EMPRESA ORIGEM, 
		   -- EMPRESA DESTINO 
		   -- MATERIAL A SER COPIADO
		   
SET SERVEROUTPUT ON
SELECT * FROM MATERIAL;
SELECT * FROM EMPRESA;

EXECUTE PROC_COPIA_MAT (9,1,1);  -- ATENÇÃO! EMPRESA ORIGEM NAO EXISTE -- (NAO ESTA CADASTRADO NA TBB EMPRESA)
EXECUTE PROC_COPIA_MAT (1,9,1);  -- ATENÇÃO! EMPRESA DESTINO NAO EXISTE -- (NAO ESTA CADASTRADO NA TBB EMPRESA)
EXECUTE PROC_COPIA_MAT (1,2,99); -- ATENÇÃO! MATERIAL NAO EXISTE NA EMPRESA ORIGEM -- -- (NAO ESTA CADASTRADO NA TBB MATERIAL)

EXECUTE PROC_COPIA_MAT (1,4,1);  -- COPIA REALIZADA COM SUCESSO!
EXECUTE PROC_COPIA_MAT (1,4,2);  -- COPIA REALIZADA COM SUCESSO!

--SELECT * FROM MATERIAL;

-- CRIEI UMA PROCEDURE: PROC_CARGA_EMP PARA CADASTRAR NOVO CLIENTES...



 --APOS INTEGRAÇÃO DE COPIA   
 INSERT INTO PED_VENDAS_ITENS VALUES (2,1,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,1,2,2,35,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,2,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,2,2,2,35,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,3,1,1,100,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,3,2,2,100,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,4,1,1,50,2500);
 INSERT INTO PED_VENDAS_ITENS VALUES (2,4,2,2,35,2500);
 
 SELECT * FROM PED_VENDAS_ITENS;
 --DELETE FROM PED_VENDAS_ITENS WHERE COD_EMPRESA=2;
 --DELETE FROM MATERIAL WHERE COD_EMPRESA=2;
 
-------------------------------------------------------
-------------------------------------------------------
-- PROCEDURE QUE CRIEI PARA DAR CARGA NA TABELA EMPRESA
-------------------------------------------------------
------------------------------------------------------- 
 
 CREATE OR REPLACE PROCEDURE PROC_CARGA_EMP(P_COD NUMBER,
                                            P_NOME IN VARCHAR2,
                                            P_FANTASIA IN VARCHAR2) IS
--VARIAVEIS EXCEPTION
V_EXC_COD EXCEPTION;
V_EXC_NOME EXCEPTION;
V_EXC_FANTASIA EXCEPTION;

-- VARIAVEIS DE CONTROLE
V_COD NUMBER;
V_NOME NUMBER;
V_FANTASIA NUMBER;


BEGIN
    -- VALIDA SE O CODIGO JA ESTA CADASTRADO P OUTRO CLIENTE
    SELECT COUNT(*) INTO V_COD FROM EMPRESA WHERE COD_EMPRESA = P_COD;
    IF (V_COD = 1) THEN
        RAISE V_EXC_COD;
    END IF;

    -- VALIDA SE O NOME DA EMPRESA JA EXISTE
    SELECT COUNT(*) INTO V_NOME FROM EMPRESA WHERE NOME_EMPRESA = P_NOME;
    IF (V_NOME = 1) THEN
       RAISE V_EXC_NOME;
    END IF;
    
    -- VALIDA SE NOME FANTASIA JA EXISTE
    SELECT COUNT(*) INTO V_FANTASIA FROM EMPRESA WHERE FANTASIA = P_FANTASIA;
    IF (V_FANTASIA = 1) THEN
        RAISE V_EXC_FANTASIA;
    END IF;

    INSERT INTO EMPRESA VALUES (P_COD,P_NOME,P_FANTASIA);
     COMMIT; 

    EXCEPTION
    
    WHEN V_EXC_COD THEN
    DBMS_OUTPUT.PUT_LINE('CODIGO: '||P_COD||' '||'INFORMADO PERTENCE A OUTRO CLIENTE!');
    
     WHEN V_EXC_NOME THEN
     DBMS_OUTPUT.PUT_LINE('NOME: '||P_NOME||' '||'JÁ ENCONTRA-SE CADASTRADO!');

     WHEN V_EXC_FANTASIA THEN
     DBMS_OUTPUT.PUT_LINE('NOME FANTASIA: '||P_FANTASIA||' '||'JÁ ENCONTRA-SE CADASTRADO, POR FAVOR SE CERTIFICAR!');

     WHEN OTHERS THEN 
     DBMS_OUTPUT.PUT_LINE('OCORREU UM ERRO - '||SQLCODE||' -ERROR- '||SQLERRM);
     DBMS_OUTPUT.PUT_LINE('LINHA: '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);

END;
 
  

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
99.Procedure Gera Planejamento de Produção

--PROCEDURE ORDEM_PROD
--SELECT * FROM PED_VENDAS
--SELECT * FROM PED_VENDAS_ITENS
--SELECT * FROM ORDEM_PROD
--MAT 1 QTD 35
--MAT 2 QTD 40

--NOSSO SISTEMA VAI TRABALHAR SOBRE DEMANDA.
--OBJETIVO GERAR ORDENS DE PRODUCAO DE ACORDO COM "DEMANDA DE VENDAS POR EMPRESA"
--AS "VENDAS" GERAM "ORDEM DE PRODUCAO", QUE VAI GERAR O "PEDIDO DE COMPRA", E ASSIM REALIZAR A PRODUCAO....


--OBS: OS PEDIDOS QUE ESTIVERM COM STATUS = A NA TAB VENDA, DEVEM SER GERADOS ORDENS DE PRODUCAO ATRAVES DA PROC: PROC_PLAN_ORDEM



--DROP PROCEDURE PROC_PLAN_ORDEM
-- PROCEDURE ORDEM DE PRODUCAO...
create or replace PROCEDURE PROC_PLAN_ORDEM (P_EMP NUMBER,
                                             P_MES  VARCHAR2, 
                                             P_ANO  VARCHAR2) 
IS
  V_EXCEPT_EXISTE_PEDIDO EXCEPTION;
  V_CONTA_PED NUMBER;
 BEGIN 

 --VERIFICANDO SE EXISTE PEDIDOS ABERTO PARA MES E ANO SELECIONADO
    SELECT COUNT(*) QTD INTO V_CONTA_PED
	FROM PED_VENDAS A
	INNER JOIN PED_VENDAS_ITENS B
	ON A.NUM_PEDIDO = B.NUM_PEDIDO
    AND A.COD_EMPRESA = B.COD_EMPRESA
	WHERE A.SITUACAO = 'A' --ABERTO
    AND A.COD_EMPRESA = P_EMP
	AND TO_CHAR(A.DATA_ENTREGA,'MM')= P_MES
    AND TO_CHAR(A.DATA_ENTREGA,'YYYY')= P_ANO;

    --SE FOR IGUAL A ZERO NAO TEM E TERMINA
    IF V_CONTA_PED = 0
	THEN 
		RAISE V_EXCEPT_EXISTE_PEDIDO;
	END IF;


    --SELECIONANDO PEDIDOS PARA GERAR ORDENS DE PRODUÇÃO DE ACORDO COM A DEMANDA.
			INSERT INTO ORDEM_PROD 
			SELECT A.COD_EMPRESA,   --SELECT * FROM ORDEM_PROD;
                   NULL, -- AUTOMATICO, TRIGGER...
                   B.COD_MAT,
                   SUM(B.QTD) AS QTD_PLAN,
                   0 QTD_PROD,
			       '01/'||P_MES||'/'||P_ANO AS DATA_INI,
                   LAST_DAY('01/'||P_MES||'/'||P_ANO) AS DATA_FIM,
                   'A'
			FROM PED_VENDAS A
				INNER JOIN PED_VENDAS_ITENS B
				ON A.NUM_PEDIDO = B.NUM_PEDIDO
                AND  A.COD_EMPRESA = B.COD_EMPRESA
				WHERE A.COD_EMPRESA = P_EMP 
				AND TO_CHAR(A.DATA_ENTREGA,'MM') = P_MES
                AND TO_CHAR(A.DATA_ENTREGA,'YYYY') = P_ANO
                AND A.SITUACAO = 'A' --APENAS PEDIDO EM ABERTO
				GROUP BY A.COD_EMPRESA, B.COD_MAT, NULL, 0, '01/'||P_MES||'/'||P_ANO,  -- COMO ESTOU FAZENDO UM (SUM) PRECISO DO GROUP BY!
                LAST_DAY('01/'||P_MES||'/'||P_ANO), 
                'A';

               DBMS_OUTPUT.PUT_LINE('INSERT ORDEM PROD REALIZADO');

               -- MUDAR O STATUS DE A - ABERTO PARA P - PLANEJADO
                --ATUALIZA STATUS PEDIDO DE A PARA P
               UPDATE PED_VENDAS  
               SET SITUACAO = 'P'
               WHERE COD_EMPRESA = P_EMP
               AND TO_CHAR(DATA_ENTREGA,'MM') = P_MES
               AND TO_CHAR(DATA_ENTREGA,'YYYY') = P_ANO
               AND SITUACAO = 'A';

               DBMS_OUTPUT.PUT_LINE('STATUS ATUALIZADO DE ABERTO PARA PLANEJADO');

 EXCEPTION
 WHEN V_EXCEPT_EXISTE_PEDIDO THEN
      DBMS_OUTPUT.PUT_LINE('ATENÇÃO! NAO EXISTE PEDIDOS ABERTO PARA PLANEJAMENTO!');

  WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('OCORREU UM ERRO - '||SQLCODE||' -ERROR- '||SQLERRM);

END;

--SELECT * FROM PED_VENDAS WHERE TO_CHAR(DATA_PEDIDO) BETWEEN '01/01/2018' AND '31/01/2018' AND SITUACAO = 'P';
--SELECT * FROM PED_VENDAS
--SELECT * FROM PED_VENDAS_ITENS
--SELECT * FROM ORDEM_PROD 
--PARAMENTRO EMPRESA, MES, ANO
EXECUTE PROC_PLAN_ORDEM (1,'01','2018');
EXECUTE PROC_PLAN_ORDEM (1,'02','2018');
EXECUTE PROC_PLAN_ORDEM (2,'03','2018');
EXECUTE PROC_PLAN_ORDEM (1,'04','2018');

--DELETE FROM ORDEM_PROD;

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
100.Procedure Gera Pedido de Compras


--PROCEDURE GERA PEDIDOS DE COMPRAS
--PROCEDURE PARA CRIAR PEDIDO DE COMPRAS COM BASE NECESSIDADES DA ORDEM DE PRODUCAO
--PARAMETROS P_EMP P_MES P_ANO

TABELAS ORIGEM  ORDEM_PROD
TABELAS NECESSARIAS: FICHA_TECNICA, 
					 MATERIAL, 
					 FORNECEDORES
					   
TABELAS DESTINO: PED_COMPRAS, 
				 PED_COMPRAS_ITEM
				 
TABELAS ATUALIZADA: ORDEM_PROD SITUACAO DE A ABERTA PARA P PLANEJ

--DROP PROCEDURE PROC_GER_PED_COMPRAS
--EXEC PROC_GER_PED_COMPRAS 05,2017


-- CARGA PRE REQ
--CARGA MATERIAL FORNEC
--DELETE FROM MAT_FORNEC;


SELECT * FROM MAT_FORNEC;
SELECT * FROM FORNECEDORES;
SELECT * FROM MATERIAL;

INSERT INTO MAT_FORNEC VALUES (1,3,1);
INSERT INTO MAT_FORNEC VALUES (1,4,1);
INSERT INTO MAT_FORNEC VALUES (1,5,1);
INSERT INTO MAT_FORNEC VALUES (1,6,1);
INSERT INTO MAT_FORNEC VALUES (1,7,1);
INSERT INTO MAT_FORNEC VALUES (1,8,1);
INSERT INTO MAT_FORNEC VALUES (1,9,1);
INSERT INTO MAT_FORNEC VALUES (1,10,1);

INSERT INTO MAT_FORNEC VALUES (1,11,2);
INSERT INTO MAT_FORNEC VALUES (1,12,2);
INSERT INTO MAT_FORNEC VALUES (1,13,2);
INSERT INTO MAT_FORNEC VALUES (1,14,2);
INSERT INTO MAT_FORNEC VALUES (1,15,2);
INSERT INTO MAT_FORNEC VALUES (1,16,2);
/*
--TESTE
--AQUI TEM UM ERRO! PERMITE O INSERT PQ NAO FOI CRIADO UMA CHAVE ESTRANGEIRA... SERA CORRIGIDO ABAIXO!!!
INSERT INTO MAT_FORNEC VALUES (1,17,2);
DELETE FROM MAT_FORNEC WHERE COD_MAT='17';
*/
ALTER TABLE MAT_FORNEC ADD FOREIGN KEY (COD_EMPRESA,COD_MAT) REFERENCES MATERIAL(COD_EMPRESA,COD_MAT);

--ALTER TABLE MAT_FORNEC DROP CONSTRAINT  SYS_C007755;

ALTER TABLE PED_COMPRAS_ITENS MODIFY QTD DECIMAL(10,2);

--FIM CARGA



CREATE OR REPLACE PROCEDURE PROC_GER_PED_COMPRAS (P_EMP NUMBER,
                                                  P_MES VARCHAR2, 
                                                  P_ANO VARCHAR2) 
IS
  
  V_EXISTE_ORDEM EXCEPTION;
  --DECLARANDO VARIAVEIS
  /*
  TYPE PED     IS TABLE OF PED_COMPRAS%ROWTYPE;
  TYPE PED_IT  IS TABLE OF PED_COMPRAS_ITENS%ROWTYPE;
  TYPE OP      IS TABLE OF ORDEM_PRODUCAO%ROWTYPE;
  TYPE FT      IS TABLE OF FICHA_TECNICA%ROWTYPE;
  TYPE MAT     IS TABLE OF MATERIAL%ROWTYPE;
  TYPE MAT_FOR IS TABLE OF MAT_FORNEC%ROWTYPE;
  TYPE FORNEC IS TABLE OF FORNECEDORES%ROWTYPE; 
  */
  
  --REFERENCIANDO
  /*
  T_PED PED;
  T_PED_IT PED_IT;
  T_OP OP;
  T_FT FT;
  T_MAT MAT;
  T_FOR_MAT MAT_FOR;
  T_FOR FORNEC;
  */
  
   NUM_PEDIDO_AUX NUMBER;
   V_NUM_PEDIDO  NUMBER;
   
  --DECLARANDO VARIAVEIS AUXILIARES
   V_CONT_ORD NUMBER;
  --MES_AUX VARCHAR2(2);
  --ANO_AUX VARCHAR2(4);
   P_MES_AUX VARCHAR2(2);
   P_ANO_AUX VARCHAR2(4);
   CONT_SEQ NUMBER;
   V_TOTAL_PED NUMBER(10,2);
 
 BEGIN 

   V_TOTAL_PED := 0; -- FORCANDO PARA INICIAR COM 0
   
-- P_MES ='01'
-- P_ANO ='2017'
--VERIFICACAO SE MES JANEIRO MES = 12 E ANO -1
--SENAO MES - 1

  IF (P_MES = '01')
	THEN
		P_MES_AUX := 12; -- RETROATIVO: (DEZ 12 - 1 = JAN MES 1)!!!
		P_ANO_AUX := P_ANO - 1; -- RETROATIVO: (2018 - 1 = 2017)!!!
    ELSE  
	   P_MES_AUX := P_MES_AUX - 1;
    END IF;
    
--VERIFICANDO SE EXISTEM ORDEM PARA PLANEJ
   SELECT COUNT(*) INTO V_CONT_ORD FROM ORDEM_PROD A
        WHERE TO_CHAR(A.DATA_INI,'MM') = P_MES
		AND TO_CHAR(A.DATA_INI,'YYYY') = P_ANO
        AND A.COD_EMPRESA = P_EMP
		AND A.SITUACAO = 'A';
        
      --SE NAO EXISTEM ORDEM RAISE  V_EXISTE_ORDEM
      IF V_CONT_ORD = 0 THEN
       
        RAISE V_EXISTE_ORDEM;
	
      ELSE -- FORCANDO ESSAS VARIAVEIS INICIAR EM 0
             P_MES_AUX := P_MES;
             P_ANO_AUX := P_ANO;
             CONT_SEQ: = 1;
             V_NUM_PEDIDO := 0;
             NUM_PEDIDO_AUX := 0;
     END IF;

--CURSOR PARA GRAVAR CABECALHO PEDIDO DE COMPRAS
--SELECT PARA GERAR NECESSIDADES DE COMPRAS CONFORME ORDEM DE PRODUCAO
--CONFORME FICHA TENICA  E PRODUTO COM SEU FORNECEDOR
-- CURSOR IMPLICITO PRIMEIRO CURSOR

-- O OBJETIVO DESSE CURSOR E ALIMENTAR DUAS TABELAS: O CBECALHO DA NOTA, E O DETALHE DA NOTA!

FOR C_FORNEC IN (SELECT distinct A.COD_EMPRESA, D.ID_FOR, E.COD_PAGTO,
      '15/'||P_MES_AUX||'/'||P_ANO_AUX AS DATA_PEDIDO, -- ESTOU FORCANDO PEDIDO DIA 15 
      '15/'||P_MES||'/'||P_ANO  AS DATA_ENTREGA,       -- ESTOU FORCANDO PEDIDO DIA 15
	'A' SITUACAO
	FROM ORDEM_PROD A  -- ESSA QUERY TEM O OBJETIVO DE VALIDAR ATRAVES DA ORDEM DE COMPRA, SE EU TENHO OS MATERIAIS NECESSARIO PARA FABRICAR.
	INNER JOIN FICHA_TECNICA B    -- SELECT * FROM FICHA_TECNICA;
	ON A.COD_MAT_PROD = B.COD_MAT_PROD
    AND A.COD_EMPRESA = B.COD_EMPRESA
    
	INNER JOIN MATERIAL C  -- SELECT * FROM MATERIAL;
	ON B.COD_MAT_NECES = C.COD_MAT -- AQUI DESCUBRO QUAL O MATERIAL ATRAVEZ DO RELACIONAMENTO
    AND A.COD_EMPRESA = C.COD_EMPRESA 
    
	INNER JOIN MAT_FORNEC D -- P SABER QUAL E O FORNECEDOR DESSE MATERIAL
	ON C.COD_MAT = D.COD_MAT
    AND A.COD_EMPRESA = D.COD_EMPRESA
    
    INNER JOIN FORNECEDORES E  -- DESCOBRIR QUAL O FORNECEDOR E DESCOBRI QUAL O CODIGO DE PAGAMENTO
    ON A.COD_EMPRESA = E.COD_EMPRESA
    AND D.ID_FOR = E.ID_FOR
    
	WHERE TO_CHAR(A.DATA_INI,'MM') = P_MES  --PARAM MES
	AND TO_CHAR(A.DATA_INI,'YYYY') = P_ANO  --PARAM ANO
    AND A.COD_EMPRESA = P_EMP               --PARAM EMPRESA
	AND A.SITUACAO = 'A')  LOOP
    	
	--INSERT NA TABELA COMPRAS CABEBECALHO
	
	 INSERT INTO PED_COMPRAS (COD_EMPRESA,ID_FOR,COD_PAGTO,DATA_PEDIDO,DATA_ENTREGA,SITUACAO)
                        VALUES 
                             (C_FORNEC.COD_EMPRESA,C_FORNEC.ID_FOR,C_FORNEC.COD_PAGTO,C_FORNEC.DATA_PEDIDO,C_FORNEC.DATA_ENTREGA,C_FORNEC.SITUACAO)
     RETURNING NUM_PEDIDO INTO NUM_PEDIDO_AUX; --PEGANDO VALOR DO PEDIDO INSERIDO E ATRIBUINDO VALOR... OBS, NESSA TABELA GERA AUTOMATICO O NUMERO DO PEDIDO.
    
    --APRESENTANDO VALORES
	 DBMS_OUTPUT.PUT_LINE('NUM Ped: '||NUM_PEDIDO_AUX||' Fornec: '||C_FORNEC.ID_FOR||' Cod Pagto: '||
     C_FORNEC.COD_PAGTO||' DATA PED: '||C_FORNEC.DATA_PEDIDO||' DATA ENTR: '||C_FORNEC.DATA_ENTREGA||' SITUA: '||
     C_FORNEC.SITUACAO);
    
    	--CURSOR DETALHE PED IT INICIO
	--SELECT COM PARAMETROS SEGUNFO CURSOR E LOOP
  FOR  PED_IT IN (SELECT A.COD_EMPRESA,B.COD_MAT_NECES COD_MAT,D.ID_FOR,
       SUM(B.QTD_NECES * A.QTD_PLAN) QTD,C.PRECO_UNIT
		FROM ORDEM_PROD A
		INNER JOIN FICHA_TECNICA B
        ON A.COD_MAT_PROD = B.COD_MAT_PROD
        AND A.COD_EMPRESA = B.COD_EMPRESA
        
		INNER JOIN MATERIAL C
		ON B.COD_MAT_NECES = C.COD_MAT
        AND A.COD_EMPRESA = C.COD_EMPRESA
        
        INNER JOIN MAT_FORNEC D
        ON D.COD_MAT = B.COD_MAT_NECES
        AND A.COD_EMPRESA = D.COD_EMPRESA
        
		INNER JOIN FORNECEDORES E
		ON D.ID_FOR = E.ID_FOR
        AND A.COD_EMPRESA = E.COD_EMPRESA
        
		WHERE TO_CHAR(A.DATA_INI,'MM') = P_MES --PAPRAM MES
		AND TO_CHAR(A.DATA_INI,'YYYY') = P_ANO --PARAM ANO
        AND A.COD_EMPRESA = P_EMP --PARAM EMPRESA
		AND A.SITUACAO = 'A' --ABERTA
		AND D.ID_FOR = C_FORNEC.ID_FOR --PARAM PARA FORNECEDOR DO CURSOR 1
		GROUP BY A.COD_EMPRESA,B.COD_MAT_NECES,D.ID_FOR,C.PRECO_UNIT -- NECESSARIO O GROUP BY PQ ESTOU FAZENDO O "SUM" ACIMA.
        ORDER BY B.COD_MAT_NECES) LOOP

	  --VERIFICACOES PARA CONTADOR DE SEQ MATERIAL E TOTAL_PED
	  IF (V_NUM_PEDIDO <> NUM_PEDIDO_AUX) THEN
	 
	   CONT_SEQ :=1;
	   V_TOTAL_PED :=0;  
	  END IF;
      
	    --INSERINDO REGISTRO NA PED_COMPRAS_ITENS
		
		INSERT INTO PED_COMPRAS_ITENS VALUES 
		(PED_IT.COD_EMPRESA,NUM_PEDIDO_AUX,CONT_SEQ,PED_IT.COD_MAT,PED_IT.QTD,PED_IT.PRECO_UNIT);
		
		--APRESENTANDO VALORES
		DBMS_OUTPUT.PUT_LINE('Cod Mat: '||PED_IT.COD_MAT||' Seq: '||CONT_SEQ||' COD MAT: '||PED_IT.COD_MAT||' QTD: '||PED_IT.QTD||' PRECO_UNIT: '||PED_IT.PRECO_UNIT);
		
        --ATRIBUINDO VALORES
		
		V_NUM_PEDIDO := NUM_PEDIDO_AUX;
		CONT_SEQ := CONT_SEQ + 1;
		V_TOTAL_PED := V_TOTAL_PED + (PED_IT.QTD * PED_IT.PRECO_UNIT);
        
          DBMS_OUTPUT.PUT_LINE('Pedido '||V_NUM_PEDIDO||' Total Pedido: '||V_TOTAL_PED);

    END LOOP; --FIM CURSOR C_FORNEC SEGUNDO CURSOR CURSO 
        
     --ATUALIZANDO TOTAL PEDIDO
  UPDATE PED_COMPRAS SET TOTAL_PED = V_TOTAL_PED
  WHERE NUM_PEDIDO = V_NUM_PEDIDO
  AND COD_EMPRESA = P_EMP;
  
  DBMS_OUTPUT.PUT_LINE('Pedido '||V_NUM_PEDIDO||' Total Pedido: '||V_TOTAL_PED);

  --ATRIBUINDO VARIAVEIS
  V_NUM_PEDIDO := NUM_PEDIDO_AUX;
    
    END LOOP ; --FIM CURSOR C_FORNEC PRIMEIRO CURSO
	
            --ATUALIZA ORDENS
			UPDATE  ORDEM_PROD SET SITUACAO = 'P'
			WHERE TO_CHAR(DATA_INI,'MM') = P_MES
			AND TO_CHAR(DATA_INI,'YYYY') = P_ANO
			AND SITUACAO = 'A'
            AND COD_EMPRESA = P_EMP;
		 
    	
		    dbms_output.put_line('OPERACAO FINALIZADA COM SUCESSO');
			COMMIT;


EXCEPTION
 WHEN   V_EXISTE_ORDEM  THEN
      DBMS_OUTPUT.PUT_LINE('ATENÇÃO! NÃO EXISTEM OP PARA ESTA OPERACAO!');
      
  WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('OCORREU UM ERRO - '||SQLCODE||' -ERROR- '||SQLERRM);

END;



--EXECUTANDO 
--PARAMENTRE EMPRESA, MES,ANO

SET SERVEROUTPUT ON
EXECUTE PROC_GER_PED_COMPRAS (1,'01','2018');
EXECUTE PROC_GER_PED_COMPRAS (1,'02','2018'); -- PEDIDO PARA MES 02


--VERIFICANDO
SELECT * FROM ORDEM_PROD;
SELECT * FROM PED_COMPRAS;
SELECT * FROM PED_COMPRAS_ITENS
SELECT * FROM FICHA_TECNICA;

--PED 5 46687,5
--PED 6 131625
--SELECT cast(qtd as decimal(10,2)) FROM PED_COMPRAS_ITENS;
--VERIFICANDO SOMA
SELECT COD_EMPRESA, 
       NUM_PEDIDO, 
       SUM(CAST(QTD * VAL_UNIT AS DECIMAL(10,2))) TOTAL -- Cast: Converte uma expressao de um tipo de dados em outro
FROM PED_COMPRAS_ITENS
WHERE COD_EMPRESA = 1
GROUP BY COD_EMPRESA, NUM_PEDIDO;

/*
DELETE FROM PED_COMPRAS_ITENS;
DELETE FROM PED_COMPRAS;
UPDATE  ORDEM_PROD SET SITUACAO='A'
			WHERE SITUACAO='P'
            AND COD_EMPRESA=1;



------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
101.Procedure Gera Estoque 


*/
-- CRIANDO PROCEDURE PARA ALIMENTAR ESTOQUE
--REGRAS
/*
VERIFICAR SE A OPERACAO E PERMITIDA (-E ENTRADA E S SAIDA
VERIFICAR SE O MATERIAL EXISTE
-- VERIFICOES DE SAIDA
1 VERIFICAR SE MATERIAL TEM SALDO ESTOQUE E E QTD SAIDA E MENOR QUE SALDO
2 VERIFICAR SE MATERIAL TEM SALDO ESTOQUE_LOTE E E QTD SAIDA E MENOR QUE SALDO DO LOTE
-- VERIFICACOES ENTRADA
1 SE MATERIAL EXISTE UPDATE
2 SENAO EXISTE INSERT
TABELAS ENVOLVIDAS
ESTOQUE
ESTOQUE_LOTE
ESTQUE_MOV
-- EXECOES ROLLBACK


*/
-- CRIANDO PROCEDURE PARA ALIMENTAR ESTOQUE
--REGRAS
/*
VERIFICAR SE A OPERACAO E PERMITIDA (-E ENTRADA E S SAIDA
VERIFICAR SE O MATERIAL EXISTE

-- VERIFICOES DE SAIDA
1 VERIFICAR SE MATERIAL TEM SALDO ESTOQUE E E QTD SAIDA E MENOR QUE SALDO
2 VERIFICAR SE MATERIAL TEM SALDO ESTOQUE_LOTE E E QTD SAIDA E MENOR QUE SALDO DO LOTE

-- VERIFICACOES ENTRADA
1 SE MATERIAL EXISTE UPDATE
2 SENAO EXISTE INSERT
TABELAS ENVOLVIDAS
ESTOQUE
ESTOQUE_LOTE
ESTQUE_MOV
-- EXECOES ROLLBACK
*/

CREATE OR REPLACE PROCEDURE PRC_MOV_ESTOQUE (P_OPER IN VARCHAR2,
                                             P_EMP IN NUMBER,
                                             P_COD_MAT IN INT,
                                             P_LOTE IN VARCHAR2,
                                             P_QTD IN INT,
                                             P_DATA_MOV DATE)
IS

    EXC_MAT_N_EXISTE EXCEPTION;
    EXC_OPERACAO_NAO_PERMITIDA EXCEPTION;
    EXC_ESTOQUE_NEGATIVO EXCEPTION;
    EXC_ESTOQUE_NEGATIVO_LOTE EXCEPTION;
    
    V_SALDO_ESTOQUE INT;
    V_SALDO_ESTOQUE_LOTE INT;
    V_MAT_EXISTE INT ;
    V_REG_ESTOQUE INT;
    V_REG_ESTOQUE_LOTE INT;


BEGIN 
    -- VERIFICANDO SE OPERACAO É PERMITIDA;
    IF P_OPER NOT IN ('E','S') THEN
        RAISE EXC_OPERACAO_NAO_PERMITIDA;
    ELSE 
    dbms_output.put_line('OPERACAO OK! CONTINUA!');
    END IF;
    
    -- VERIFICANDO SE MATERIAL EXISTE
    SELECT COUNT(*) INTO V_MAT_EXISTE FROM MATERIAL WHERE COD_MAT = P_COD_MAT AND COD_EMPRESA = P_EMP;
    
    IF V_MAT_EXISTE = 0 THEN
        RAISE EXC_MAT_N_EXISTE;
    ELSE
        dbms_output.put_line('MATERIAL EXISTE! CONTINUA');
    END IF;
  
  --VERIFICANDO SE EXISTE REGISTRO EM ESTOQUE
  SELECT COUNT(*) INTO V_REG_ESTOQUE 
  FROM ESTOQUE 
  WHERE COD_MAT = P_COD_MAT AND COD_EMPRESA = P_EMP;
  
   dbms_output.put_line('QTD REG ESTOQUE '||V_REG_ESTOQUE);
   
  -- VERIFICANDO OPERACAO DE SAIDA SE MATERIAL EXISTE NAO ESTOQUE
  IF P_OPER = 'S' AND V_REG_ESTOQUE = 0 
  THEN
      RAISE EXC_ESTOQUE_NEGATIVO;
      ELSIF  P_OPER = 'S' AND V_REG_ESTOQUE > 0  THEN
       -- ATRIBUINDO SALDO DE ESTOQUE E QTD REGISTRO
        SELECT QTD_SALDO, COUNT(*) INTO V_SALDO_ESTOQUE, V_REG_ESTOQUE FROM ESTOQUE 
        WHERE COD_MAT = P_COD_MAT AND COD_EMPRESA = P_EMP
        GROUP BY QTD_SALDO;
        dbms_output.put_line('TEM ESTOQUE');
  END IF;
  
  --VERIFICANDO SE EXISTE REGISTRO EM ESTOQUE LOTE
  SELECT COUNT(*) INTO V_REG_ESTOQUE_LOTE 
  FROM ESTOQUE_LOTE 
  WHERE COD_MAT = P_COD_MAT AND LOTE = P_LOTE AND COD_EMPRESA = P_EMP;
  dbms_output.put_line('QTD REG ESTOQUE LOTE '||V_REG_ESTOQUE_LOTE);
  -- VERIFICANDO OPERACAO DE SAIDA SE MATERIAL EXISTE NAO ESTOQUE
  IF P_OPER = 'S' AND V_REG_ESTOQUE_LOTE = 0 
  THEN
      RAISE EXC_ESTOQUE_NEGATIVO_LOTE;
      ELSIF P_OPER = 'S' AND V_REG_ESTOQUE_LOTE > 0 THEN
      -- ATRIBUINDO SALDO DE ESTOQUE_LOTE E QTD REGISTRO
        SELECT SUM(QTD_LOTE), COUNT(*) INTO V_SALDO_ESTOQUE_LOTE, V_REG_ESTOQUE_LOTE FROM ESTOQUE_LOTE 
        WHERE COD_MAT = P_COD_MAT AND LOTE = P_LOTE AND COD_EMPRESA = P_EMP;
        dbms_output.put_line('TEM ESTOQUE LOTE');
  END IF;
  
  IF P_OPER = 'S' AND (V_SALDO_ESTOQUE_LOTE - P_QTD < 0 OR V_SALDO_ESTOQUE - P_QTD < 0) THEN
     RAISE EXC_ESTOQUE_NEGATIVO_LOTE;
    ELSIF P_OPER = 'S' AND  V_SALDO_ESTOQUE_LOTE - P_QTD >= 0 AND V_SALDO_ESTOQUE - P_QTD >= 0 THEN
    -- ATUALIZA ESTOQUE
    UPDATE ESTOQUE SET QTD_SALDO = QTD_SALDO - P_QTD WHERE COD_MAT = P_COD_MAT AND COD_EMPRESA = P_EMP;
    -- ATUALIZA ESTOQUE LOTE
    UPDATE ESTOQUE_LOTE SET QTD_LOTE = QTD_LOTE - P_QTD WHERE COD_MAT = P_COD_MAT AND LOTE = P_LOTE AND COD_EMPRESA = P_EMP;
    -- INSERE ESTOQUE TIP_MOV
    INSERT INTO ESTOQUE_MOV (id_mov,cod_empresa,tip_mov,cod_mat,lote,qtd,login,data_hora,DATA_MOV) 
			VALUES
				(NULL,P_EMP,P_OPER,P_COD_MAT,P_LOTE,P_QTD,USER,SYSDATE,P_DATA_MOV);
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('OPERACAO FINALIZADA');
    END IF;
    -- FINALIZA OPERACAO PARA SAIDA
    
    
    --INICIA OPERACAO PARA ENTRADA
    
    --VERIFCANDO SE MATERIAL TEM REGISTRO NA ESTOQUE E ESTOQUE LOTE
    IF P_OPER = 'E' AND V_REG_ESTOQUE_LOTE > 0 AND V_REG_ESTOQUE > 0 THEN
        -- ATUALIZANDO ESTOQUE
         UPDATE ESTOQUE SET QTD_SALDO = QTD_SALDO + P_QTD WHERE COD_MAT = P_COD_MAT AND COD_EMPRESA = P_EMP;
         
          -- ATUALIZANDO ESTOQUE_LOTE
         UPDATE ESTOQUE_LOTE SET QTD_LOTE = QTD_LOTE + P_QTD WHERE COD_MAT = P_COD_MAT AND LOTE = P_LOTE AND COD_EMPRESA = P_EMP;
         
         -- INSERE ESTOQUE TIP_MOV
         INSERT INTO ESTOQUE_MOV (id_mov,COD_EMPRESA,tip_mov,cod_mat,lote,qtd,login,data_hora,DATA_MOV) VALUES
            (nULL,P_EMP,P_OPER,P_COD_MAT,P_LOTE,P_QTD,USER,SYSDATE,P_DATA_MOV);
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('OPERACAO FINALIZADA');
        
        -- VERIFICA QUE EXISTE ESTOQUE MAS NAO EXISTE ESTOQUE LOTE PARA INSERT ESTOQUE LOTE E UPDATE ESTOQUE
    ELSIF P_OPER = 'E' AND V_REG_ESTOQUE_LOTE = 0 AND V_REG_ESTOQUE > 0 THEN
        -- ATUALIZANDO ESTOQUE
         UPDATE ESTOQUE SET QTD_SALDO = QTD_SALDO + P_QTD WHERE COD_MAT = P_COD_MAT AND COD_EMPRESA = P_EMP;
         
        --INSERINDO REGISTRO NA ESTOQUE LOTE
         INSERT INTO ESTOQUE_LOTE (COD_EMPRESA,COD_MAT,QTD_LOTE,LOTE) VALUES (P_EMP,P_COD_MAT,P_QTD,P_LOTE);
         
          -- INSERE ESTOQUE TIP_MOV
         INSERT INTO ESTOQUE_MOV (id_mov,COD_EMPRESA,tip_mov,cod_mat,lote,qtd,login,data_hora,DATA_MOV) VALUES
            (nULL,P_EMP,P_OPER,P_COD_MAT,P_LOTE,P_QTD,USER,SYSDATE,P_DATA_MOV);
         COMMIT;
        DBMS_OUTPUT.PUT_LINE('OPERACAO FINALIZADA');
        
        -- VERIFICANDO QUE NAO EXISTE ESTOQUE E ESTOQUE LOTE PARA INSERT
    ELSIF P_OPER = 'E' AND V_REG_ESTOQUE_LOTE = 0 AND V_REG_ESTOQUE = 0 THEN
        -- INSERINDO ESTOQUE
         INSERT INTO  ESTOQUE (COD_EMPRESA,COD_MAT,QTD_SALDO) VALUES (P_EMP,P_COD_MAT,P_QTD);
         
        --INSERINDO REGISTRO NA ESTOQUE LOTE
         INSERT INTO ESTOQUE_LOTE (COD_EMPRESA,COD_MAT,QTD_LOTE,LOTE) VALUES (P_EMP,P_COD_MAT,P_QTD,P_LOTE);
         
          -- INSERE ESTOQUE TIP_MOV
         INSERT INTO ESTOQUE_MOV (id_mov,COD_EMPRESA,tip_mov,cod_mat,lote,qtd,login,data_hora,DATA_MOV) VALUES
            (nULL,P_EMP,P_OPER,P_COD_MAT,P_LOTE,P_QTD,USER,SYSDATE,P_DATA_MOV);
         COMMIT;
        DBMS_OUTPUT.PUT_LINE('OPERACAO FINALIZADA');
    END IF;
    -- TERMINA ENTRADA
    --INICIA EXCESSOES
EXCEPTION
    when EXC_OPERACAO_NAO_PERMITIDA THEN
        DBMS_OUTPUT.PUT_LINE('A OPERACAO DEVER SER E-ENTRADA OU S-SAIDA');
        ROLLBACK;
     
     when EXC_MAT_N_EXISTE THEN
        DBMS_OUTPUT.PUT_LINE('MATERIAL NAO EXISTE CADASTRO');
        ROLLBACK;
     
    when EXC_ESTOQUE_NEGATIVO THEN
        DBMS_OUTPUT.PUT_LINE('ESTOQUE NEGATIVO,OPERACAO NAO PERMITIDA!!!');
        ROLLBACK;
     
    when EXC_ESTOQUE_NEGATIVO_LOTE THEN
        DBMS_OUTPUT.PUT_LINE('ESTOQUE LOTE NEGATIVO,OPERACAO NAO PERMITIDA!!!');
        ROLLBACK;
    
    when NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('REGISTRO NAO ENCONTRADO!');
        DBMS_OUTPUT.PUT_LINE('Linha: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
        ROLLBACK;
         
     WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('CODIGO DO ERRO '||SQLCODE||' MSG '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Linha: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE); -- AJUDA O PROGRAMADOR ENCONTRAR O ERRO!
        ROLLBACK;

end;

-- testando procedure

--PARAMETROS OPERACAO,COD_EMPRESA,MATERIAL,LOTE,QTD
/*
(P_OPER IN VARCHAR2,
 P_EMP IN NUMBER,
 P_COD_MAT IN INT,
 P_LOTE IN VARCHAR2,
 P_QTD IN INT,
 P_DATA_MOV DATE)
*/
-- testando procedure
execute PRC_MOV_ESTOQUE ('E',1,1,'ABC',10,'01/01/2018');

--PARAMETROS OPERACAO,COD_EMPRESA,MATERIAL,LOTE,QTD
execute PRC_MOV_ESTOQUE ('S',1,1,'ABC',10,'01/01/2018');


      
select * from ESTOQUE;
SELECT * FROM ESTOQUE_LOTE;
SELECT A.ID_MOV, 
       A.COD_EMPRESA, 
       A.TIP_MOV, 
       A.COD_MAT, 
       A.LOTE, 
       A.QTD, 
       A.DATA_MOV, 
       TO_CHAR(A.DATA_HORA,'DD/MM/YYYY HH24:MI:SS')AS DATA_HORA,
       A.LOGIN
FROM ESTOQUE_MOV A;

/*
DELETE from ESTOQUE;
DELETE FROM ESTOQUE_LOTE;
DELETE FROM ESTOQUE_MOV;
*/


select to_char(DATA_HORA,'cc dd/mm/yyyy hh24:mi:ss') data from ESTOQUE_MOV;
select to_char(sysdate,'cc dd/mm/yyyy hh24:mi:ss') data from dual;

select to_char(sysdate,'cc dd/mm/yyyy hh24:mi:ss'),
       to_char(current_date,'cc dd/mm/yyyy hh24:mi:ss'),
       sysdate,
       current_date from dual;
	   
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
102.Procedure Integra Nota Fiscal X Estoque 


-- OBJETIVO, INTEGRAR OS PEDIDOS DE COMPRA E VENDA NAS NOTAS FISCAIS...
--PROC_GERA_NF
--TABELAS ORIGEM: PED_VENDAS, PED_VENDAS_ITENS, PED_COMPRAS, PED_COMPRAS_ITENS

--TABELAS DESTINO: NOTA_FISCAL, NOTA_FISCAL_ITENS

--PARAMETROS: TIP_NF,
           -- DOCTO,
           -- CFOP,
           -- DATA_EMIS,
           -- DATA_ENTREGA
--EXEC PROC_GERA_NF 'S',4,'5.101','2017-01-30','2017-01-30'
--DROP  PROCEDURE PROC_GERA_NF 
CREATE OR REPLACE PROCEDURE PROC_GERA_NF (P_EMP IN NUMBER,
                                           TIP_NF IN VARCHAR2, --E = ENTRADA S= SAIDA
                                           DOCTO IN NUMBER,    --NUMERO DO PEDIDO QUE SERA GERADO NFE
                                           CFOP VARCHAR2,      -- Código Fiscal de Operações e Prestações
                                           DATA_EMIS DATE,
                                           DATA_ENTREGA DATE)
IS

        EXC_LANC_FUTURO  EXCEPTION;
        EXC_TIP_NF       EXCEPTION;
        EXC_PED_N_EXISTE EXCEPTION;
        EXC_QTD_PED_VEND EXCEPTION;
        EXC_QTD_PED_COMP EXCEPTION;
        
        V_SEQ_MAT INT;
        V_TOTAL_NFE NUMBER(10,2):=0;
        QTD_PED_V INT;
        QTD_PED_C INT;
        V_NUM_NF  NUMBER;
        V_DATA DATE := TRUNC(sysdate);

		 
BEGIN 
        --VERIFICA DATA DA EMISSAO MAIOR QUE  ATUAL
		IF (DATA_EMIS > V_DATA) THEN
            
            RAISE EXC_LANC_FUTURO;
        		
		END IF;
        
        --VEQTD_PED_CRIFICA TIPO MOVIMENTO
		
        IF (TIP_NF NOT IN ('S','E')) THEN
		 
            RAISE EXC_TIP_NF;
       
		END IF;
        
        --VERIFICA SE PEDIDO DE VENDA EXISTE
        SELECT COUNT(*) QTD INTO QTD_PED_V FROM PED_VENDAS A
		   WHERE A.NUM_PEDIDO = DOCTO
                 AND A.COD_EMPRESA = P_EMP
		         AND A.SITUACAO <> 'F'; -- FINALIZADO
        
		IF (TIP_NF = 'S' AND QTD_PED_V = 0) THEN
		 
		   RAISE EXC_QTD_PED_VEND;
           
		END IF;
        
         --VERIFICA SE PEDIDO DE COMPRA EXISTE
         SELECT COUNT(*) QTD INTO QTD_PED_C FROM PED_COMPRAS A
		   WHERE A.NUM_PEDIDO = DOCTO
                 AND A.COD_EMPRESA = P_EMP
		         AND A.SITUACAO <> 'F'; -- FINALIZADO
        
		 IF (TIP_NF = 'E' AND QTD_PED_C = 0) THEN
            
            RAISE  EXC_QTD_PED_COMP;
		   
		END IF;
        
--INICIO NOTA FISCAL DE SAIDA OU ENTRADA
   IF TIP_NF = 'S' THEN
		 	
    --CURSO FOR PARA LER PEDIDO DE SAIDA E MONTAR O CABEÇALHO DA NOTA
	FOR C_NF IN (SELECT A.COD_EMPRESA,A.NUM_PEDIDO,A.ID_CLIENTE ID_CLIFOR,A.COD_PAGTO
		FROM  PED_VENDAS A
		WHERE A.NUM_PEDIDO = DOCTO
        AND A.COD_EMPRESA = P_EMP
		AND A.SITUACAO <> 'F') LOOP  --FINALIZADO
   
   
       --INSERINDO DADOS DO CURSOR FOR C_NF
    INSERT INTO NOTA_FISCAL (COD_EMPRESA,NUM_NF,TIP_NF,COD_CFOP,ID_CLIFOR,COD_PAGTO,DATA_EMISSAO,DATA_ENTREGA,TOTAL_NF,INTEGRADA_FIN,INTEGRADA_SUP)
						VALUES
                            (P_EMP,NULL,TIP_NF,CFOP,C_NF.ID_CLIFOR,C_NF.COD_PAGTO,DATA_EMIS,DATA_ENTREGA,0,'N','N')
            
            RETURNING NUM_NF INTO V_NUM_NF; --PEGANDO VALOR DO NFE INSERIDO E ATRIBUINDO VALOR
				
        --APRESENTANDO VALORES CABECALHO
         DBMS_OUTPUT.PUT_LINE('NUM_NF: '||V_NUM_NF||' Tip NFE: '||TIP_NF||' CFOP: '||CFOP||' COD CLIFOR: '||C_NF.ID_CLIFOR||' COD PAGTO: '||C_NF.COD_PAGTO||' DATA_EMIS: '||DATA_EMIS||'DATA_ENTREGA: '||DATA_ENTREGA);

	--INICIO CURSRO DETALHES NFE
	--CURSOR DETALHE PED INICIO
	
	FOR C_NF_IT IN (SELECT A.SEQ_MAT,A.COD_MAT,A.QTD,A.VAL_UNIT 
		FROM PED_VENDAS_ITENS A
		WHERE A.NUM_PEDIDO = DOCTO
        AND COD_EMPRESA = P_EMP
		ORDER BY A.SEQ_MAT) LOOP
         --INSERINDO DADOS DO CURSOR FOR C_NF_IT
				INSERT INTO NOTA_FISCAL_ITENS (COD_EMPRESA,NUM_NF,SEQ_MAT,COD_MAT,QTD,VAL_UNIT,PED_ORIG)
                VALUES
			   (P_EMP,V_NUM_NF,C_NF_IT.SEQ_MAT,C_NF_IT.COD_MAT,C_NF_IT.QTD,C_NF_IT.VAL_UNIT,DOCTO);
			
			--APRESENTANDO VALORES
			 DBMS_OUTPUT.PUT_LINE ('SEQ: '||C_NF_IT.SEQ_MAT||' COD MAT: '||C_NF_IT.COD_MAT||' QTD:'||C_NF_IT.QTD||' VAL_UNIT: '||C_NF_IT.VAL_UNIT);
			--ATRIBUINDO VALORES
		
			 V_TOTAL_NFE := V_TOTAL_NFE + (C_NF_IT.QTD * C_NF_IT.VAL_UNIT);
			--SELECT TOTAL_NFE
	--FINAL CURSOR DETALHES

END LOOP; -- CURSOR NFE IT
  
    --ATUALIZANDO TOTAL NFE
		UPDATE NOTA_FISCAL SET TOTAL_NF = V_TOTAL_NFE WHERE NUM_NF = V_NUM_NF AND COD_EMPRESA = P_EMP;
		--ATUALIZADO STATUS PARA FECHADO NFE
		UPDATE PED_VENDAS  SET SITUACAO = 'F' WHERE NUM_PEDIDO = DOCTO AND COD_EMPRESA = P_EMP;
        
        
END LOOP; -- CURSOR NFE CABEÇALHO
	--FINAL CURSOR NFE

--ELSEIF PARA ENTRADA
ELSIF TIP_NF = 'E' THEN
    
    FOR C_NF IN (SELECT A.COD_EMPRESA,A.NUM_PEDIDO,A.ID_FOR AS ID_CLIFOR,A.COD_PAGTO
		FROM  PED_COMPRAS A
		WHERE A.NUM_PEDIDO = DOCTO
        AND A.COD_EMPRESA = P_EMP
		AND A.SITUACAO <> 'F') LOOP --FINALIZADO
     
       --INSERINDO DADOS DO CURSOR FOR
    INSERT INTO NOTA_FISCAL (COD_EMPRESA,NUM_NF,TIP_NF,COD_CFOP,ID_CLIFOR,COD_PAGTO,DATA_EMISSAO,DATA_ENTREGA,TOTAL_NF,
                                 INTEGRADA_FIN,INTEGRADA_SUP)
			VALUES
			(P_EMP,NULL,TIP_NF,CFOP,C_NF.ID_CLIFOR,C_NF.COD_PAGTO,DATA_EMIS,DATA_ENTREGA,0,'N','N')
            
            RETURNING NUM_NF INTO V_NUM_NF; --PEGANDO VALOR DO NFE INSERIDO E ATRIBUINDO VALOR
				
        --APRESENTANDO VALORES CABECALHO
        DBMS_OUTPUT.PUT_LINE('NUM_NF: '||V_NUM_NF||'Tip NFE: '||TIP_NF||' CFOP: '||CFOP||' COD CLIFOR: '||C_NF.ID_CLIFOR||'COD PAGTO: '||C_NF.COD_PAGTO||' DATA_EMIS: '|| DATA_EMIS||'DATA_ENTREGA: '||DATA_ENTREGA);

	--INICIO CURSRO DETALHES NFE
	--CURSOR DETALHE PED INICIO
	
	FOR C_NF_IT IN (SELECT A.SEQ_MAT,A.COD_MAT,A.QTD,A.VAL_UNIT 
		FROM PED_COMPRAS_ITENS A
		WHERE A.NUM_PEDIDO = DOCTO
        AND COD_EMPRESA = P_EMP
		ORDER BY A.SEQ_MAT) LOOP

				INSERT INTO NOTA_FISCAL_ITENS (COD_EMPRESA,NUM_NF,SEQ_MAT,COD_MAT,QTD,VAL_UNIT,PED_ORIG)
                VALUES
			   (P_EMP,V_NUM_NF,C_NF_IT.SEQ_MAT,C_NF_IT.COD_MAT,C_NF_IT.QTD,C_NF_IT.VAL_UNIT,DOCTO);
			
			--APRESENTANDO VALORES
			 DBMS_OUTPUT.PUT_LINE ('SEQ: '||C_NF_IT.SEQ_MAT||'COD MAT: '||C_NF_IT.COD_MAT||'QTD: '||C_NF_IT.QTD||' VAL_UNIT: '||C_NF_IT.VAL_UNIT);
			--ATRIBUINDO VALORES
		
			V_TOTAL_NFE := V_TOTAL_NFE + (C_NF_IT.QTD * C_NF_IT.VAL_UNIT);
			--SELECT TOTAL_NFE
	--FINAL CURSOR DETALHES

END LOOP; -- CURSOR NFE IT
  
    --ATUALIZANDO TOTAL NFE
		UPDATE NOTA_FISCAL SET TOTAL_NF = V_TOTAL_NFE WHERE NUM_NF = V_NUM_NF AND COD_EMPRESA = P_EMP;
		--ATUALIZADO STATUS PARA FECHADO NFE
		UPDATE PED_COMPRAS  SET SITUACAO = 'F' WHERE NUM_PEDIDO = DOCTO AND COD_EMPRESA = P_EMP;
        
        
END LOOP; -- CURSOR NFE CABEÇALHO
	--FINAL CURSOR NFE
  
END IF;
	
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('FINALIZADA COM SUCESSO!');
  
 
 --VALIDACOES FINAIS
EXCEPTION
    WHEN EXC_LANC_FUTURO THEN
        DBMS_OUTPUT.PUT_LINE('NAO PERMITIDO LANCAMENTOS FUTUROS!');
        
        ROLLBACK;
    
      WHEN EXC_TIP_NF THEN
        DBMS_OUTPUT.PUT_LINE('OPERACAO NAO PERMITIDA!');
        ROLLBACK;
        
        
    WHEN  EXC_QTD_PED_VEND THEN
        DBMS_OUTPUT.PUT_LINE('NAO A PEDIDO DE VENDAS DISPONIVEL PARA SAIDA!');     
        ROLLBACK;
        
    WHEN  EXC_QTD_PED_COMP THEN
        DBMS_OUTPUT.PUT_LINE('NAO A PEDIDO DE COMPRAS DISPONIVEL PARA ENTRADA');
        
     WHEN  NO_DATA_FOUND  THEN
        DBMS_OUTPUT.PUT_LINE('NAO EXISTE DADOS!');
        
     WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('OUTROS CODIGO DO ERRO '||SQLCODE||' MSG '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Linha: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
        ROLLBACK;

END; --END PROCEDURE


   
/*
SELECT * FROM NOTA_FISCAL_ITENS
--PARAMENTROS                  P_EMP IN NUMBER,
                               TIP_NF IN CHAR(1),--E = ENTRADA S= SAIDA
                               DOCTO IN NUMBER, --NUMERO DO PEDIDO QUE SERA GERADO NFE
							   CFOP VARCHAR2,
							   DATA_EMIS DATE,
							   DATA_ENTREGA
*/                               

SET SERVEROUTPUT ON    
EXECUTE PROC_GERA_NF (1,'S',1,'5.101','21/01/2018','22/01/2018');
EXECUTE PROC_GERA_NF (1,'S',2,'5.101','21/01/2018','22/01/2018');
EXECUTE PROC_GERA_NF (1,'S',3,'5.101','21/01/2018','22/01/2018');
EXECUTE PROC_GERA_NF (1,'S',4,'5.101','21/01/2018','22/01/2018');

EXECUTE PROC_GERA_NF (1,'E',7,'1.101','21/01/2018','22/01/2018');
EXECUTE PROC_GERA_NF (1,'E',8,'1.101','21/01/2018','22/01/2018');
EXECUTE PROC_GERA_NF (1,'E',9,'1.101','21/01/2018','22/01/2018');
EXECUTE PROC_GERA_NF (1,'E',10,'1.101','21/01/2018','22/01/2018');



/*
SELECT COD_EMPRESA,NUM_PEDIDO,SITUACAO FROM PED_VENDAS;
SELECT  COD_EMPRESA,NUM_PEDIDO,SITUACAO FROM PED_COMPRAS;

SELECT * FROM NOTA_FISCAL
ORDER BY NUM_NF;
WHERE NUM_NF=7
AND COD_EMPRESA=1;

SELECT  * FROM NOTA_FISCAL_ITENS
WHERE NUM_NF=7
AND COD_EMPRESA=1

SELECT  * FROM PED_VENDAS_ITENS;
SELECT  * FROM PED_COMPRAS_ITENS
WHERE COD_EMPRESA=1
AND NUM_PEDIDO=9
*/

--DELETE FROM NOTA_FISCAL_ITENS;
--DELETE FROM NOTA_FISCAL;
/*
UPDATE  PED_VENDAS SET SITUACAO='P' WHERE SITUACAO='F' ;
UPDATE  PED_COMPRAS SET SITUACAO='P' WHERE SITUACAO='F' ;
*/

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
103. Procedure Integra Nota Fiscaal X Estoque 

--@TIPO_MOV, COD_MAT,@LOTE, QTD_MOV
--EXEC PROC_GERA_ESTOQUE 
--CRIACAO PROC_INTEGR_NF_ESTOQUE
--EXECUTE PROC_INTEGR_NF_ESTOQUE 10,'2017-01-30'
--SELECT * FROM NOTA_FISCAL
--SELECT * FROM NOTA_FISCAL_ITENS
--UPDATE NOTA_FISCAL SET INTEGRADA_SUP = 'N' WHERE NUM_NF = '2'
--SELECT * FROM ESTOQUE
--SELECT * FROM ESTOQUE_LOTE
--SELECT * FROM ESTOQUE_MOV
CREATE OR REPLACE PROCEDURE PROC_INTEGR_NF_ESTOQUE (P_EMP IN NUMBER,
                                                    P_NUM_NF NUMBER,
                                                    P_DATA_MOVTO DATE)

IS

        V_EXC_SALDO_INSUFICIENTE EXCEPTION;
        V_EXC_DOCT_NAO_EXISTE EXCEPTION;
        V_EXC_INTEGRADO EXCEPTION;
        
        V_QTD_AUX NUMBER(10,2);
        V_QTD_TOT NUMBER(10,2);
        V_TIP_OPER VARCHAR2(1);
        V_SITUA VARCHAR2(1);
        V_CONT INT;
        V_NUM_NF NUMBER;
        V_MAT_AUX NUMBER;
        V_SALDO_AUX NUMBER(10,2);

 BEGIN 
    
    --VERIFICANDO SE DOCTO EXISTEM, E SE JA ESTA INTEGRADO
SELECT NUM_NF, TIP_NF, INTEGRADA_SUP, COUNT(*) QTD INTO V_NUM_NF, V_TIP_OPER, V_SITUA, V_CONT FROM NOTA_FISCAL
  WHERE COD_EMPRESA = P_EMP AND NUM_NF = P_NUM_NF
  GROUP BY NUM_NF, TIP_NF, INTEGRADA_SUP;
  --VERIFICA SE EXISTE DOCTO
  IF V_CONT = 0 THEN
  RAISE V_EXC_DOCT_NAO_EXISTE;
  END IF;
  --VERIFICA SE ESTA INTEGRADO
  IF V_CONT = 1 AND V_SITUA = 'S' THEN
    RAISE V_EXC_INTEGRADO;
  END IF;
  
  --VERIFCANDO SE NOTA DE ENTRADA PARA DAR ENTRADA EM ESTOQUE;
  -- NOTA FISCAL DE ENTRADA E UM POUCO MAIS SIMPLES, PQ NAO CHECA O SALDO
  IF V_TIP_OPER = 'E' THEN
  
  FOR C_NF_IT IN (
  SELECT A.COD_EMPRESA, 
		 A.TIP_NF, B.COD_MAT,
		 TO_CHAR(SYSDATE,'DD-MM')||'-'||A.NUM_NF AS LOTE,
			--COMPOSICAO CAMPO LOTE (DIA MES + NUMERO DA NF)
			B.QTD 
			FROM NOTA_FISCAL A
			
            INNER JOIN NOTA_FISCAL_ITENS B
			ON A.COD_EMPRESA = B.COD_EMPRESA
            AND A.NUM_NF = B.NUM_NF
            
			WHERE A.NUM_NF = P_NUM_NF --PARAMETRO
            AND A.COD_EMPRESA = P_EMP --PARAMENTO
            AND A.TIP_NF = 'E'
			AND A.INTEGRADA_SUP = 'N') LOOP
            
            --EXECUTANDO PROCEDURE QUE MOVIMENTA ESTOQUE PARA DAR ENTRADA NO MATERIAL
            PRC_MOV_ESTOQUE (C_NF_IT.TIP_NF,P_EMP,C_NF_IT.COD_MAT,C_NF_IT.LOTE,C_NF_IT.QTD,P_DATA_MOVTO);
            
    END LOOP;
    
     UPDATE NOTA_FISCAL SET INTEGRADA_SUP = 'S'  WHERE NUM_NF = P_NUM_NF AND COD_EMPRESA = P_EMP;
     COMMIT;
		    DBMS_OUTPUT.PUT_LINE ('ENTRADA CONCLUIDA!');
    
    --OPERACAO DE SAIDA /REGRA NAO PODE SAIR MAIS QUE O SALDO
    ELSIF V_TIP_OPER = 'S' THEN
    --ABRINDO CURSOR DOS ITENS DA NF
     FOR C_NF_IT IN (SELECT A.COD_EMPRESA,
                            A.TIP_NF,B.COD_MAT,
                         --TO_CHAR(SYSDATE,'DD-MM')||'-'||A.NUM_NF LOTE,
                         --COMPOSICAO CAMPO LOTE (DIA MES + NUMERO DA NF)
                            B.QTD 
			FROM NOTA_FISCAL A
			INNER JOIN NOTA_FISCAL_ITENS B
			ON A.COD_EMPRESA=B.COD_EMPRESA
            AND A.NUM_NF=B.NUM_NF
            AND A.COD_EMPRESA=P_EMP --PARAMENTO
			WHERE A.NUM_NF=P_NUM_NF --PARAMETRO
            AND A.TIP_NF='S'
			AND A.INTEGRADA_SUP='N') LOOP 
     
     --ABRINDO CURSOR DO MATERIAIS EM ESTQUE DOS ITENS DA NF
     FOR C_ESTOQUE IN (SELECT A.COD_EMPRESA,A.COD_MAT,A.QTD_SALDO FROM ESTOQUE A
                        WHERE A.COD_EMPRESA=P_EMP AND A.COD_MAT=C_NF_IT.COD_MAT) LOOP
        --VERIFICA SE SALDO DISPONIVEL PARA SAIDA                
        IF (C_NF_IT.QTD > C_ESTOQUE.QTD_SALDO) THEN
        
            RAISE V_EXC_SALDO_INSUFICIENTE;
            
        END IF;
        
        END LOOP; --LOOP C_ESTOQUE
        
        END LOOP; --LOOP C_NF_IT
        
    END IF;  
    
    --GERANDO MOVIMENTAÇÃO DE SAIDA
    IF V_TIP_OPER = 'S' THEN
    --ABRINDO CURSOR DOS ITENS DA NF
     
     FOR C_NF_IT IN (SELECT A.COD_EMPRESA,A.TIP_NF,B.COD_MAT,
			--TO_CHAR(SYSDATE,'DD-MM')||'-'||A.NUM_NF LOTE,
			--COMPOSICAO CAMPO LOTE (DIA MES + NUMERO DA NF)
			B.QTD 
			FROM NOTA_FISCAL A
			INNER JOIN NOTA_FISCAL_ITENS B
			ON A.COD_EMPRESA=B.COD_EMPRESA
            AND A.NUM_NF=B.NUM_NF
            AND A.COD_EMPRESA=P_EMP --PARAMENTO
			WHERE A.NUM_NF=P_NUM_NF --PARAMETRO
            AND A.TIP_NF='S'
			AND A.INTEGRADA_SUP='N') LOOP
            
           -- <<PROXIMO_MAT>>
        
        --ATRIBUINDO A QUANTIDADE NECESSARIA PARA BAIXA EM ESTOQUE
        V_SALDO_AUX := C_NF_IT.QTD;
    
   FOR C_EST_LOTE IN (SELECT A.COD_EMPRESA,A.COD_MAT,A.LOTE,A.QTD_LOTE FROM ESTOQUE_LOTE A
    WHERE A.COD_EMPRESA = P_EMP 
     AND A.COD_MAT = C_NF_IT.COD_MAT 
     ORDER BY A.COD_MAT,A.LOTE ) LOOP
        
        --SE SALDO IGUAL A ZERO LER PROXIMO MATERIAL
        IF V_SALDO_AUX = 0 THEN
        
            EXIT;
        
        END IF;
        
        IF (V_SALDO_AUX <= C_EST_LOTE.QTD_LOTE) THEN
        --EXECUTANDO PROCEDURE QUE MOVIMENTA ESTOQUE PARA DAR ENTRADA NO MATERIAL
        PRC_MOV_ESTOQUE (C_NF_IT.TIP_NF,P_EMP,C_EST_LOTE.COD_MAT,C_EST_LOTE.LOTE,V_SALDO_AUX,P_DATA_MOVTO);
        --SUBSTRAINDO QTD BAIXADA
        V_SALDO_AUX := V_SALDO_AUX - V_SALDO_AUX;
        
        ELSIF (V_SALDO_AUX > C_EST_LOTE.QTD_LOTE) THEN
         --EXECUTANDO PROCEDURE QUE MOVIMENTA ESTOQUE PARA DAR ENTRADA NO MATERIAL
        PRC_MOV_ESTOQUE (C_NF_IT.TIP_NF,P_EMP,C_EST_LOTE.COD_MAT,C_EST_LOTE.LOTE,C_EST_LOTE.QTD_LOTE,P_DATA_MOVTO);
            
        V_SALDO_AUX := V_SALDO_AUX - C_EST_LOTE.QTD_LOTE;
        END IF;
    
       
    
    END LOOP; --C_EST_LOTE
    END LOOP; --C_NF_IT
    
    UPDATE NOTA_FISCAL SET INTEGRADA_SUP = 'S'  WHERE NUM_NF = P_NUM_NF AND COD_EMPRESA = P_EMP;
     COMMIT;
		    DBMS_OUTPUT.PUT_LINE ('SAIDA CONCLUIDA!');
    END IF;
    

 --VALIDACOES FINAIS
    EXCEPTION
    WHEN V_EXC_SALDO_INSUFICIENTE THEN
        DBMS_OUTPUT.PUT_LINE('SALDO INSUFICIENTE!'); 
        ROLLBACK;
    
      WHEN V_EXC_DOCT_NAO_EXISTE THEN
        DBMS_OUTPUT.PUT_LINE('DOCUMENTO NAO EXISTE!');
        ROLLBACK;
        
        
    WHEN  V_EXC_INTEGRADO THEN
        DBMS_OUTPUT.PUT_LINE('DOCTO JA INTEGRADO!');     
        ROLLBACK;
        
     WHEN  NO_DATA_FOUND  THEN
        DBMS_OUTPUT.PUT_LINE('NAO EXISTE DADOS!');
        ROLLBACK;
        
     WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('OUTROS CODIGO DO ERRO '||SQLCODE||' MSG '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Linha: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
        ROLLBACK;

END; --END PROCEDURE      
        
        

--SELECT * FROM NOTA_FISCAL
--UPDATE NOTA_FISCAL SET INTEGRADA_SUP='N'
/*
SELECT * FROM ESTOQUE
SELECT * FROM ESTOQUE_MOV
SELECT * FROM ESTOQUE_LOTE
*/

/*
DELETE FROM ESTOQUE;
DELETE FROM ESTOQUE_MOV;
DELETE FROM ESTOQUE_LOTE;
*/
--SELECT * FROM PED_VENDAS_ITENS
--SELECT * FROM PED_VENDAS
--SELECT * FROM PED_COMPRAS
--SELECT * FROM NOTA_FISCAL ORDER BY NUM_NF;
--SELECT * FROM NOTA_FISCAL_ITENS WHERE COD_EMPRESA=1 AND NUM_NF='4' ORDER BY NUM_NF;

--PARAMENTROS (P_EMP IN NUMBER, P_NUM_NF NUMBER, P_DATA_MOVT
--SIMULANDO ENTRADA
EXECUTE PROC_INTEGR_NF_ESTOQUE (1,15,'15/01/2018');

--ALIMENTANDO ESTOQUE PARA NOTA DE SAIDA]
--SAIDA
EXECUTE PRC_MOV_ESTOQUE ('E',1,1,'AB',20,SYSDATE);
EXECUTE PRC_MOV_ESTOQUE ('E',1,1,'CD',30,SYSDATE);
EXECUTE PRC_MOV_ESTOQUE ('E',1,2,'EF',20,SYSDATE);
EXECUTE PRC_MOV_ESTOQUE ('E',1,2,'GH',15,SYSDATE);

--PARAMENTROS (P_EMP IN NUMBER, P_NUM_NF NUMBER, P_DATA_MOVT
SET SERVEROUTPUT ON
EXECUTE PROC_INTEGR_NF_ESTOQUE (1,12,'15/01/2018');

--SELECT * FROM ESTOQUE WHERE COD_MAT IN (1,2) AND COD_EMPRESA=1;
--SELECT * FROM ESTOQUE_LOTE WHERE COD_MAT IN (1,2) AND COD_EMPRESA=1;
--SELECT * FROM ESTOQUE_MOV ORDER BY ID_MOV

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
104.Procedure Integração Financeira 

--SELECT * FROM CONTAS_PAGAR
--SELECT * FROM CONTAS_RECEBER
--PROCEDURE INTEGRA CAP E CRE
--ORIGEM NOTA_FISCAL ENTRADA SAIDA
--SE SAIDA DESTINO CONTAS A RECEBER
--SE ENTRADA DESTINO CONTAS A PAGAR
--SEM PARAMETROS EXTERNOS, APENAS INTERNOS
--EXEC PROC_INTEGR_FIN
CREATE OR REPLACE PROCEDURE PROC_INTEGR_FIN 

IS 
    
 V_EXECP_SEM_DOCTO EXCEPTION;
 
 BEGIN 
 --ABRINDO PRIMEIRO IF
 FOR C_CONTA IN  (SELECT COUNT(*) QTD FROM NOTA_FISCAL WHERE INTEGRADA_FIN = 'N') LOOP --SELECT * FROM NOTA_FISCAL;
 
   IF C_CONTA.QTD = 0 THEN
        RAISE V_EXECP_SEM_DOCTO;
   END IF;
   
 END LOOP;
    
   --DECLARANDO CURSOR PARA INTEGRAR PARCELAS
  
   --SELECIONANDO REGISTROS
  FOR C_FIN IN (SELECT A.COD_EMPRESA, A.TIP_NF, A.NUM_NF, B.PARC, A.ID_CLIFOR, A.COD_PAGTO,
		  A.DATA_EMISSAO,
		  A.DATA_EMISSAO + B.DIAS AS VENCIMENTO,
		  A.TOTAL_NF,
		  CAST(A.TOTAL_NF / 100 * B.PCT AS DECIMAL(10,2)) AS VALOR_PARC
   FROM NOTA_FISCAL A  
   INNER JOIN COND_PAGTO_DET B
     ON A.COD_PAGTO = B.COD_PAGTO
   WHERE A.INTEGRADA_FIN = 'N'
   ORDER BY A.COD_EMPRESA, A.NUM_NF, B.PARC) LOOP
  
  	--IF PARA INTEGRAR NOTAS DE VENDAS SAIDAS
	IF C_FIN.TIP_NF = 'S' THEN
	  
		INSERT INTO CONTAS_RECEBER (COD_EMPRESA,ID_DOC,ID_CLIENTE,ID_DOC_ORIG,PARC,DATA_VENC,VALOR)
        VALUES (C_FIN.COD_EMPRESA,NULL,C_FIN.ID_CLIFOR,C_FIN.NUM_NF,C_FIN.PARC,C_FIN.VENCIMENTO,C_FIN.VALOR_PARC);
		
	 
	--IF PARA INTEGRAR NOTAS DE COMPRAS ENTRADASS
	ELSIF C_FIN.TIP_NF = 'E' THEN
	 
        INSERT INTO CONTAS_PAGAR (COD_EMPRESA,ID_DOC,ID_FOR,ID_DOC_ORIG,PARC,DATA_VENC,VALOR)
        VALUES (C_FIN.COD_EMPRESA,NULL,C_FIN.ID_CLIFOR,C_FIN.NUM_NF,C_FIN.PARC,C_FIN.VENCIMENTO,C_FIN.VALOR_PARC);
		 		
	END IF;
    --IF PARA ATUALIZAR STATUS NA NF
	
	  --ATUALIZANDO STATUS DE NOTA FISCAL PARA INTEGRADA_FIN=S
	
    UPDATE NOTA_FISCAL SET INTEGRADA_FIN = 'S' WHERE NUM_NF = C_FIN.NUM_NF AND COD_EMPRESA = C_FIN.COD_EMPRESA -- S: SIM
    AND INTEGRADA_FIN = 'N' ; -- NAO...
	
  END LOOP;
    
    DBMS_OUTPUT.PUT_LINE('INTEGRACAO CONCLUIDA');
    COMMIT;
    
     --VALIDACOES FINAIS
EXCEPTION
    WHEN V_EXECP_SEM_DOCTO THEN
        DBMS_OUTPUT.PUT_LINE('NÃO EXISTEM DOCUMENTOS PARA INTEGRACAO!');
        ROLLBACK;
    
        
     WHEN  NO_DATA_FOUND  THEN
        DBMS_OUTPUT.PUT_LINE('NAO EXISTE DADOS!');
        ROLLBACK;
        
     WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('OUTROS CODIGO DO ERRO '||SQLCODE||' MSG '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Linha: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
        ROLLBACK;

END; --END PROCEDURE 

    
     --VALIDACOES FINAIS
EXCEPTION
    WHEN V_EXECP_SEM_DOCTO THEN
        DBMS_OUTPUT.PUT_LINE('NÃO EXISTEM DOCUMENTOS PARA INTEGRACAO!');
        ROLLBACK;
    
        
     WHEN  NO_DATA_FOUND  THEN
        DBMS_OUTPUT.PUT_LINE('NAO EXISTE DADOS!');
        ROLLBACK;
        
     WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('OUTROS CODIGO DO ERRO '||SQLCODE||' MSG '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Linha: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
        ROLLBACK;

END; --END PROCEDURE 

--EXECUTANDO PROC
SET SERVEROUTPUT ON
EXECUTE PROC_INTEGR_FIN;

SELECT * FROM CONTAS_PAGAR;
SELECT * FROM CONTAS_RECEBER;
--DELETE FROM CONTAS_RECEBER
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
105. Procedure Apontamento de Producao 

--PROCEDURE PRODUCAO
--GERA MOVIMENTA DE ENTRADA ESTOQUE DO PRODUTO APONTADO
--GERA MOVIMENTO DE SAIDA ESTOQUE DOS PRODUTOS CONSUMIDOS CONFORME FICHA TECNICA
--ALIMENTA TABELA CONSUMO PARA RASTREABILIDADE
--ALIMENTA TABELA APONTAMENTO PARA RASTREABILIDADE
--ATUALIZA TABELAS ORDEM_PROD QTD_PROD E SITUACAO = F FINALIZADO , QUANDO QTD_PLAN = QTD_PROD
--PARAMETROS, ID_ORDEM,COD_MAT_PROD,QTD_APONT, LOTE
--CONSISTENCIAS DE ESTOQUE
--ORDEM_PROD SITUACAO = A NAO GEROU PEDIDO DE COMPRAS
--ORDEM_PROD SITUACAO = P GEROU PEDIDO DE COMPRAS
--ORDEM_PROD SITUACAO = F FINALIZADA

--SELECT * FROM ORDEM_PROD

--SELECT * FROM ORDEM_PROD
--EXEC PROC_APONTAMENTO 1,1,10,TESTE1
CREATE OR REPLACE PROCEDURE PROC_APONTAMENTO (P_EMP IN NUMBER,
                                              P_ID_ORDEM IN INT,
                                              P_COD_MAT_PROD IN NUMBER,
                                              P_QTD_APON IN NUMBER,
                                              P_LOTE_PROD VARCHAR2)
IS


        V_ORDER_N_EXISTE    EXCEPTION;
        V_MAT_NEC_INSUF     EXCEPTION;
        V_SALDO_INSUF_ORDEM EXCEPTION;
        
        V_CONT_OP INT;
		P_QTD_PLAN DECIMAL(10,2);
		P_QTD_PROD DECIMAL(10,2);
		--P_LOTE_PROD VARCHAR(20),
		P_SALDO DECIMAL(10,2);
		P_SALDO_AUX DECIMAL(10,2);
		--P_SITUACAO VARCHAR(1);
		
		P_DATA_MOVTO DATE;
		P_ID_APON INT;
        
		--P_COD_MAT_NECES INT,
		P_QTD_ATEND DECIMAL(10,2);
		--P_QTD_LOTE DECIMAL(10,2),
		--P_TESTE INT,
		P_COD_MAT_AUX INT;
		--P_QTD_NECES_CONS DECIMAL(10,2),
		--P_LOTE VARCHAR(20),
		--P_QTD_NECES DECIMAL(10,2)


--SET P_ID_ORDEM=23
--SET P_COD_MAT_PROD=1
--SET P_QTD_APON=1
--SET P_LOTE_PROD='TESTE4'
 -- P_DATA_MOVTO:=;

BEGIN 

--ATRIBUINDO VALOR A VARIAVEL P_DATA_MOVTO
SELECT SYSDATE INTO P_DATA_MOVTO FROM DUAL;

--PRIMEIRA ETAPA APONTAMENTO ATUALIZA ORDEM E MOVIMENTA ESTOQUE
--PRIMEIRO IF CHECK DE EXISTE ORDEM E SE POSSUI SALDO PARA SELECAO
   SELECT COUNT(*) CONT, A.QTD_PLAN, A.QTD_PROD INTO V_CONT_OP, P_QTD_PLAN, P_QTD_PROD FROM ORDEM_PROD A
	WHERE A.COD_MAT_PROD = P_COD_MAT_PROD
	AND A.ID_ORDEM = P_ID_ORDEM
    AND A.COD_EMPRESA = P_EMP
	AND A.SITUACAO = 'P'
    GROUP BY A.QTD_PLAN, A.QTD_PROD; --APENAS ORDEM PLANEJADAS
    
    --ATRIBUINDO SALDO
    P_SALDO:= P_QTD_PLAN - P_QTD_PROD;
    --VERIFICA SE EXISTE ORDEM
    IF V_CONT_OP = 0 THEN
    
        RAISE V_ORDER_N_EXISTE;
     --VERIFICA SE A A OP DISPONIVEL TEM SALDO SUFICIENTE   
     --VERIFANDO QTD APONTADA > SALDO PARA NAO PERMITIR APONTAMENTO
    ELSIF V_CONT_OP = 1 AND P_SALDO < P_QTD_APON THEN
        
        RAISE V_SALDO_INSUF_ORDEM;
        
    END IF;
	
--VERIFANDO SE MATERIAIS NECESSARIOS TEM SALDO PARA CONSUMO
FOR C_MAT_NECES IN(SELECT  B.COD_MAT_NECES,
						   B.QTD_NECES * P_QTD_APON AS QTD_NECES,
						   NVL(C.QTD_SALDO,0) SALDO,
						   NVL(C.QTD_SALDO,0) - (B.QTD_NECES * P_QTD_APON) AS SALDO_DISP
	
	 FROM ORDEM_PROD A
	INNER JOIN FICHA_TECNICA B
	ON A.COD_MAT_PROD=B.COD_MAT_PROD
    AND A.COD_EMPRESA=B.COD_EMPRESA
    
	LEFT JOIN  ESTOQUE C
	ON B.COD_MAT_NECES=C.COD_MAT
    AND A.COD_EMPRESA=B.COD_EMPRESA
    
	WHERE A.ID_ORDEM=P_ID_ORDEM --PARAMENTRO DE OP
    AND A.COD_EMPRESA=P_EMP) LOOP --PARAMENTRO DE EMRPESA
	
    --VERIFICOES
    IF C_MAT_NECES.SALDO_DISP<=0 THEN
        
        RAISE V_MAT_NEC_INSUF;
        
    END IF;
    
    END LOOP; --FIM CURSOR C_MAT_NECES
    
    	--DECLARANDO CURSO DE APONTAMENTO
	
	--SELECIONANDO VALORES
FOR C_APONT IN (SELECT A.ID_ORDEM, A.COD_MAT_PROD, A.QTD_PLAN, A.QTD_PROD
				FROM ORDEM_PROD A
				WHERE A.COD_MAT_PROD = P_COD_MAT_PROD
				AND ID_ORDEM = P_ID_ORDEM
				AND A.COD_EMPRESA = P_EMP
				AND A.SITUACAO = 'P') LOOP --APENAS ORDEM PLANEJADAS

	--ATRIBUINDO VALORES
	P_SALDO:= C_APONT.QTD_PLAN - C_APONT.QTD_PROD;
	P_SALDO_AUX := P_SALDO;	
	
	    --INSERT NA TABELA APONTAMENTOS PARA RASTREABILIDADE
        
		INSERT INTO APONTAMENTOS (COD_EMPRESA,ID_APON,ID_ORDEM,COD_MAT_PROD,QTD_APON,DATA_APON,LOGIN,LOTE)
				VALUES 
					(P_EMP,NULL,P_ID_ORDEM,P_COD_MAT_PROD,P_QTD_APON,SYSDATE,USER,P_LOTE_PROD)
        RETURNING ID_APON INTO P_ID_APON;
		
		--EXECUTA PROC GERA ESTOQUE
          PRC_MOV_ESTOQUE ('E',P_EMP,P_COD_MAT_PROD,P_LOTE_PROD,P_QTD_APON,P_DATA_MOVTO);
		--UPDATE SALDO DA ORDEM
        
        DBMS_OUTPUT.PUT_LINE('APONTAMENTO');
        DBMS_OUTPUT.PUT_LINE('ORDEM: '||P_ID_ORDEM||' MAT PRODUZIDO: '||P_COD_MAT_PROD||' QTD: '||P_QTD_APON||' LOTE: '||P_LOTE_PROD );
       
		UPDATE ORDEM_PROD SET QTD_PROD = P_QTD_PROD + P_QTD_APON
		WHERE ID_ORDEM = P_ID_ORDEM
		      AND COD_MAT_PROD = P_COD_MAT_PROD
              AND COD_EMPRESA = P_EMP;
		
        --ATRIBUINDO VALORES
		 P_SALDO := P_QTD_PLAN - (C_APONT.QTD_PROD+P_QTD_APON);
		 P_SALDO_AUX := P_SALDO;
	--END
END LOOP; --FIM FIM LOOP APONTAMENTO	

--INICIO DO SEGUNDO BLOCO CONSUMINDO NECESSIDADES E MOVIMENTANDO ESTOQUE	

--ZERANDO VARIAVEIS
    DBMS_OUTPUT.PUT_LINE('MATERIAS CONSUMIDOS');
	--DECLARANDO CURSOR NECESSIDADES
	       
	--SELECIONANDO VALORES
	FOR C_NECESSIDADES IN (SELECT A.ID_ORDEM,A.SITUACAO,A.COD_MAT_PROD,
	A.QTD_PLAN,B.COD_MAT_NECES,B.QTD_NECES,
	P_QTD_APON QTD_APON,
	P_QTD_APON*B.QTD_NECES QTD_NECES_CONS
	FROM ORDEM_PROD A
	
    INNER JOIN FICHA_TECNICA B
	ON A.COD_MAT_PROD=B.COD_MAT_PROD
    AND A.COD_EMPRESA=B.COD_EMPRESA
    
	WHERE A.SITUACAO='P'
	AND A.ID_ORDEM=P_ID_ORDEM --PARAMENTRO DE ORDEM
	AND A.COD_MAT_PROD=P_COD_MAT_PROD --PARAMETEO MAT PROD
    AND A.COD_EMPRESA=P_EMP ) --PARAMENTRO EMPRESA
    LOOP
	--ABRINDO CURSOR NECESSIDADES
	
   
	--DECLARANDO CURSOR PARA ALIMENTAR CONSUMO E MOVIMENTAR ESTOQUE
	
	FOR C_EST_CONS IN (SELECT C.COD_MAT,C.QTD_LOTE,C.LOTE
		FROM  ESTOQUE_LOTE C
		WHERE C.COD_MAT=C_NECESSIDADES.COD_MAT_NECES
        AND C.COD_EMPRESA=P_EMP --PARAMENTRO EMPRESA
		AND C.QTD_LOTE>0
	ORDER BY C.COD_MAT,C.LOTE) LOOP
	--ABRINDO CURSOR
	
	--ATRIBUINDO VALORES A VARIAVEIS
        P_SALDO:=C_NECESSIDADES.QTD_NECES_CONS;
        P_SALDO_AUX:=P_SALDO;
	
    

	--TESTES
	--VERIFICAÇOES DE TROCA DE MATERIAL
			  IF P_COD_MAT_AUX<>C_NECESSIDADES.COD_MAT_NECES THEN
			   
                P_QTD_ATEND:=0;
               
			  END IF;
--VERIFICACOES DE SALDO	 <= 0	 
			  IF P_SALDO<=0 THEN
			   
			   P_QTD_ATEND:=0;
               
			  END IF;
--VERIFICANDO SE SALDO_AUX MAIOR IGUAL A QTD_LOTE
			  IF  P_SALDO_AUX>=C_EST_CONS.QTD_LOTE THEN
			   
			  --ATRIBUINDO VALORES
			        P_QTD_ATEND:=C_EST_CONS.QTD_LOTE;
				    P_SALDO:=P_SALDO-C_NECESSIDADES.QTD_NECES_CONS;
				    P_SALDO_AUX:=P_SALDO_AUX-C_EST_CONS.QTD_LOTE;
				    	  
--VERIFICANDO SE SALDO_AUX MENOR A QTD_LOTE
			  ELSIF  P_SALDO_AUX<C_EST_CONS.QTD_LOTE THEN
			   
			  --ATRIBUINDO VALORES
				    P_SALDO:=C_NECESSIDADES.QTD_NECES_CONS;
				    P_QTD_ATEND:=P_SALDO_AUX;
				    P_SALDO_AUX:=P_SALDO_AUX-P_QTD_ATEND;
			  
			  END IF;
		--IF PARA INSERIR APENAS RETORNO COM SALDO>=0 E QTD_ATEND>0  
        IF P_SALDO_AUX>=0 AND P_QTD_ATEND>0 THEN
	      
		
		--EXCUTANDO PROCEDURE DE MOV ESTOQUE DENTRO DO IF, RECEBENDO VARIAVEIS
		 --INSERT NA TABELA CONSUMO PARA RASTREABILIDADE
		  INSERT INTO CONSUMO VALUES (P_ID_APON,P_EMP,C_NECESSIDADES.COD_MAT_NECES,P_QTD_ATEND,C_EST_CONS.LOTE);
		
		--EXECUTA PROC GERA ESTOQUE COM MOV SAIDA
		 PRC_MOV_ESTOQUE ('S',P_EMP,C_NECESSIDADES.COD_MAT_NECES,C_EST_CONS.LOTE,P_QTD_ATEND,P_DATA_MOVTO);
		--ATRIBUINDO VALOR VARIAVEL 
		 P_COD_MAT_AUX:=C_NECESSIDADES.COD_MAT_NECES;
         --PRINT
         DBMS_OUTPUT.PUT_LINE('COD MAT: '||C_NECESSIDADES.COD_MAT_NECES||' QTD ATEND: '||P_QTD_ATEND||' LOTE: '||C_EST_CONS.LOTE||' SALDO AUX: '||P_SALDO_AUX);
	    END IF;
        
        --SE SALDO AUXILAR IGUAL A ZERO SAI DO LOOP E INICIA PROXIMO MATERIAL    
        IF  P_SALDO_AUX=0 THEN
           EXIT;
        END IF;   
  
  END LOOP; --FIM LOOP C_EST_CONS 
  END LOOP; --FIM LOOP NECESSIDADES
  
  COMMIT;
  
  DBMS_OUTPUT.PUT_LINE('FINALIZADO COM SUCESSO!');

EXCEPTION
    WHEN V_ORDER_N_EXISTE THEN
        DBMS_OUTPUT.PUT_LINE('ORDEM NAO EXISTE OU SEM SALDO/PARAMETROS INCORRETOS');
        ROLLBACK;
    
    WHEN V_MAT_NEC_INSUF THEN
        DBMS_OUTPUT.PUT_LINE('MATERIAIS NECESSARIOS INSUFICENTE');
        ROLLBACK;
    
      WHEN V_SALDO_INSUF_ORDEM THEN
        DBMS_OUTPUT.PUT_LINE('SALDO INSUFICIENTE DA ORDEM');
        ROLLBACK;
    
        
     WHEN  NO_DATA_FOUND  THEN
        DBMS_OUTPUT.PUT_LINE('NAO EXISTE DADOS!');
        ROLLBACK;
        
     WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('OUTROS CODIGO DO ERRO '||SQLCODE||' MSG '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Linha: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
        ROLLBACK;

END; 

--TESTANDO PROCEDURE
--VERIFICANDO ORDEM
SELECT * FROM ORDEM_PROD
WHERE ID_ORDEM=3 AND COD_EMPRESA=1;

--VERIFICANDO ESTOQUE
SELECT * FROM ESTOQUE WHERE COD_EMPRESA=1 AND COD_MAT=1;

SELECT * FROM ESTOQUE_LOTE WHERE COD_EMPRESA=1 AND COD_MAT=1;


--VERIFICANDO APONTAMENTO
SELECT * FROM APONTAMENTOS
WHERE COD_EMPRESA=1 AND ID_ORDEM=3;

--VERIFACANDO CONSUMO
SELECT * FROM CONSUMO
WHERE ID_APON=2
 AND COD_EMPRESA=1;
 
--VERIFICANDO SE MATERIAL NECESSARIO EXISTE
SELECT A.COD_EMPRESA,A.ID_ORDEM,A.COD_MAT_PROD,A.QTD_PLAN,A.QTD_PROD,
	A.QTD_PLAN-A.QTD_PROD SALDO,
	 B.COD_MAT_NECES,D.DESCRICAO,
	 B.QTD_NECES,
	 (A.QTD_PLAN-A.QTD_PROD)*B.QTD_NECES QTD_REAL_NEC,
	 NVL(C.QTD_SALDO,0) AS QTD_SALDO,
	 CASE WHEN  (A.QTD_PLAN-A.QTD_PROD)*B.QTD_NECES>NVL(C.QTD_SALDO,0)
	   THEN 'FALTA ESTOQUE' ELSE 'OK' END MSG
	 FROM ORDEM_PROD A
	 INNER JOIN FICHA_TECNICA B
	 ON A.COD_MAT_PROD=B.COD_MAT_PROD
     AND A.COD_EMPRESA=B.COD_EMPRESA
     
	 LEFT JOIN ESTOQUE C
	 ON B.COD_MAT_NECES=C.COD_MAT
     AND A.COD_EMPRESA=C.COD_EMPRESA
     
	 INNER JOIN MATERIAL D
	 ON B.COD_MAT_NECES=D.COD_MAT
     AND A.COD_EMPRESA=D.COD_EMPRESA
	 WHERE (A.QTD_PLAN-A.QTD_PROD)<>0
     AND A.COD_EMPRESA=1  --empresa
     AND A.ID_ORDEM=3;    --ordem de producao

--PARAMETROS (P_EMP - P_ID_ORDEM -P_COD_MAT_PROD - P_QTD_APON - P_LOTE_PROD)
SET SERVEROUTPUT ON
EXECUTE PROC_APONTAMENTO (1,3,1,5,'QWE');

SELECT * FROM NOTA_FISCAL;

--PARAMENTROS (P_EMP IN NUMBER, P_NUM_NF NUMBER, P_DATA_MOVT
--ALIMENTANDO ESTOQUE COM NF DE ENTRADAS
SET SERVEROUTPUT ON

EXECUTE PROC_INTEGR_NF_ESTOQUE (1,16,'15/01/2018');
EXECUTE PROC_INTEGR_NF_ESTOQUE (1,17,'15/01/2018');
EXECUTE PROC_INTEGR_NF_ESTOQUE (1,18,'15/01/2018');

--SELECT * FROM ESTOQUE
--SELECT * FROM ESTOQUE_LOTE


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
106.PROCEDURE FOLHA DE PAGAMENTO

-- CORRIGINDO DATA DE ADMISSAO
SELECT *  FROM FUNCIONARIO
where TO_CHAR(DATA_ADMISS,'YYYY') = '1917';

UPDATE FUNCIONARIO 
SET DATA_ADMISS = TO_CHAR(DATA_ADMISS,'DD/MM')||'/2017'
where TO_CHAR(DATA_ADMISS,'YYYY') = '1917';
COMMIT;

SELECT MATRICULA,
       TO_CHAR(DATA_ADMISS,'DD/MM/YYYY') AS DATA_ADMISS
FROM FUNCIONARIO
--where TO_CHAR(DATA_ADMISS,'YYYY')='1917';


--SELECT * FROM FOLHA_PAGTO
--PROCEDURE FOLHA PGTO
--GERA INFORMACOES PARA PAGAMENTO
--TABELAS ORIGEM SALARIO
--TABELA DE FUNCIONARIO VERIFICAO ADMISSAO E DEMISSAO
--TAB PARAMETROS, PARAM_INSS, PARAM_IRRF
--TABELAS DESTINO FOLHA PAGTO
--PARAMETROS, MES_REF, ANO_REF,DATA_PAGTO
--EXEC PROC_FOLHA 3,2017,'2017-03-05'
--SELECT * FROM FOLHA_PAGTO


--
CREATE OR REPLACE PROCEDURE  PROC_FOLHA (P_EMP IN NUMBER,
                                         P_MES_REF IN VARCHAR2,
                                         P_ANO_REF IN VARCHAR2,
                                         P_DATA_PAGTO DATE)
IS	
		SALARIO_LIQ DECIMAL(10,2);
		VAL_INSS DECIMAL(10,2);
		VAL_IRPF DECIMAL(10,2);
		VAL_ISENT_IRPF DECIMAL(10,2);

BEGIN  
--APAGANDO REGISTRO PARA RECALCULAR
DBMS_OUTPUT.PUT_LINE('APAGANDO REGISTROS PARA RECALCULO');

DELETE FROM FOLHA_PAGTO WHERE MES_REF = P_MES_REF AND ANO_REF = P_ANO_REF AND COD_EMPRESA = P_EMP;
--DECLARANDO CURSOR PARA LER SALARIO BRUTO
FOR SAL_BRUTO IN (SELECT A.COD_EMPRESA,A.MATRICULA,A.SALARIO AS SALARIO_BRUTO   
     FROM SALARIO A
	 INNER JOIN FUNCIONARIO B
	 ON A.MATRICULA=B.MATRICULA
     AND A.COD_EMPRESA=B.COD_EMPRESA
	  WHERE  B.DATA_ADMISS<=LAST_DAY('01/'||P_MES_REF||'/'||P_ANO_REF)
      AND A.COD_EMPRESA=P_EMP
      AND  B.DATE_DEMISS IS NULL) LOOP


    --INSERT DE VALORES BRUTOS
	INSERT INTO FOLHA_PAGTO (COD_EMPRESA,MATRICULA,TIPO_PGTO,TIPO,EVENTO,MES_REF,ANO_REF,DATA_PAGTO,VALOR) VALUES 
	(SAL_BRUTO.COD_EMPRESA,SAL_BRUTO.MATRICULA,'F','P','SAL BRUTO',P_MES_REF,P_ANO_REF,P_DATA_PAGTO,SAL_BRUTO.SALARIO_BRUTO);

--DECLARANDO CURSOR PARA CALCULAR INSS
 --SELECT * FROM PARAM_INSS
 FOR C_INSS IN (SELECT A.PCT AS PCT_INSS FROM PARAM_INSS A
		WHERE SAL_BRUTO.SALARIO_BRUTO BETWEEN A.VALOR_DE AND A.VALOR_ATE
		AND P_MES_REF BETWEEN TO_CHAR(A.VIGENCIA_INI,'MM') AND TO_CHAR(A.VIGENCIA_FIM,'MM')
		AND P_ANO_REF BETWEEN TO_CHAR(A.VIGENCIA_INI,'YYYY') AND TO_CHAR(A.VIGENCIA_FIM,'YYYY')) LOOP

	--REGRA DE TETO DE INSS QUANDO SALARIO MAIOR QUE 5531.31

	IF SAL_BRUTO.SALARIO_BRUTO>5531.31 THEN
		
			  VAL_INSS:=608.44;
			  C_INSS.PCT_INSS:=0;
		 
		 ELSE
			 VAL_INSS:=SAL_BRUTO.SALARIO_BRUTO/100*C_INSS.PCT_INSS;
     END IF;
	  
       --INSERINDO REGISTRO NA FOLHA PAGTO
		INSERT INTO FOLHA_PAGTO (COD_EMPRESA,MATRICULA,TIPO_PGTO,TIPO,EVENTO,MES_REF,ANO_REF,DATA_PAGTO,VALOR) VALUES 
	 (SAL_BRUTO.COD_EMPRESA,SAL_BRUTO.MATRICULA,'F','D','INSS',P_MES_REF,P_ANO_REF,P_DATA_PAGTO,VAL_INSS);
     
--DECLARANDO CURSOR PARA CALC IRRF	
 --SELECIONANDO VALORES
 --SELECT * FROM PARAM_IRRF
FOR C_IRRF IN (SELECT A.PCT AS PCT_IRPF, A.VAL_ISENT  FROM PARAM_IRRF A
		WHERE SAL_BRUTO.SALARIO_BRUTO BETWEEN A.VALOR_DE AND A.VALOR_ATE
		   AND P_MES_REF BETWEEN TO_CHAR(A.VIGENCIA_INI,'MM') AND TO_CHAR(A.VIGENCIA_FIM,'MM')
		   AND P_ANO_REF BETWEEN TO_CHAR(A.VIGENCIA_INI,'YYYY') AND TO_CHAR(A.VIGENCIA_FIM,'YYYY') )LOOP

			--CALCULO DO IR
             VAL_IRPF:=((SAL_BRUTO.SALARIO_BRUTO-VAL_INSS)/100)*C_IRRF.PCT_IRPF-C_IRRF.VAL_ISENT;
			
			--INSERINTO REGISTRO IR
			INSERT INTO FOLHA_PAGTO (COD_EMPRESA,MATRICULA,TIPO_PGTO,TIPO,EVENTO,MES_REF,ANO_REF,DATA_PAGTO,VALOR) VALUES 
			(SAL_BRUTO.COD_EMPRESA,SAL_BRUTO.MATRICULA,'F','D','IRRF',P_MES_REF,P_ANO_REF,P_DATA_PAGTO,VAL_IRPF);

		
  --CALCULANDO SALARIO LIQUIDO
  SALARIO_LIQ:=SAL_BRUTO.SALARIO_BRUTO-(VAL_INSS+VAL_IRPF);

 INSERT INTO FOLHA_PAGTO (COD_EMPRESA,MATRICULA,TIPO_PGTO,TIPO,EVENTO,MES_REF,ANO_REF,DATA_PAGTO,VALOR) VALUES 
	      (SAL_BRUTO.COD_EMPRESA,SAL_BRUTO.MATRICULA,'F','P','SALARIO LIQUIDO',P_MES_REF,P_ANO_REF,P_DATA_PAGTO,SALARIO_LIQ);
          
          
  
    END LOOP; --FIM CALC INSS
    END LOOP; --FIM CALDO IRRF
    END LOOP; --FIM SALARIO BRUTO
    
    DBMS_OUTPUT.PUT_LINE('CALCULA FINALIZADO!');
    COMMIT;
    
    EXCEPTION
            
     WHEN  NO_DATA_FOUND  THEN
        DBMS_OUTPUT.PUT_LINE('NAO EXISTE DADOS!');
        ROLLBACK;
        
     WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('OUTROS CODIGO DO ERRO '||SQLCODE||' MSG '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('Linha: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
        ROLLBACK;

END; 


--EXCUTANDO PROCEDURE
--PARAMENTROS: EMPRESA, MES_REF, ANO_REF, DATA_PAGTO
SET SERVEROUTPUT ON
EXECUTE PROC_FOLHA (1,'01','2018','05/02/2018');
EXECUTE PROC_FOLHA (1,'02','2018','05/03/2018');

SELECT * FROM FOLHA_PAGTO;
--delete  FROM FOLHA_PAGTO;


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
107.Trigger Bloqueia usuario


--TRIGGER PRA BLOQUEAR USUARIO QUANDO DEMITIDO
CREATE OR REPLACE TRIGGER TG_BLOQUEIA_USUARIO     
    AFTER UPDATE
    OF DATE_DEMISS ON FUNCIONARIO
FOR EACH ROW
BEGIN
    IF (:NEW.DATE_DEMISS IS NOT NULL) THEN
    
        UPDATE USUARIOS SET SITUACAO = 'B' --BLOQUEIA
		WHERE MATRICULA =:OLD.MATRICULA
        AND COD_EMPRESA =:OLD.COD_EMPRESA;
        
    END IF;
    
END;

--TESTE
--TRIGGER PRA BLOQUEAR USUARIO QUANDO DEMITIDO

CREATE OR REPLACE TRIGGER TG_BLOQUEIA_USUARIO     
    AFTER UPDATE
    OF DATE_DEMISS ON FUNCIONARIO  -- SOMENTE DISPARA NESSA TABELA, QUANDO O CAMPO DATE_DEMISS FOR PREENCHIDO...
FOR EACH ROW
BEGIN
    IF (:NEW.DATE_DEMISS IS NOT NULL) THEN
    
        UPDATE USUARIOS SET SITUACAO = 'B' --BLOQUEIA
		WHERE MATRICULA =:OLD.MATRICULA
        AND COD_EMPRESA =:OLD.COD_EMPRESA;
        
    END IF;
    
END;

--TESTE
SELECT * FROM FUNCIONARIO
WHERE COD_EMPRESA = '1'
AND MATRICULA = '11';

SELECT * FROM USUARIOS
WHERE COD_EMPRESA = '1'
AND MATRICULA = '11';

--update teste trigger 
--OBSERVAÇÃO EFETUAR O COMMIT;
UPDATE FUNCIONARIO 
SET DATE_DEMISS = SYSDATE
WHERE COD_EMPRESA = '1'
AND MATRICULA = '11';
COMMIT;


SELECT * FROM USUARIOS
WHERE COD_EMPRESA = '1'
AND MATRICULA = '11';

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
108.Trigger Auditoria de Salario

--CRIACAO TRIGGER AUDITA SALARIO
--DROP TRIGGER TG_AUDIT_SAL 
--TRIGGER PARA AUDITAR ALTERACOES DE SALARIO

 
CREATE OR REPLACE TRIGGER TG_AUDIT_SAL
AFTER INSERT OR UPDATE OF SALARIO ON SALARIO -- OF CAMPO// ON TABELA
  FOR EACH ROW

BEGIN
    IF inserting THEN 
     
      INSERT INTO AUDITORIA_SALARIO VALUES 
        (:NEW.COD_EMPRESA,:NEW.MATRICULA,0,:NEW.SALARIO,USER,SYSDATE);
              
      
    ELSIF updating THEN 
      
       INSERT INTO AUDITORIA_SALARIO VALUES 
                   (:NEW.COD_EMPRESA,:NEW.MATRICULA,:OLD.SALARIO,:NEW.SALARIO,USER,SYSDATE);
    
    END IF;
END;


--TESTE
SELECT * FROM AUDITORIA_SALARIO;
SELECT * FROM SALARIO;

UPDATE SALARIO SET SALARIO = SALARIO *1.05
WHERE COD_EMPRESA = 1
AND MATRICULA = 8;
COMMIT;

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
109.VIEWS FUNCIONARIO

--V_FUNCIONARIO
--TABELAS FUNCIONARIO,CARGOS,CENTRO_CUSTO
--SELECT * FROM V_FUNCIONARIO

CREATE OR REPLACE VIEW V_FUNCIONARIO
AS
	SELECT A.COD_EMPRESA,
           A.MATRICULA,
		   A.COD_CC,
           C.NOME_CC,  
		   A.NOME,
           A.COD_CARGO,
		   B.NOME_CARGO,
		   A.DATA_ADMISS,
		   A.DATE_DEMISS,
		   
           CASE WHEN A.DATE_DEMISS IS  NULL THEN 'ATIVO'
		         ELSE 'DESLIGADO' END SITUACAO
		FROM 
		 FUNCIONARIO A
		 INNER JOIN CARGOS B
		 ON A.COD_CARGO = B.COD_CARGO
         AND A.COD_EMPRESA = B.COD_EMPRESA
         
		 INNER JOIN CENTRO_CUSTO C
		 ON A.COD_CC = C.COD_CC
         AND A.COD_EMPRESA = C.COD_EMPRESA;
         
--TESTANDO VIEW  

SELECT * FROM V_FUNCIONARIO



------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
110.VIEW FATURAMENTO




--V_FATURAMENTO
--NOTA_FISCAL, NOTA_FISCAL_ITENS,MATERIAL,CLIENTES, CIDADES,
--SELECT * FROM MATERIAL
--SELECT * FROM CLIENTES
--SELECT * FROM CIDADES

    CREATE OR REPLACE VIEW V_FATURAMENTO
    AS
    SELECT A.COD_EMPRESA,
           A.NUM_NF,
           A.ID_CLIFOR,
           A.DATA_EMISSAO,
           B.COD_MAT,
           C.DESCRICAO,
           D.RAZAO_CLIENTE,
           E.NOME_CIDADE,
           B.QTD,
           B.VAL_UNIT,
           B.QTD*B.VAL_UNIT as  TOTAL
    FROM NOTA_FISCAL A 
    INNER JOIN NOTA_FISCAL_ITENS B
    ON A.NUM_NF=B.NUM_NF
    AND A.COD_EMPRESA=B.COD_EMPRESA
    
    INNER JOIN MATERIAL C
    ON B.COD_MAT=C.COD_MAT
    AND A.COD_EMPRESA=C.COD_EMPRESA
    
    INNER JOIN CLIENTES D
    ON A.ID_CLIFOR=D.ID_CLIENTE
    AND A.COD_EMPRESA=D.COD_EMPRESA
    
    INNER JOIN CIDADES E
    ON D.COD_CIDADE=E.COD_CIDADE
    WHERE A.TIP_NF='S';
    
    --TESTANDO A VIEW
    SELECT * FROM V_FATURAMENTO
    where COD_EMPRESA = 1
    ORDER BY NUM_NF;
    


--CRIAMOS INDICE PARA MELHORAR PERFORMANCE
--CREATE INDEX IX_FAT1 ON NOTA_FISCAL(TIP_NF)

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
111.VIEW NECESSIDADES DE ESTOQUE

--V_NECCESSIDADES
--ORDEM_PROD,FICHA_TECNICA, ESTOQUE,MATERIAL

CREATE OR REPLACE VIEW V_NECCESSIDADES
   AS
	SELECT A.COD_EMPRESA,
           A.ID_ORDEM,
           A.COD_MAT_PROD,
           A.QTD_PLAN,
           A.QTD_PROD,
	       A.QTD_PLAN-A.QTD_PROD SALDO,
	       B.COD_MAT_NECES,
           D.DESCRICAO,
	       B.QTD_NECES,
	       (A.QTD_PLAN-A.QTD_PROD)*B.QTD_NECES as QTD_REAL_NEC,
	      NVL(C.QTD_SALDO,0) AS QTD_SALDO,
          CASE WHEN  (A.QTD_PLAN-A.QTD_PROD)*B.QTD_NECES>NVL(C.QTD_SALDO,0)
                    THEN 'FALTA ESTOQUE' 
               ELSE 'OK' END MSG
	 FROM ORDEM_PROD A
	 INNER JOIN FICHA_TECNICA B
	 ON A.COD_MAT_PROD=B.COD_MAT_PROD
     AND A.COD_EMPRESA=B.COD_EMPRESA
     
	 LEFT JOIN ESTOQUE C
	 ON B.COD_MAT_NECES=C.COD_MAT
     AND A.COD_EMPRESA=C.COD_EMPRESA
     
	 INNER JOIN MATERIAL D
	 ON B.COD_MAT_NECES=D.COD_MAT
     AND A.COD_EMPRESA=D.COD_EMPRESA
	 WHERE (A.QTD_PLAN-A.QTD_PROD)<>0;
	 
     --TESTE
     SELECT * FROM V_NECCESSIDADES
     WHERE COD_EMPRESA=1
     AND ID_ORDEM=3;
     
     SELECT * FROM FICHA_TECNICA
     WHERE COD_MAT_PROD='1';
	 
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
112.VIEW FINANCEIRO


	 
--V_CONTAS_PAGAR
--CONTAS_PAGAR,FORNECEDORES
--SELECT * FROM V_CONTAS_PAGAR

CREATE OR REPLACE VIEW V_CONTAS_PAGAR
AS
SELECT A.COD_EMPRESA,
       A.ID_DOC,
       A.ID_FOR,
       B.RAZAO_FORNEC,
       A.PARC,
       A.DATA_VENC,
       A.DATA_PAGTO,
       A.VALOR,
       CASE WHEN A.DATA_PAGTO IS NULL THEN 'ABERTO' ELSE 'PAGO' END SITUACAO,
       CASE WHEN A.DATA_VENC > SYSDATE THEN 'NORMAL' 
     WHEN A.DATA_PAGTO > A.DATA_VENC   THEN 'PAGTO EF COM ATRASO'
     ELSE 'VENCIDO' END MSG
 FROM CONTAS_PAGAR A
 INNER JOIN FORNECEDORES B
 ON A.ID_FOR=B.ID_FOR
 AND A.COD_EMPRESA=B.COD_EMPRESA;
 
 
 SELECT * FROM V_CONTAS_PAGAR;
 /*
 UPDATE CONTAS_PAGAR SET DATA_PAGTO=SYSDATE
 WHERE ID_DOC='1' AND PARC='1' AND COD_EMPRESA=1;
 */
--V_CONTAS_RECEBER
--CONTAS_RECEBER,CLIENTES
    CREATE OR REPLACE VIEW V_CONTAS_RECEBER
    AS
    SELECT A.COD_EMPRESA, 
           A.ID_DOC,
           A.ID_CLIENTE,
           B.RAZAO_CLIENTE,
           A.PARC,
           A.DATA_VENC,
           A.DATA_PAGTO,
           A.VALOR,
           CASE WHEN A.DATA_PAGTO IS NULL THEN 'ABERTO' ELSE 'PAGO' END SITUACAO,
           CASE WHEN A.DATA_VENC>SYSDATE THEN 'NORMAL' 
                WHEN A.DATA_PAGTO>A.DATA_VENC   THEN 'PAGTO EM COM ATRASO'
                ELSE 'VENCIDO' END MSG,
           CASE WHEN A.DATA_VENC=A.DATA_PAGTO THEN 0
                WHEN A.DATA_PAGTO>A.DATA_VENC THEN CAST(CAST(A.DATA_PAGTO AS DATE)-CAST(A.DATA_VENC AS DATE) AS INT )
                ELSE 
          CAST(SYSDATE-CAST(A.DATA_VENC AS DATE) AS INT ) END DIAS_ATRASO
     FROM CONTAS_RECEBER A
     INNER JOIN CLIENTES B
     ON A.ID_CLIENTE=B.ID_CLIENTE
     AND A.COD_EMPRESA=B.COD_EMPRESA;

 /*
 UPDATE CONTAS_RECEBER SET DATA_PAGTO='05/04/2018'
 WHERE ID_DOC=21 AND PARC=1  AND COD_EMPRESA=1;
 */

SELECT * FROM V_CONTAS_RECEBER;


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
113.VIEW FINANCEIRO


--MATERIAL,FICHA_TECNICA
CREATE OR REPLACE VIEW V_CUSTO_PRODUTO_DET
AS
SELECT A.COD_EMPRESA,
       A.COD_MAT,
       A.DESCRICAO,
       B.COD_MAT_NECES,
       C.DESCRICAO AS DESCRICAO_MAT_NEC,
       B.QTD_NECES,
       C.PRECO_UNIT,
       B.QTD_NECES * C.PRECO_UNIT CUSTO_NEC
 FROM MATERIAL A
 INNER JOIN FICHA_TECNICA B
 ON A.COD_MAT = B.COD_MAT_PROD
 AND A.COD_EMPRESA = B.COD_EMPRESA
 
 INNER JOIN MATERIAL C
 ON B.COD_MAT_NECES = C.COD_MAT
 AND A.COD_EMPRESA = C.COD_EMPRESA
 WHERE A.COD_TIP_MAT = 2; --TIPO 2 MATERIAL PRODUZIDO
--AND A.COD_EMPRESA=1


-- TESTE VIEW
    SELECT * FROM V_CUSTO_PRODUTO_DET
    WHERE COD_EMPRESA=1
    AND COD_MAT=1;

--CRIICAO VIEW RESUMO DE CUSTO
    CREATE OR REPLACE VIEW V_CUSTO_PRODUTO_RESUMO
    AS
 SELECT A.COD_EMPRESA,
        A.COD_MAT,
        A.DESCRICAO,
        SUM(B.QTD_NECES*C.PRECO_UNIT) CUSTO,
        A.PRECO_UNIT PRECO_VENDA
        FROM MATERIAL A
        INNER JOIN FICHA_TECNICA B
        ON A.COD_MAT=B.COD_MAT_PROD
        AND A.COD_EMPRESA=B.COD_EMPRESA
         
        INNER JOIN MATERIAL C
        ON B.COD_MAT_NECES=C.COD_MAT
        AND A.COD_EMPRESA=C.COD_EMPRESA
         
        WHERE A.COD_TIP_MAT=2 --TIPO 2 MATERIAL PRODUZIDO
        GROUP BY A.COD_EMPRESA,A.COD_MAT,A.DESCRICAO,A.PRECO_UNIT;
        
    --TESTE VIEW
    
    SELECT * FROM V_CUSTO_PRODUTO_RESUMO
    WHERE COD_EMPRESA=1
    --AND COD_MAT=1;


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
114.VIEW CANAL DE VENDAS 

--V_CANAL_VENDAS
--CLIENTES,CANAL_VENDAS_G_V, CANAL_VENDAS_V_C


CREATE OR REPLACE  VIEW V_CANAL_VENDAS
AS
SELECT A.COD_EMPRESA,
       A.ID_CLIENTE,
       A.RAZAO_CLIENTE,
       NVL(B.ID_VEND,0)ID_VEND,
       NVL(D.NOME,'SEM CANAL')NOME_VEND,
       NVL(E.ID_GER,0) ID_GER,
       NVL(G.NOME,'SEM CANAL') NOME_GER
       
    FROM CLIENTES A
    LEFT JOIN CANAL_VENDAS_V_C B
    ON A.ID_CLIENTE=B.ID_CLIENTE
    AND A.COD_EMPRESA=B.COD_EMPRESA
    
    LEFT JOIN VENDEDORES C
    ON B.ID_VEND=C.ID_VEND
    AND A.COD_EMPRESA=C.COD_EMPRESA
    
    LEFT JOIN FUNCIONARIO D
    ON C.MATRICULA=D.MATRICULA
    AND A.COD_EMPRESA=D.COD_EMPRESA
    
    LEFT JOIN CANAL_VENDAS_G_V E
    ON B.ID_VEND=E.ID_VEND
    AND A.COD_EMPRESA=E.COD_EMPRESA
    
    LEFT JOIN GERENTES F
    ON E.ID_GER=F.ID_GER
    AND A.COD_EMPRESA=F.COD_EMPRESA
    
    LEFT JOIN FUNCIONARIO G
    ON F.MATRICULA=G.MATRICULA
    AND A.COD_EMPRESA=G.COD_EMPRESA;

-- TESTANDO A VIEW

SELECT * FROM V_CANAL_VENDAS;


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
115.EXPORTANDO TESTE PARA PRODUÇÃO 

Vamos rxportar esse TB_space TST para produção.


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
SECAO 15: Extra - Bonus

116.Pivot - Transformando linhas em colunas

PIVOT:
	Apresenta as informações em um relatório com referências cruzadas com formato de planilha eletrônica a partir de qualquer tabela relacional usando código
	SQL.
	Funções:
	Agregação: sum, count, min, max, or avg
	Operador: In (expr1,expr2, ...expr_n)
	SubQuery: Pode ser utilizado para lista de valores
	
	




--CRIANDO TABELA PARA USO DE PIVOT
--DROP TABLE VOLUME_VENDAS
CREATE TABLE VOLUME_VENDAS
(
 PRODUTO VARCHAR2(50) NOT NULL,
 DEPTO    VARCHAR2(15) NOT NULL,
 QTDE     INT          NOT NULL,
 MES      INT          NOT NULL
 );
 

 
--CARGA DE DADOS
insert into volume_vendas values ('Pão','Padaria','72','1');
insert into volume_vendas values ('Roscas','Padaria','34','1');
insert into volume_vendas values ('Biscoitos','Padaria','45','1');
insert into volume_vendas values ('Bolos','Confeitaria','11','1');
insert into volume_vendas values ('Tortas','Confeitaria','96','1');
insert into volume_vendas values ('Pão','Padaria','52','2');
insert into volume_vendas values ('Roscas','Padaria','47','2');
insert into volume_vendas values ('Biscoitos','Padaria','31','2');
insert into volume_vendas values ('Bolos','Confeitaria','60','2');
insert into volume_vendas values ('Tortas','Confeitaria','38','2');
insert into volume_vendas values ('Pão','Padaria','29','3');
insert into volume_vendas values ('Roscas','Padaria','63','3');
insert into volume_vendas values ('Biscoitos','Padaria','95','3');
insert into volume_vendas values ('Bolos','Confeitaria','73','3');
insert into volume_vendas values ('Tortas','Confeitaria','72','3');
insert into volume_vendas values ('Pão','Padaria','82','4');
insert into volume_vendas values ('Roscas','Padaria','72','4');
insert into volume_vendas values ('Biscoitos','Padaria','61','4');
insert into volume_vendas values ('Bolos','Confeitaria','70','4');
insert into volume_vendas values ('Tortas','Confeitaria','30','4');
insert into volume_vendas values ('Pão','Padaria','85','5');
insert into volume_vendas values ('Roscas','Padaria','48','5');
insert into volume_vendas values ('Biscoitos','Padaria','50','5');
insert into volume_vendas values ('Bolos','Confeitaria','17','5');
insert into volume_vendas values ('Tortas','Confeitaria','15','5');
insert into volume_vendas values ('Pão','Padaria','23','6');
insert into volume_vendas values ('Roscas','Padaria','67','6');
insert into volume_vendas values ('Biscoitos','Padaria','94','6');
insert into volume_vendas values ('Bolos','Confeitaria','80','6');
insert into volume_vendas values ('Tortas','Confeitaria','58','6');

--USANDO PIVOT
--SELECT * FROM VOLUME_VENDAS;
SELECT * FROM 
            (SELECT PRODUTO,QTDE,MES FROM volume_vendas)
PIVOT
    (SUM(QTDE)
     FOR MES IN (1,2,3,4,5,6)
    )
    ORDER BY PRODUTO;
    
--Formantando as colunas Pivot
SELECT * FROM 
            (SELECT PRODUTO,QTDE,MES FROM volume_vendas)
PIVOT
    (
    SUM(QTDE)
    FOR MES IN (1 AS "jan",2 AS "Fev",3 AS "Mar",4 AS "Abr",5 AS "Mai",6 AS "Jun")
    )
    ORDER BY PRODUTO

--Formantando Pivot   

SELECT * FROM 
            (SELECT DEPTO,QTDE,MES FROM volume_vendas)
PIVOT
    (
    SUM(QTDE)
    FOR DEPTO IN ('Padaria' as "Padaria",'Confeitaria' as "Confeitaria")
    )
    ORDER BY MES

--Formantando Pivot    
SELECT * FROM 
            (SELECT DEPTO,
                    QTDE,
                    MES,
                    TO_CHAR(TO_DATE(MES,'MM'),'MONTH') AS MES_NOME 
             FROM volume_vendas
             )
PIVOT
    (
    SUM(QTDE)
    FOR DEPTO IN ('Padaria' as "Padaria",'Confeitaria' as "Confeitaria")
    )
    ORDER BY MES
    
    
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------     
																	-- FIM DO TREINAMENTO --
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------











































	